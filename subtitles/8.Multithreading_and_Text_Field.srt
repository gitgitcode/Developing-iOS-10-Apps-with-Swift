1
00:00:00,668 --> 00:00:07,105
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:07,174 --> 00:00:13,044
>> Welcome to Stanford CS193, winter quarter of 2017.
欢迎参加 2017 年冬季学期斯坦福 CS193P 课程

3
00:00:13,113 --> 00:00:17,782
Today I'm going to continue that demo that we started last

4
00:00:17,851 --> 00:00:19,434
I'm really just going to enhance it to be multiple MVC
我将把它提升为多个MVC

5
00:00:19,435 --> 00:00:21,018
time.
时间。

6
00:00:21,087 --> 00:00:24,422
again, it gives you a chance to see it all happen again.
再一次，它给你一个机会，让你看到它再次发生。

7
00:00:24,491 --> 00:00:26,224
And I'm gonna be going very quickly for
我很快就会讲

8
00:00:26,293 --> 00:00:28,893
doing that because we already did that in the last demo, so
因为我们在上次的演示中已经做过了

9
00:00:28,962 --> 00:00:30,328
and you did it on your homework,
你做作业的时候，

10
00:00:30,397 --> 00:00:32,697
so hopefully it's really, really comfortable.
希望它非常非常舒服。

11
00:00:32,766 --> 00:00:35,633
Now we're going to dive back into the slides and
现在我们要回到幻灯片

12
00:00:35,702 --> 00:00:38,937
solve a problem that we're going to have with our app,
解决了我们的应用程序的问题，

13
00:00:39,006 --> 00:00:41,373
which is that it's really slow.
它的速度很慢。

14
00:00:41,442 --> 00:00:44,309
And not only really slow, but it blocks our user interface
不仅很慢，而且还会阻塞我们的用户界面

15
00:00:44,378 --> 00:00:47,712
so that the user thinks the app is probably dead and
用户认为这款应用可能已经死了

16
00:00:47,781 --> 00:00:49,514
needs to be killed or something.
需要被杀。

17
00:00:49,583 --> 00:00:52,317
And we're gonna fix that with multithreading, so
我们将用多线程解决这个问题

18
00:00:52,385 --> 00:00:55,286
I'm gonna talk a little about how we do multithreading.
我将简单介绍一下我们是如何多线程的。

19
00:00:55,355 --> 00:00:56,255
I'll go back to the demo,
回到demo，

20
00:00:56,323 --> 00:00:58,123
we'll fix it with multithreading.
我们将用多线程修复它。

21
00:00:58,192 --> 00:01:00,925
I'm gonna show you a couple other cool things to do.
我将给你们展示一些其他很酷的事情。

22
00:01:00,994 --> 00:01:03,528
And then we're gonna come back to the slides and
然后我们会回到幻灯片

23
00:01:03,597 --> 00:01:06,164
I'm gonna talk about text field, which is a little bit
我要讲一下文本框，这有点

24
00:01:06,233 --> 00:01:09,667
of a random topic, but I have to fit it in somewhere.
一个随机的话题，但我必须把它放在某个地方。

25
00:01:09,736 --> 00:01:12,437
And if I have a little time at the end, which I doubt I will,
如果我最后有一点时间，我怀疑我会，

26
00:01:12,506 --> 00:01:15,173
but if I have time at the end, I'll actually get started on
但如果我有时间的话，我会开始的

27
00:01:15,242 --> 00:01:18,009
table view, which is gonna be our big topic for Wednesday.
表格视图，这将是我们周三的大话题。

28
00:01:18,078 --> 00:01:19,178
A very important topic, and
一个非常重要的话题

29
00:01:19,246 --> 00:01:21,280
it's what your next assignment is gonna be about.
这是你的下一个任务。

30
00:01:21,348 --> 00:01:24,082
Sorry, your next assignment has multi-threading as well,
抱歉，下一个作业也有多线程，

31
00:01:24,151 --> 00:01:26,852
of course, but it's mostly a table view assignment, so
当然，但这主要是一个表视图赋值

32
00:01:26,920 --> 00:01:28,519
that's what we're gonna do today.
这就是我们今天要做的。

33
00:01:28,588 --> 00:01:33,358
So let's jump right back into our demo from last time.
让我们回到上次的演示。

34
00:01:33,427 --> 00:01:35,960
You remember that it looked like this, so
你记得它看起来是这样的

35
00:01:36,029 --> 00:01:37,028
here it is running.
这是跑步。

36
00:01:37,097 --> 00:01:42,167
And this was a nice little image viewing application so
这是一个很好的图像浏览应用程序

37
00:01:42,236 --> 00:01:46,338
far, and we can zoom in and out, and pan around, and
我们可以放大，缩小，平移

38
00:01:46,406 --> 00:01:47,138
all that.
这一切。

39
00:01:47,207 --> 00:01:50,308
And in fact, in building this application,
实际上，在构建这个应用程序时，

40
00:01:50,377 --> 00:01:54,746
I've built this nice generic ImageViewController.
我构建了一个很好的通用ImageViewController。

41
00:01:54,814 --> 00:01:58,049
It's a reusable MVC, just like in your assignment,
这是一个可重用的MVC，就像你的作业一样，

42
00:01:58,118 --> 00:02:01,486
you built a reusable graphing view controller, well,
你建立了一个可复用的图形视图控制器，

43
00:02:01,555 --> 00:02:04,622
I've built a generic MVC that will show an image and
我已经构建了一个通用的MVC，它将显示一个图像和

44
00:02:04,691 --> 00:02:08,460
let you zoom in on it and pan around, so, that's kinda cool.
让你放大它，平移一下，这很酷。

45
00:02:08,528 --> 00:02:14,499
Hopefully you're gaining an appreciation for
希望你在欣赏

46
00:02:14,568 --> 00:02:17,569
good API design, and how important good API design and
良好的API设计，以及良好的API设计和

47
00:02:17,637 --> 00:02:20,839
reusable componentry is to building good architecture in
可重用组件是构建良好的体系结构

48
00:02:20,908 --> 00:02:24,208
general, so hopefully, you're seeing that.
一般，希望你们能看到。

49
00:02:24,277 --> 00:02:26,477
I mean, these are very simple applications that we're
我的意思是，这些都是非常简单的应用

50
00:02:26,546 --> 00:02:27,779
writing, so it's hard to see.
写作，很难看到。

51
00:02:27,848 --> 00:02:30,315
But when you start building a huge app and have these
但当你开始构建一个巨大的应用并拥有这些

52
00:02:30,384 --> 00:02:33,151
reuseable components and really strong public APIs that
可重复使用的组件和真正强大的公共api

53
00:02:33,220 --> 00:02:36,388
you're willing to support, and things like that, then you'll
你愿意支持，这样的事情，你就会

54
00:02:36,456 --> 00:02:38,990
find that your application is gonna have less bugs,
发现你的应用程序会有更少的bug，

55
00:02:39,059 --> 00:02:41,092
and it's gonna be able to grow over time.
随着时间的推移，它也会成长。

56
00:02:41,161 --> 00:02:43,628
And you're gonna be able to work in teams better, so
你可以在团队中工作得更好，所以

57
00:02:43,697 --> 00:02:45,130
it's just good all around.
到处都很好。

58
00:02:46,734 --> 00:02:50,736
In my viewDidLoad, I put that little imageURL equals
在我的viewDidLoad中，我把这个小imageURL等于

59
00:02:50,804 --> 00:02:53,905
DemoURL.stanford that was just for testing.
DemoURL。只是为了测试。

60
00:02:53,974 --> 00:02:55,540
Now that we know that it works,
现在我们知道它起作用了，

61
00:02:55,609 --> 00:02:57,409
I'm just gonna delete that so
我要把它删掉

62
00:02:57,477 --> 00:03:00,812
that my ImageViewController again can be reusable.
我的ImageViewController可以是可重用的。

63
00:03:00,881 --> 00:03:03,882
This is its public API, which happens to be its model.
这是它的公共API，恰好是它的模型。

64
00:03:03,950 --> 00:03:04,750
It's not that unusual,
这并不是说不寻常,

65
00:03:04,818 --> 00:03:08,553
by the way, for the public API of a view controller
顺便说一下，对于视图控制器的公共API

66
00:03:08,622 --> 00:03:12,090
to be to set the model, that's quite actually common.
要建立模型，这很常见。

67
00:03:12,159 --> 00:03:13,758
So that's our model, it's the URL for
这是我们的模型，它是URL

68
00:03:13,827 --> 00:03:15,727
the image you wanna show, and it's public.
你想要展示的形象，以及它的公众形象。

69
00:03:15,796 --> 00:03:19,331
So we're gonna be using that when we build the rest of
我们在构建剩下的部分时会用到它

70
00:03:19,400 --> 00:03:20,899
So our storyboard so far just has this one image view
到目前为止，我们的故事板只有一个图像视图

71
00:03:20,900 --> 00:03:22,399
our app.
我们的应用程序。

72
00:03:22,469 --> 00:03:26,170
controller right here, and I'm just gonna rapidly go through
控制器在这里，我要快速浏览一下

73
00:03:26,239 --> 00:03:27,972
and build a multiple MVC app.
并构建一个多MVC应用程序。

74
00:03:28,041 --> 00:03:31,643
What we're gonna do is just use our generic image
我们要做的就是使用我们的通用图像

75
00:03:31,711 --> 00:03:35,046
controller MVC here to view images related to
控制器MVC用于查看与之相关的图像

76
00:03:35,115 --> 00:03:36,748
the Cassini project,
卡西尼号的项目,

77
00:03:36,817 --> 00:03:41,219
which is a space probe that was sent out to Saturn.
这是一个发射到土星的太空探测器。

78
00:03:41,287 --> 00:03:45,723
To do that, it's gonna be all the things you know.
要做到这一点，它将是你所知道的一切。

79
00:03:45,792 --> 00:03:48,192
I'm going to get it build another MVC, so
我要让它建立另一个MVC

80
00:03:48,261 --> 00:03:51,062
here let's drag out another MVC.
这里我们拖出另一个MVC。

81
00:03:51,131 --> 00:03:53,031
Let's create a class for it.
让我们为它创建一个类。

82
00:03:53,100 --> 00:03:55,300
It's a Cocoa Touch Class, of course,
这是一个Cocoa Touch类，当然，

83
00:03:55,369 --> 00:04:00,038
I'm gonna call it Cassini, my CassiniViewController.
我把它叫做Cassini，我的CassiniViewController。

84
00:04:00,107 --> 00:04:02,540
I'm gonna put it in the same place that I put all my other
我要把它放在我把其他东西放进去的地方

85
00:04:02,609 --> 00:04:05,910
files here, and here's my CassiniViewController.
文件在这里，这是我的CassiniViewController。

86
00:04:05,979 --> 00:04:08,880
I'm gonna remove my ViewController lifecycle but
我要删除我的ViewController生命周期

87
00:04:08,949 --> 00:04:12,951
I'm gonna leave my prepare for segue, without the comments,
我要准备segue，没有注释，

88
00:04:13,019 --> 00:04:16,220
because I am going to be segueing from this
因为我要从这里segue

89
00:04:16,289 --> 00:04:21,193
CassiniViewController to my ImageViewController.
CassiniViewController ImageViewController。

90
00:04:21,261 --> 00:04:23,895
So the way this UI is gonna work is I'm just gonna have
UI的工作方式就是

91
00:04:23,964 --> 00:04:25,563
three buttons here in Cassini,
卡西尼号有三个按钮，

92
00:04:25,632 --> 00:04:28,700
similar to how we had with the emotions application.
类似于我们的情绪应用。

93
00:04:28,769 --> 00:04:33,271
And these three buttons are going to pick these three URLs
这三个按钮将会选择这三个url

94
00:04:33,340 --> 00:04:37,642
right here that are from NASA here, jpl.nasa.gov.
这里是NASA的jpl.nasa.gov。

95
00:04:37,711 --> 00:04:40,612
One's of Cassini itself, one's of the Earth and
一个是卡西尼，一个是地球

96
00:04:40,680 --> 00:04:44,015
one is of Saturn, so we're just gonna have three buttons
一个是土星，所以我们只有三个按钮

97
00:04:44,084 --> 00:04:46,418
that let you pick those three images.
让你选择这三个图像。

98
00:04:47,487 --> 00:04:48,420
So let's build that UI.
我们来构建这个UI。

99
00:04:50,156 --> 00:04:52,490
First of all, let's make sure we set our identity.
首先，让我们确定我们的身份。

100
00:04:52,559 --> 00:04:55,093
We just dragged out a generic ViewController,
我们只是拖出一个通用的视图控制器，

101
00:04:55,161 --> 00:04:58,296
we obviously want its identity to be a specific subclass,
显然，我们希望它的身份是一个特定的子类，

102
00:04:58,365 --> 00:05:00,765
in this case, the CassiniViewController,
在这个例子中，CassiniViewController，

103
00:05:00,834 --> 00:05:04,068
just like this one is an ImageViewController.
就像这个是ImageViewController。

104
00:05:04,137 --> 00:05:07,405
So let's drag this out to make the button a little bigger,
把这个拖出来，让按钮变大一点，

105
00:05:07,473 --> 00:05:08,640
to get a bigger font.
得到更大的字体。

106
00:05:08,709 --> 00:05:15,113
Try a maybe 40 point, something like that.
试试大概40点，像这样。

107
00:05:15,182 --> 00:05:18,816
The three buttons that I had, one was Earth, I'll just do
我有三个按钮，一个是地球，我就这么做

108
00:05:18,885 --> 00:05:22,754
copy and paste, make a couple more buttons here, another one
复制粘贴，在这里多做几个按钮，另一个

109
00:05:22,822 --> 00:05:25,757
was Cassini itself, another one was Saturn.
卡西尼号本身，另一个是土星。

110
00:05:25,826 --> 00:05:29,828
And we'll just select these and we'll put them in a stack
我们选择这些，然后把它们放到堆栈中

111
00:05:29,896 --> 00:05:33,264
view, and we'll put some spacing between, and
视图，我们会把间隔设为

112
00:05:33,333 --> 00:05:35,667
we'll fill, and fill equally.
我们将填满，并同样填满。

113
00:05:35,736 --> 00:05:38,336
We'll take it and drag it to the middle here.
我们把它拖到中间。

114
00:05:38,405 --> 00:05:40,738
We'll use our blue lines to put it in the middle, so
我们用蓝色的线把它放到中间

115
00:05:40,807 --> 00:05:42,073
that we can go down here, and
我们可以往下走

116
00:05:42,141 --> 00:05:43,875
say Reset to Suggested Constraints.
重置为建议的约束。

117
00:05:43,944 --> 00:05:47,078
We can go to our Size Inspector here just to verify
我们可以去找我们的尺寸检验员来验证一下

118
00:05:47,147 --> 00:05:50,815
that the constraints it added seem like the ones we want,
它添加的约束似乎是我们想要的，

119
00:05:50,884 --> 00:05:53,384
which definitely does seem like that.
这显然是这样的。

120
00:05:53,453 --> 00:05:54,486
Let's go ahead and,
让我们继续,

121
00:05:54,554 --> 00:05:57,022
one thing I wanna show you a little different this
我想向你们展示一个不同的东西

122
00:05:57,090 --> 00:05:59,957
time is before we started with a SplitViewController and
时间是在我们使用SplitViewController开始之前

123
00:06:00,026 --> 00:06:02,226
then I added the navigation controller in.
然后我添加了导航控制器。

124
00:06:02,295 --> 00:06:04,895
In other words, I started with an iPad UI,
换句话说，我从一个iPad UI开始，

125
00:06:04,964 --> 00:06:08,633
building an iPad UI, and then I made it also work on iPhone.
建立一个iPad用户界面，然后我也在iPhone上做了它。

126
00:06:08,702 --> 00:06:10,635
We can do the other way around as well.
我们也可以这样做。

127
00:06:10,703 --> 00:06:14,405
So we could take this view controller, which is the one,
我们可以用这个视图控制器，

128
00:06:14,474 --> 00:06:16,841
the base one that we want to show, and
这是我们想要展示的基础

129
00:06:16,910 --> 00:06:20,512
we can say embed it in a Navigation Controller.
我们可以把它嵌入到导航控制器中。

130
00:06:20,581 --> 00:06:22,213
And then, obviously, we want to make this
显然，我们要做这个

131
00:06:22,282 --> 00:06:24,382
navigation controller be the entry point of our app.
导航控制器是app的入口点。

132
00:06:24,450 --> 00:06:27,084
I don't want to forget that, so I'm just gonna throw that
我不想忘记这个，所以我要把它扔了

133
00:06:27,153 --> 00:06:28,886
little arrow over here onto the left.
小箭头在左边。

134
00:06:28,955 --> 00:06:31,689
And then when we do our segues here,
当我们在这里做segue的时候，

135
00:06:31,758 --> 00:06:35,493
like from Earth over to here, and from Cassini.
从地球到这里，从卡西尼。

136
00:06:35,562 --> 00:06:38,396
And I'm going to Show Detail because I know eventually I'm
我将展示细节，因为我知道最终我是

137
00:06:38,465 --> 00:06:40,799
also going to support the iPad, instead of Show,
也支持iPad，而不是显示，

138
00:06:40,867 --> 00:06:43,335
which would only really support the iPhone.
这只会真正支持iPhone。

139
00:06:43,403 --> 00:06:45,603
Because Show, remember, if you do a Show and
因为Show，记住，如果你做一个节目

140
00:06:45,672 --> 00:06:48,239
you're in the master of an iPad, it'll actually,
你在iPad的主人那里，实际上，

141
00:06:48,308 --> 00:06:50,875
if you're in Navigation Controller in the master of
如果你在导航控制器中

142
00:06:50,944 --> 00:06:53,845
the iPad and you do Show, it's going to replace the mster,
iPad会显示，它将取代mster，

143
00:06:53,914 --> 00:06:56,181
whereas Show Detail replaces the detail.
而显示细节则取代了细节。

144
00:06:57,450 --> 00:06:59,050
So here I have these three segues.
这里有三个segue。

145
00:06:59,119 --> 00:07:01,419
I'm gonna kinda cheat a little bit and
我有点作弊了

146
00:07:01,488 --> 00:07:06,324
have my segue identifiers just be the names of these
我的segue标识符是这些的名称吗

147
00:07:06,393 --> 00:07:09,060
URLs right here, so Cassini, Earth, and Saturn,
这里的url，卡西尼，地球和土星，

148
00:07:09,129 --> 00:07:11,829
that's gonna be my segue identifiers.
这是我的segue标识符。

149
00:07:11,898 --> 00:07:14,799
I say it's cheating because normally your identifier would
我说这是作弊，因为通常你的标识符会

150
00:07:14,868 --> 00:07:16,268
just identify the segue, and
只要识别segue，然后

151
00:07:16,336 --> 00:07:18,803
then you would get the information somewhere else,
然后你会得到其他地方的信息，

152
00:07:18,872 --> 00:07:21,272
but just to make our code really, really simple.
只是为了让我们的代码非常简单。

153
00:07:21,341 --> 00:07:23,474
Oops, that's not Earth, that one's Saturn.
哦，那不是地球，那是土星。

154
00:07:23,543 --> 00:07:27,579
And then let's go to this one, wait, where's our Earth?
然后再看这个，等等，地球在哪里?

155
00:07:27,647 --> 00:07:31,750
And we go to this one, oops, this one rather,
我们看这个，哦，这个，

156
00:07:31,818 --> 00:07:33,384
that is Cassini.
这是卡西尼。

157
00:07:33,453 --> 00:07:37,555
Okay, so we built our UI here.
我们在这里建立了UI。

158
00:07:37,623 --> 00:07:42,627
Now, this would be really only an iPhone appropriate UI.
现在，这只是一个iPhone合适的UI。

159
00:07:42,696 --> 00:07:46,030
If we run this on iPhone, it actually would look fine,
如果我们在iPhone上运行这个，它看起来会很好，

160
00:07:46,099 --> 00:07:47,032
you'll see.
你会看到。

161
00:07:48,101 --> 00:07:50,035
Now why doesn't this work as is?
为什么不像现在这样?

162
00:07:50,103 --> 00:07:53,204
You see I had this right here, and I get this modal view,
你看到我在这里有这个，然后我得到这个模态视图，

163
00:07:53,273 --> 00:07:54,205
it kinda came up.
它有点上来。

164
00:07:54,274 --> 00:07:56,207
Obviously, we have no image selected yet,
很明显，我们还没有选定图像，

165
00:07:56,276 --> 00:07:58,342
we haven't written any prepare code.
我们还没有编写任何代码。

166
00:07:58,411 --> 00:07:59,344
But there's no back here.
但这里没有。

167
00:07:59,412 --> 00:08:00,545
Why is there no back?
为什么没有回来?

168
00:08:00,614 --> 00:08:03,615
That's because of this things being show detail.
这是因为这些东西都很详细。

169
00:08:03,683 --> 00:08:06,384
Because show detail only works in the iPad configuration.
因为show detail只在iPad配置中工作。

170
00:08:06,453 --> 00:08:09,287
So like, if I change this to being a show.
所以，如果我把它改成一个show。

171
00:08:09,356 --> 00:08:13,491
Well, actually, I'm not sure, someone was
事实上，我不确定，有人

172
00:08:13,559 --> 00:08:17,428
saying that to we have to remake that one to be a show.
说到我们必须重拍那个节目。

173
00:08:17,497 --> 00:08:20,632
Let's see if that works.
让我们看看它是否有效。

174
00:08:20,700 --> 00:08:24,836
And this is where it goes Saturn.
这就是土星所在的地方。

175
00:08:25,872 --> 00:08:26,871
Cuz we're not being prepared.
因为我们没有准备好。

176
00:08:26,939 --> 00:08:31,342
All right, see?
好了,看到了吗?

177
00:08:31,410 --> 00:08:34,279
So now it pushes, we're inside the navigation controller.
现在它在推，我们在导航控制器里。

178
00:08:34,347 --> 00:08:35,747
We can go back.
我们可以回去。

179
00:08:35,815 --> 00:08:39,617
But this is an iPhone only and we don't want that.
但这只是一部iPhone，我们不想要它。

180
00:08:39,685 --> 00:08:41,419
We want to work on both platforms.
我们想在这两个平台上工作。

181
00:08:41,487 --> 00:08:42,820
So I am gonna take that out again,
所以我要把它取出来，

182
00:08:42,889 --> 00:08:44,889
and put this back to be showed detail.
然后把它放回细节。

183
00:08:44,958 --> 00:08:47,826
Anyway, so I have this nice iPhone API, or UI rather.
不管怎样，我有一个很好的iPhone API，或者说UI。

184
00:08:47,895 --> 00:08:49,494
And I wanna turn into split view if, so
我想把它变成分屏视图

185
00:08:49,562 --> 00:08:51,696
I am going the other way and terms of preparing it.
我要用另一种方式来准备它。

186
00:08:51,765 --> 00:08:54,198
So lets go down here and grab a split view.
让我们从这里开始，抓取一个分屏视图。

187
00:08:54,267 --> 00:08:55,166
I drag it out here,
我把它拖出来，

188
00:08:55,235 --> 00:08:57,568
remember it brings all this other junk with it.
记住，它带来了所有其他的垃圾。

189
00:08:57,637 --> 00:08:59,337
We close our document outline,
我们关闭了文件大纲，

190
00:08:59,406 --> 00:09:02,007
you can delete these things that came with it.
你可以删除这些附带的东西。

191
00:09:04,478 --> 00:09:08,813
Now we have our Split View Controller right here, and
现在我们有了分屏视图控制器

192
00:09:08,882 --> 00:09:13,218
we can just use Ctrl+Drag to make this be our master.
我们可以用Ctrl +拖动来让它成为我们的master。

193
00:09:13,287 --> 00:09:15,787
And we can put this down here, let's say,
我们可以把它写在这里，

194
00:09:15,855 --> 00:09:18,356
in control drag to make this be our detail.
在control拖动中，这是我们的细节。

195
00:09:18,424 --> 00:09:23,227
And let's make our entry point the display view and
让我们进入显示视图

196
00:09:23,296 --> 00:09:24,863
just like that now,
就像现在一样,

197
00:09:24,931 --> 00:09:28,900
we turn this into something that can work on iPad.
我们把它变成可以在iPad上运行的东西。

198
00:09:28,969 --> 00:09:32,136
But having these segues we show versus show detail is
但我们展示的这些segue与显示的细节是不同的

199
00:09:32,205 --> 00:09:35,440
kind of an annoying little difference between the two
这两者之间有点不一样

200
00:09:35,508 --> 00:09:36,274
platforms.
平台。

201
00:09:36,342 --> 00:09:38,576
So you kinda have to know whether you're gonna put
所以你必须知道你是否会

202
00:09:38,645 --> 00:09:40,478
it into split view or not unfortunately,
很不幸，

203
00:09:40,547 --> 00:09:41,646
when you build your app.
当你建立你的应用程序。

204
00:09:41,715 --> 00:09:48,986
Now, this will still work on iPhone.
现在，这仍然适用于iPhone。

205
00:09:49,055 --> 00:09:51,589
Just begins on the detail to start and
就从开始的细节开始

206
00:09:51,658 --> 00:09:54,725
we can navigate here into these various things.
我们可以在这里浏览各种各样的东西。

207
00:09:54,794 --> 00:09:58,562
And it will also work on iPad,
它也适用于iPad，

208
00:09:58,631 --> 00:10:07,271
lets see iPad.
让我们看看iPad。

209
00:10:07,340 --> 00:10:09,641
Here is the thing we can slide out our master,
这是我们可以从我们的主人那里滑出的东西，

210
00:10:09,709 --> 00:10:12,243
I click on these things or we can go to landscape.
我点击这些东西，或者我们可以去风景。

211
00:10:12,311 --> 00:10:16,147
And again, it's not showing anything cuz I haven't yet.
再一次，它没有显示任何我还没有的东西。

212
00:10:16,216 --> 00:10:17,215
on iPad maybe we want to put this in a navigation
在iPad上，我们想把它放在导航栏里

213
00:10:17,216 --> 00:10:18,215
Now, again,
现在,再一次,

214
00:10:18,284 --> 00:10:20,785
controller right here so, we get a nice title over here.
控制器在这里，这里有一个很好的标题。

215
00:10:20,854 --> 00:10:23,555
So I can do that as well, just go down here and
我也可以这样做，在下面这里

216
00:10:23,624 --> 00:10:26,090
select this new controller down here and
在这里选择这个新控制器

217
00:10:26,159 --> 00:10:28,192
do embed in navigation control.
在导航控制中嵌入。

218
00:10:28,261 --> 00:10:29,160
Now if we do that,
如果我们这样做，

219
00:10:29,228 --> 00:10:31,830
we're gonna be want to be careful in our prepare.
我们在准备时要小心。

220
00:10:31,898 --> 00:10:34,499
That when we prepare for this segue, we account for
当我们为这个segue做准备时，我们需要考虑

221
00:10:34,568 --> 00:10:37,201
this navigation controller perhaps being there.
这个导航控制器可能在那里。

222
00:10:37,270 --> 00:10:38,670
And I'm gonna show you how to do that as well.
我也会告诉你们怎么做。

223
00:10:39,839 --> 00:10:41,806
Let's do our prepare.
让我们做准备。

224
00:10:41,875 --> 00:10:42,673
We've got our UI,
我们有我们的UI,

225
00:10:42,742 --> 00:10:45,576
same kinda UI as we did in emotions, exactly the same.
就像我们在情感中所做的那样，完全一样。

226
00:10:45,645 --> 00:10:49,814
But obviously nothing works in these segues unless we
但很明显，这些segue里没有任何东西，除非我们

227
00:10:49,883 --> 00:10:51,466
So, let's go to our prepare for segue here and type it in.
所以，让我们进入prepareforsegue，并输入它。

228
00:10:51,467 --> 00:10:53,050
prepare.
准备。

229
00:10:53,119 --> 00:10:55,853
It's gonna be a really simple prepare for segue,
这将是一个很简单的prepareforsegue，

230
00:10:55,922 --> 00:10:58,523
cuz I made the segue identifier be the thing I'm
因为我做了segue标识符

231
00:10:58,592 --> 00:11:00,091
gonna look up in the table.
在桌子上抬头看。

232
00:11:00,159 --> 00:11:03,728
So I'm just gonna say if I can let the URL,
我想说，如果我可以让URL，

233
00:11:03,797 --> 00:11:08,600
that I want the NASA URL, equal DemoURL.NASA.
我想要NASA的网址，equal demourl . NASA。

234
00:11:08,668 --> 00:11:12,770
And I'm gonna look it up, by taking the segue identifier,
我将通过segue标识符来查找它，

235
00:11:12,839 --> 00:11:16,841
but if that segue identified with nil, this won't work.
但如果这个segue被nil识别，这就行不通了。

236
00:11:16,909 --> 00:11:17,742
In other words,
换句话说,

237
00:11:17,811 --> 00:11:20,545
you can't look up something that's an optional,
你不能找一个可选的，

238
00:11:20,614 --> 00:11:22,914
like the identifier is, in a dictionary.
像标识符一样，在字典里。

239
00:11:22,982 --> 00:11:24,783
This dictionary is looking for a string here.
这本字典在找一个字符串。

240
00:11:24,851 --> 00:11:29,487
So, I'm just gonna say defaulting to nothing.
那么，我就说默认为零。

241
00:11:29,555 --> 00:11:32,090
And of course, looking this up in this dictionary,
当然，在这本字典里，

242
00:11:32,158 --> 00:11:33,324
it's gonna return nil.
它会返回nil。

243
00:11:33,393 --> 00:11:36,427
But I'm doing if let right here, so that's okay.
但如果我在这里做，就可以了。

244
00:11:36,495 --> 00:11:40,031
Now I'm getting the URL if possible, so that segue,
现在我得到了URL，如果可能的话，那么这个segue，

245
00:11:40,100 --> 00:11:42,600
if it's possible to get that URL out of
如果有可能的话

246
00:11:42,669 --> 00:11:45,537
the NASA dictionary, then I will do that.
NASA的字典，我就这么做。

247
00:11:45,605 --> 00:11:46,270
Now, of course,
现在,当然,

248
00:11:46,339 --> 00:11:48,372
I need the view controller that I'm segueing to.
我需要segue到的视图控制器。

249
00:11:48,441 --> 00:11:50,508
So I'm gonna say,
所以我想说,

250
00:11:50,576 --> 00:11:56,146
if I can let imageVC = (segue.destination as?
如果我可以让imageVC =(segue)目的地是?

251
00:11:56,215 --> 00:11:58,382
ImageViewController.
ImageViewController。

252
00:11:58,451 --> 00:12:02,854
That's that view controller that we're segueing to.
这就是我们segue到的视图控制器。

253
00:12:05,158 --> 00:12:07,925
If I can do that, then I can prepare.
如果我能做到，我就能做好准备。

254
00:12:07,994 --> 00:12:10,661
But of course, here we've got the problem where this
当然，这里有一个问题

255
00:12:10,730 --> 00:12:12,697
destination on an iPad might be, what?
在iPad上的目的地可能是什么?

256
00:12:12,766 --> 00:12:14,665
A navigation controller.
一个导航控制器。

257
00:12:14,734 --> 00:12:17,502
So normally, we would put a little if in here,
通常情况下，如果在这里，

258
00:12:17,571 --> 00:12:20,404
we say if the thing is a navigation controller,
我们说如果它是一个导航控制器，

259
00:12:20,473 --> 00:12:23,341
then we would get the visible view controller.
然后我们会得到可见的视图控制器。

260
00:12:23,410 --> 00:12:24,809
Remember that code that we put in there?
还记得我们输入的代码吗?

261
00:12:24,878 --> 00:12:26,944
You probably put that in your homework,
你们可能把它放在作业里，

262
00:12:27,013 --> 00:12:30,014
if you used navigation control for your detail.
如果你使用导航控制你的细节。

263
00:12:30,082 --> 00:12:32,283
Instead, I'm gonna put that in an extension,
相反，我将把它放到一个扩展中，

264
00:12:32,352 --> 00:12:34,652
remember we learned about extensions last time?
还记得上次我们学过的扩展吗?

265
00:12:34,721 --> 00:12:38,322
So I'm going to extend UI view controller, and
我将扩展uiviewcontroller

266
00:12:38,391 --> 00:12:41,159
just add a var to UIViewController.
只需添加一个var到UIViewController。

267
00:12:41,227 --> 00:12:45,196
Now this var I'm gonna add, I'm gonna call it contents,
现在我要添加这个var，我把它命名为contents，

268
00:12:45,265 --> 00:12:48,733
and it's going to be of type UIViewController.
它将会是UIViewController类型。

269
00:12:49,702 --> 00:12:51,102
And since it's in the extension,
因为它在扩展中，

270
00:12:51,171 --> 00:12:53,171
it can't be a var that has any storage.
它不可能是一个有任何存储的var。

271
00:12:53,240 --> 00:12:55,106
Extensions have no storage.
扩展没有存储。

272
00:12:55,174 --> 00:12:58,976
So it can only be a computed var so I'm gonna compute it.
它只能是一个计算的var，所以我要计算它。

273
00:12:59,045 --> 00:13:01,712
And what is contents gonna be, what is this var?
什么是内容，什么是var ?

274
00:13:01,781 --> 00:13:04,748
Well, I'm defining contents to be the contents of this
我将内容定义为它的内容

275
00:13:04,817 --> 00:13:07,918
view controller, what this view controller holds?
视图控制器，这个视图控制器是什么?

276
00:13:07,987 --> 00:13:10,688
Well, if this view controller is a navigation controller,
如果这个视图控制器是一个导航控制器，

277
00:13:10,757 --> 00:13:12,690
then tha's the visible view controller.
然后是可见的视图控制器。

278
00:13:12,758 --> 00:13:15,293
If it's not, then it's just itself,
如果不是，那么它就是它自己，

279
00:13:15,362 --> 00:13:18,329
a view controller's contents are itself.
视图控制器的内容本身就是。

280
00:13:18,398 --> 00:13:20,164
Unless, it happens to be a navigation controller and
除非，它恰好是一个导航控制器

281
00:13:20,233 --> 00:13:21,765
then it returns to visible view controller.
然后它返回到可见的视图控制器。

282
00:13:21,834 --> 00:13:24,802
I could also,
我也可以,

283
00:13:24,871 --> 00:13:27,071
And if I am, show the visible tab, too.
如果我是，也显示可见选项卡。

284
00:13:27,140 --> 00:13:28,973
But for interest of time I won't do that,
但为了时间的利益，我不会那样做，

285
00:13:29,042 --> 00:13:31,308
you can do that if you want.
如果你愿意，你可以这样做。

286
00:13:31,377 --> 00:13:36,747
I'm just gonna say here if I can let navcon = self as?
如果我可以让navcon = self ?

287
00:13:36,816 --> 00:13:39,416
a UINavigationController.
UINavigationController。

288
00:13:39,485 --> 00:13:42,019
In other words, if I'm a navigation controller then I'm
换句话说，如果我是导航控制器

289
00:13:42,088 --> 00:13:44,522
just going to return the navcon's visible.
只需要返回navcon的可见值。

290
00:13:44,591 --> 00:13:45,389
Navcon is myself,
Navcon是我自己,

291
00:13:45,458 --> 00:13:48,025
it's just that it's myself as a navigation controller.
只是我自己作为导航控制器。

292
00:13:48,094 --> 00:13:52,029
So I can send this var, I can get this var from it.
所以我可以发送这个var，我可以从它得到这个var。

293
00:13:52,098 --> 00:13:54,966
Of course, this visible view controller is optional
当然，这个可见的视图控制器是可选的

294
00:13:55,035 --> 00:13:57,601
because the navigation controller might not have any
因为导航控制器可能没有

295
00:13:57,670 --> 00:13:59,437
view controller in it at the moment.
视图控制器此时此刻。

296
00:13:59,505 --> 00:14:02,440
So, I better have a default there which I'll just
因此，我最好有一个默认值

297
00:14:02,509 --> 00:14:03,741
return self.
回归自我。

298
00:14:03,809 --> 00:14:06,410
And then if I'm not in navigation controller,
如果我不在导航控制器中，

299
00:14:06,479 --> 00:14:11,215
then I'm just gonna return self.
然后我返回self。

300
00:14:11,283 --> 00:14:13,784
So you see how content, it's showing the contents of our
你可以看到内容，它显示了我们的内容

301
00:14:13,853 --> 00:14:16,487
navigation folder, otherwise, it's returning myself.
导航文件夹，否则，它返回自己。

302
00:14:16,556 --> 00:14:18,656
Which is kind of cool for this situation.
这对这种情况很酷。

303
00:14:18,724 --> 00:14:21,191
And it allows me to go up here, instead of saying segue
它允许我向上走，而不是说segue

304
00:14:21,260 --> 00:14:24,061
destination, I can just say sequedestination.content.
目的地,我可以说sequedestination.content。

305
00:14:24,130 --> 00:14:28,266
And then I don't need this little if up there.
然后我就不需要这个了。

306
00:14:29,836 --> 00:14:32,803
Now, is this a reasonable thing to do in extension?
这是一个合理的扩展吗?

307
00:14:32,872 --> 00:14:36,307
Absolutely it is, because this var has complete and
当然，因为这个var已经完整了

308
00:14:36,375 --> 00:14:39,777
utter understandable semantics that only have to do
完全可以理解的语义，只需要做

309
00:14:39,846 --> 00:14:41,846
with the UI view controller and
使用UI视图控制器

310
00:14:41,915 --> 00:14:45,916
nothing to do with Casini view controller or anything else.
与Casini视图控制器或其他东西无关。

311
00:14:45,985 --> 00:14:47,585
Because when you do an extension,
因为当你做一个扩展时，

312
00:14:47,654 --> 00:14:49,353
you want that to be the case.
你想要这样。

313
00:14:49,422 --> 00:14:51,889
You don't wanna generally put extensions on other classes
一般不需要在其他类上添加扩展名

314
00:14:51,958 --> 00:14:53,958
that have to do with other classes, generally.
一般来说，这与其他类有关。

315
00:14:54,027 --> 00:14:56,827
Unless they're kind of like standard types, or
除非它们有点像标准类型

316
00:14:56,896 --> 00:14:58,395
something like that.
就像这样。

317
00:14:58,464 --> 00:15:00,130
Maybe converting from a string to a date,
也许从一个字符串转换到一个日期，

318
00:15:00,199 --> 00:15:01,165
or something like that.
之类的。

319
00:15:01,234 --> 00:15:03,601
In some way might make some sense, but
从某种意义上说，可能有些道理

320
00:15:03,670 --> 00:15:06,670
you wouldn't want to put extensions on other classes
您不想在其他类上添加扩展

321
00:15:06,739 --> 00:15:09,707
that are specific to things that other classes need.
这是特定于其他类需要的东西。

322
00:15:09,775 --> 00:15:13,211
In that case, just put a function in your own class
在这种情况下，只需在自己的类中添加一个函数

323
00:15:13,279 --> 00:15:15,312
that does that thing.
那件事。

324
00:15:15,381 --> 00:15:18,181
So does everyone see what I'm saying about this?
大家都明白我的意思了吗?

325
00:15:18,250 --> 00:15:19,617
This makes perfect sense,
这非常有意义,

326
00:15:19,686 --> 00:15:21,785
this would be usable in any environment,
这在任何环境下都是可用的，

327
00:15:21,854 --> 00:15:24,555
it's a sensible var to have on a view controller.
在视图控制器上有一个合理的var。

328
00:15:27,327 --> 00:15:29,360
Now that I have my image view controller,
现在我有了图像视图控制器，

329
00:15:29,429 --> 00:15:30,361
either by getting it or
要么得到它，要么

330
00:15:30,430 --> 00:15:33,064
going through the navigation controller, I can prepare it.
通过导航控制器，我可以准备它。

331
00:15:33,132 --> 00:15:35,232
And so preparing it is really easy,
所以准备很简单，

332
00:15:35,301 --> 00:15:38,235
I just wanna set the URL equal to that URL, okay,
我只想设置URL等于这个URL，

333
00:15:38,304 --> 00:15:40,504
the URL that I got out of the demo URL.
我从演示URL中得到的URL。

334
00:15:40,573 --> 00:15:44,341
This is just public API, okay, this happens to be its model,
这是公共API，这恰好是它的模型，

335
00:15:44,410 --> 00:15:46,043
let's also set its title.
让我们也设置它的标题。

336
00:15:46,112 --> 00:15:47,411
We can set the title equal to,
我们可以把标题设为，

337
00:15:47,480 --> 00:15:49,313
we could do the same thing we did before.
我们可以像以前一样做。

338
00:15:49,382 --> 00:15:52,216
Take the sender interpret it as a UI button and
以发送者将其解释为UI按钮

339
00:15:52,285 --> 00:15:56,187
if we're able to do that then we'll get the current title.
如果我们能这样做，我们就会得到当前的标题。

340
00:15:57,624 --> 00:15:58,990
Which might be nil, but
可能是nil，但是

341
00:15:59,058 --> 00:16:01,292
that's okay because this is also an optional.
这没问题，因为这也是一个可选的。

342
00:16:01,361 --> 00:16:04,828
This is optional so can take a nil even though this is nil.
这是可选的，所以可以取nil，尽管这是nil。

343
00:16:04,897 --> 00:16:07,498
And of course it might be nil because this turns out to not
当然它可能是nil，因为结果不是

344
00:16:07,567 --> 00:16:08,866
be true, and that's fine, too.
是真的，那也很好。

345
00:16:10,436 --> 00:16:13,571
See how these optionals play out nicely because you have
看看这些选项是如何发挥作用的，因为你有

346
00:16:13,640 --> 00:16:15,639
vars that are optional and things are optional?
可选的vars是可选的?

347
00:16:15,708 --> 00:16:17,675
So you can set things equal to each other and
所以你可以把它们设成相等的

348
00:16:17,743 --> 00:16:20,911
it kind of just all plays out kind of beautifully there.
它在那里的效果都很好。

349
00:16:20,980 --> 00:16:22,747
So that's it, let's run here.
就是这样，我们在这里运行。

350
00:16:22,815 --> 00:16:26,951
Let's see
让我们看看

351
00:16:27,020 --> 00:16:32,389
what we got.
我们得到了什么。

352
00:16:32,458 --> 00:16:32,957
Here we go. So
我们开始吧。所以

353
00:16:33,025 --> 00:16:34,692
let's take a look at Cassini, for
让我们来看看卡西尼号

354
00:16:34,761 --> 00:16:38,963
example, look, it's broken.
看,它坏了。

355
00:16:39,031 --> 00:16:40,063
Whoa, what's going on?
哇,这是怎么回事?

356
00:16:40,132 --> 00:16:46,803
I clicked there to get Cassini which, look, there's Cassini.
我点了一下卡西尼，看，卡西尼号。

357
00:16:46,872 --> 00:16:50,307
Let's zoom in on Cassini.
让我们放大卡西尼号。

358
00:16:50,376 --> 00:16:51,175
There it is.
在这里。

359
00:16:51,243 --> 00:16:55,946
So this is the Cassini space probe right here by Saturn.
这是土星的卡西尼号太空探测器。

360
00:16:56,015 --> 00:16:58,749
But when I clicked on it, it seemed like my UI froze.
但当我点击它的时候，我的UI就被冻结了。

361
00:16:58,818 --> 00:17:00,117
And if I click on these other ones, look,
如果我点击其他的，

362
00:17:00,185 --> 00:17:02,353
I'm clicking Saturn, Saturn, Saturn, nothing's happening.
我点击土星，土星，土星，什么都没发生。

363
00:17:02,421 --> 00:17:04,555
Because it, now something came up.
因为它，现在出现了一些东西。

364
00:17:05,692 --> 00:17:07,725
So this UI seems broken.
这个UI看起来是坏的。

365
00:17:07,794 --> 00:17:10,528
Now we're on ultra fast network here.
现在我们在超快的网络上。

366
00:17:10,597 --> 00:17:11,562
This is Stanford's network.
这是斯坦福大学的网络。

367
00:17:11,631 --> 00:17:14,232
We have like gigabyte connections to everywhere and
我们有十亿字节的连接到任何地方和

368
00:17:14,300 --> 00:17:16,733
it still took a while cuz it's a very large file.
它仍然需要一段时间，因为它是一个非常大的文件。

369
00:17:16,802 --> 00:17:19,504
Imagine I was on cellular.
想象一下，我在手机上。

370
00:17:20,706 --> 00:17:24,375
That image might take a minute to download.
这个图像可能需要一分钟才能下载。

371
00:17:24,444 --> 00:17:26,310
And meanwhile my app is completely stuck,
与此同时，我的应用完全卡住了，

372
00:17:26,378 --> 00:17:28,112
I can't click on any other button.
我不能点击任何其他的按钮。

373
00:17:28,181 --> 00:17:28,980
If I'm on iPhone,
如果我在iPhone上,

374
00:17:29,048 --> 00:17:31,349
lets see what he looks like on iPhone, it's even worse.
让我们看看他在iPhone上的样子，情况更糟。

375
00:17:33,620 --> 00:17:35,419
If I'm on iPhone, I'm gonna click that.
如果我在iPhone上，我会点击它。

376
00:17:35,488 --> 00:17:37,688
I'm gonna think, " my app is broken".
我想，"我的app坏了"

377
00:17:37,756 --> 00:17:39,690
So I'm in a NavigationController,
我在导航控制器中，

378
00:17:39,759 --> 00:17:41,491
no problem, I'll just hit back.
没问题，我打回去。

379
00:17:41,560 --> 00:17:46,697
But even the back button's
但即使是back按钮

380
00:17:46,766 --> 00:17:53,070
not gonna work, as you'll see.
不去工作，你会看到的。

381
00:17:53,139 --> 00:17:56,774
All right, so here we are.
好的，我们到了。

382
00:17:57,977 --> 00:17:58,943
Got the detailed view there.
这里有详细的视图。

383
00:17:59,012 --> 00:18:02,046
Now I'm gonna hit Earth, it's stuck.
现在我要撞上地球了，它卡住了。

384
00:18:02,115 --> 00:18:03,313
And again, I can't do anything.
再说一次，我什么都做不了。

385
00:18:03,382 --> 00:18:04,849
Finally comes back.
终于回来了。

386
00:18:04,917 --> 00:18:08,953
So this kinda UI is horrible because, especially on
这个UI很可怕，尤其是

387
00:18:09,022 --> 00:18:11,055
cellular or something where it's really slow,
细胞或者其他一些非常缓慢的地方，

388
00:18:11,124 --> 00:18:12,556
users are like, this app is broken.
用户就像，这个app坏了。

389
00:18:12,625 --> 00:18:15,892
They're literally going to double-click the Home
他们会双击房子

390
00:18:15,961 --> 00:18:19,429
button and flip your app off, to use an analogy there.
按下你的应用程序，用一个类比。

391
00:18:19,498 --> 00:18:21,965
They're gonna flip your app and kill it because their,
他们会翻转你的应用，然后杀了它，

392
00:18:22,034 --> 00:18:23,500
they think it's broken.
他们认为这是坏了。

393
00:18:23,569 --> 00:18:25,936
So we're gonna fix that with multitasking.
我们要用多任务处理来解决这个问题。

394
00:18:26,004 --> 00:18:31,441
So first, let me show
首先，我来展示一下

395
00:18:31,510 --> 00:18:36,647
you how that works.
你是怎么做的。

396
00:18:36,716 --> 00:18:40,517
All right, so, multithreading.
好吧,所以,多线程。

397
00:18:40,586 --> 00:18:43,154
There's two reasons generally,
通常有两个原因,

398
00:18:43,222 --> 00:18:45,556
that you wanna do multithreading.
你想要多线程。

399
00:18:45,624 --> 00:18:48,759
One reason is, you have a mathematical problem, or
一个原因是，你有一个数学问题，或者

400
00:18:48,827 --> 00:18:52,863
some image processing problem, that is best solved
一些图像处理问题，这是最好的解决方法

401
00:18:52,932 --> 00:18:56,433
using some kind of parallel processing algorithm where you
使用一种并行处理算法

402
00:18:56,502 --> 00:19:00,137
wanna go off and do 1000 things or 100 things at once.
想要一次性完成1000件或100件事情。

403
00:19:00,205 --> 00:19:02,639
And then and when they're all done together you're gonna
然后，当他们一起完成的时候，你就会

404
00:19:02,708 --> 00:19:04,908
combine the result, or something like that.
结合结果，或者类似的东西。

405
00:19:04,977 --> 00:19:08,579
So that's an obvious need to do multithreading.
这显然需要多线程处理。

406
00:19:08,648 --> 00:19:10,281
That's not the multithreading I'm gonna be
那不是我要做的多线程

407
00:19:10,349 --> 00:19:11,482
talking to you about.
和你谈话。

408
00:19:11,551 --> 00:19:13,717
That, that's a perfectly valid use of multithreading,
这是多线程的有效使用，

409
00:19:13,786 --> 00:19:15,719
iOS has some great API for doing that kind of design.
iOS有一些很棒的API来做这种设计。

410
00:19:15,788 --> 00:19:18,456
But that's not what I'm talking about.
但这不是我要说的。

411
00:19:18,524 --> 00:19:21,759
The second reason that you might wanna do multithreading
第二个原因可能是多线程

412
00:19:21,828 --> 00:19:23,961
is because you have one thread.
因为你有一个线程。

413
00:19:24,030 --> 00:19:25,730
By the way, does everyone know what a thread is?
顺便问一下，大家都知道线程是什么吗?

414
00:19:25,798 --> 00:19:28,665
Raise your hand if you know what a thread is.
如果你知道线是什么，请举手。

415
00:19:28,734 --> 00:19:31,468
Okay, I see some people saying, yeah, remind me.
好吧，我看到有人说，是的，提醒我。

416
00:19:31,537 --> 00:19:35,839
A thread just means, thread is short for thread of execution.
线程只是意味着，线程是执行线程的缩写。

417
00:19:35,908 --> 00:19:40,210
And it just is kind of a, the process,
这是一个过程，

418
00:19:40,279 --> 00:19:43,414
through which code is executing.
通过该代码执行。

419
00:19:43,482 --> 00:19:46,417
That could conceivably be separated where you have
这可能会被分开

420
00:19:46,486 --> 00:19:48,285
multiple of them.
的倍数。

421
00:19:48,354 --> 00:19:50,170
in the iOS, you've got a very important kind of main thread
在iOS中，你有一个非常重要的主线程

422
00:19:50,171 --> 00:19:51,987
For example,
例如,

423
00:19:52,057 --> 00:19:53,640
That's the thread of execution that is listening to gestures
这是执行的主线，倾听手势

424
00:19:53,641 --> 00:19:55,224
of execution.
的执行。

425
00:19:55,294 --> 00:19:58,162
and doing drawing, things like that.
画图画之类的。

426
00:19:58,230 --> 00:20:00,230
Then you can have other threads of execution that
然后你可以有其他的执行线程

427
00:20:00,299 --> 00:20:02,733
might be doing background things, like going out onto
可能做一些背景的事情，比如出去

428
00:20:02,802 --> 00:20:05,803
the network and getting data, or something like that.
网络和获取数据，或者类似的东西。

429
00:20:05,872 --> 00:20:09,373
Most of our devices aren't multiprocessor, per se, so
我们的大多数设备都不是多处理器，所以

430
00:20:09,442 --> 00:20:12,877
these threads, although they have multiple cores, so
这些线程，虽然它们有多个内核，所以

431
00:20:12,946 --> 00:20:15,412
they can actually do two things at once.
他们实际上可以同时做两件事。

432
00:20:15,481 --> 00:20:16,580
They literally can.
他们真的可以。

433
00:20:16,649 --> 00:20:18,783
But in this case where I'm talking about multithreading
但在这种情况下，我说的是多线程

434
00:20:18,851 --> 00:20:23,287
to solve this problem of keeping the UI responsive,
为了解决保持UI响应的问题，

435
00:20:23,356 --> 00:20:24,888
we don't even care about that.
我们甚至不关心这个。

436
00:20:24,957 --> 00:20:28,659
And so here's the thing with multithreading and the UI.
这里是多线程和UI。

437
00:20:28,727 --> 00:20:31,662
We want the thread of execution which is listening
我们想要执行的线程正在监听

438
00:20:31,731 --> 00:20:34,865
to the user to be super responsive, always working,
要让用户反应灵敏，一直工作，

439
00:20:34,934 --> 00:20:36,299
never blocked.
不会阻塞。

440
00:20:36,368 --> 00:20:39,703
And we don't really care about other threads too much,
我们并不太关心其他的线程，

441
00:20:39,771 --> 00:20:43,407
but we really want that one to be unblocked at all time.
但我们真的希望它能一直畅通无阻。

442
00:20:43,476 --> 00:20:46,510
So if we're ever going to do anything that would block,
所以如果我们要做任何会阻碍的事情，

443
00:20:46,578 --> 00:20:49,947
like either block because it's doing so much computation
就像任何一个block一样，因为它做了很多计算

444
00:20:50,015 --> 00:20:53,884
that it's not getting back to the rest of the code.
它不会回到代码的其余部分。

445
00:20:53,953 --> 00:20:56,620
Or in this case, with our Cassini, it's gonna block
或者在这种情况下，用卡西尼号，它会阻塞

446
00:20:56,689 --> 00:20:59,456
because it's waiting on some resource like the network.
因为它在等一些资源，比如网络。

447
00:20:59,525 --> 00:21:02,893
Okay, I make a request for a URL.
我请求URL。

448
00:21:02,962 --> 00:21:05,496
It doesn't respond immediately, I have to wait.
它没有立即响应，我必须等待。

449
00:21:05,564 --> 00:21:08,198
Any time I have to wait, I can't be waiting in the middle
任何时候我都得等，我不能在中间等

450
00:21:08,267 --> 00:21:10,734
of that UI cuz now no one can do a gesture or
在这个UI中，现在没有人可以做手势

451
00:21:10,803 --> 00:21:13,604
click on the back button or do anything else.
单击后退按钮或做其他事情。

452
00:21:13,673 --> 00:21:15,306
So that's the kind of multithreading that I'm
这就是我说的多线程

453
00:21:15,374 --> 00:21:16,874
talking about here that we're gonna try and
说到这里，我们会尝试

454
00:21:16,942 --> 00:21:20,811
solve, is keep the UI thread responsive and active
解决，就是保持UI线程的响应性和活动性

455
00:21:20,879 --> 00:21:24,314
by pushing everything else that could be slow or blocked,
把其他的东西都推得很慢或堵塞，

456
00:21:24,383 --> 00:21:27,418
waiting on a resource, off to a different thread.
在资源上等待，在不同的线程上等待。

457
00:21:27,487 --> 00:21:29,019
Now in iOS,
现在在iOS,

458
00:21:29,088 --> 00:21:31,755
we don't actually even really talk about threads much.
我们实际上并没有过多地讨论线程。

459
00:21:31,823 --> 00:21:33,089
I've been using this word thread,
我一直在用这个词，

460
00:21:33,158 --> 00:21:34,892
because that's what's going on underneath the covers.
因为这就是封面下面的内容。

461
00:21:34,961 --> 00:21:37,961
We're talking about threads of execution here.
我们说的是执行的线程。

462
00:21:38,030 --> 00:21:40,031
But really, what we talk about is queues.
但实际上，我们谈论的是队列。

463
00:21:41,734 --> 00:21:45,068
So multithreading is really about queues.
多线程实际上是关于队列的。

464
00:21:45,137 --> 00:21:46,036
Now what's a queue?
现在一个队列是什么?

465
00:21:46,105 --> 00:21:48,939
Queue is an English word, actually.
实际上，队列是一个英语单词。

466
00:21:49,008 --> 00:21:50,941
We don't use it in the United States much, but
我们在美国不用它，但是

467
00:21:51,010 --> 00:21:53,276
a queue just means a line.
队列就是一条直线。

468
00:21:53,345 --> 00:21:55,979
Like if you go to the movies, you might say, I'm queueing up
如果你去看电影，你可能会说，我在排队

469
00:21:56,048 --> 00:21:57,881
to see this movie, especially if you were in London,
为了看这部电影，特别是如果你在伦敦，

470
00:21:57,950 --> 00:22:00,318
you would say let's go queue for the movie.
你会说让我们去排队看电影吧。

471
00:22:01,587 --> 00:22:04,288
So that's all a queue is, it's a line.
这就是队列，这是一条直线。

472
00:22:04,357 --> 00:22:05,756
And what are we gonna put in this line?
我们在这条直线上写什么呢?

473
00:22:05,825 --> 00:22:06,823
Instead of people waiting for
而不是等待

474
00:22:06,892 --> 00:22:09,360
the movie, we're gonna put blocks of code.
电影，我们要把代码块放进去。

475
00:22:11,397 --> 00:22:13,830
And we know a great way to make a block of code that we
我们知道一个很好的方法来做一个代码块

476
00:22:13,899 --> 00:22:15,766
can put in a line which is a closure.
可以输入一条闭合的线。

477
00:22:15,835 --> 00:22:17,768
So we're almost always doing this with closure.
所以我们几乎总是用闭包来做。

478
00:22:17,836 --> 00:22:20,538
So putting these closures, it could be any blocking code,
把这些闭包，可以是任何阻塞代码，

479
00:22:20,606 --> 00:22:22,740
but we're putting these closures basically,
但是我们把这些闭包，

480
00:22:22,808 --> 00:22:25,275
usually into a queue.
通常在一个队列。

481
00:22:25,344 --> 00:22:27,811
And so what's happening then is the system
那么系统就是这样的

482
00:22:27,880 --> 00:22:31,348
is creating threads as necessary to grab those
创建线程是为了获取这些吗

483
00:22:31,417 --> 00:22:34,251
blocks off that queue, off the front of the line, who's ever
挡在队伍前面，排在队伍前面，谁是谁

484
00:22:34,320 --> 00:22:37,321
in the front of the queue and executing on a thread.
在队列的前面，在线程上执行。

485
00:22:38,524 --> 00:22:40,457
That's how multitasking or
这就是多任务或

486
00:22:40,526 --> 00:22:42,926
multithreading really works in iOS.
多线程确实在iOS中有效。

487
00:22:42,995 --> 00:22:46,763
We don't really care how the system assigns threads to
我们并不关心系统如何分配线程

488
00:22:46,832 --> 00:22:48,565
these lines, these queues.
这些线,这些队列。

489
00:22:48,634 --> 00:22:50,300
All we care about is the queues.
我们只关心队列。

490
00:22:50,369 --> 00:22:53,304
And when we wanna express to the system where we want
当我们想要表达我们想要的系统的时候

491
00:22:53,372 --> 00:22:55,973
things to run, you know, where the UI runs or
运行的东西，UI运行的地方

492
00:22:56,041 --> 00:22:58,175
in background process or whatever,
在后台进程中，

493
00:22:58,243 --> 00:23:00,644
we specify it by what queue we put code on.
我们通过使用代码来指定它。

494
00:23:00,712 --> 00:23:03,047
Does that make sense?
这说得通吗?

495
00:23:04,717 --> 00:23:08,786
Let's talk about the queues that we can have.
我们来讨论一下我们可以使用的队列。

496
00:23:08,854 --> 00:23:11,722
One important queue, of course, is the main queue.
当然，一个重要的队列是主队列。

497
00:23:11,791 --> 00:23:14,792
So this is the queue on which all the UI
这是所有UI的队列

498
00:23:14,860 --> 00:23:16,193
activity is happening.
活动正在发生的事情。

499
00:23:16,261 --> 00:23:19,530
It's not only the queue that all UI activity is happening
它不仅仅是所有UI活动都在发生的队列

500
00:23:21,333 --> 00:23:22,967
But it's the only queue that UI activity can happen on.
但它是UI活动能够发生的唯一队列。

501
00:23:22,968 --> 00:23:24,602
in general.
一般来说。

502
00:23:25,938 --> 00:23:29,272
And that's because it's a serial queue.
这是因为它是一个串行队列。

503
00:23:29,341 --> 00:23:31,842
A serial queue is a queue where everyone,
串行队列是每个人的队列，

504
00:23:31,911 --> 00:23:33,844
the blocks in code are waiting in line to run,
代码中的代码块正在排队等待运行，

505
00:23:33,913 --> 00:23:37,447
and there's only one thread to run them.
只有一个线程来运行它们。

506
00:23:37,516 --> 00:23:41,618
So when the system comes along to grab the next guy in line,
所以当系统来抓下一个人的时候，

507
00:23:41,687 --> 00:23:44,921
he runs him to completion and then goes back for
他让他完成任务，然后回去

508
00:23:44,990 --> 00:23:46,123
the next one.
下一个。

509
00:23:46,192 --> 00:23:47,858
So you see how they're serial.
看它们是如何串联的。

510
00:23:47,926 --> 00:23:48,759
They happen in order.
他们发生在订单。

511
00:23:48,828 --> 00:23:51,929
The entire line of closures waiting to run, or code
所有闭包等待运行，或代码

512
00:23:51,998 --> 00:23:56,300
waiting to run, is processed in order, one at a time.
等待运行，按顺序处理，一次一个。

513
00:23:56,369 --> 00:23:59,102
What's really great about the UI side of that is it
UI方面真正伟大的是它

514
00:23:59,171 --> 00:24:00,738
makes it very predictable.
很可预测的。

515
00:24:00,806 --> 00:24:03,473
You really don't have to get into a lot of the mind games
你真的不必去玩心理游戏了

516
00:24:03,542 --> 00:24:06,977
of multithreading, where it's like, is this thing waiting on
在多线程的情况下，这是一个等待的东西

517
00:24:07,045 --> 00:24:10,047
this, do I have to have a lock on this data resource bug?
这个，我必须要锁定这个数据资源bug吗?

518
00:24:10,115 --> 00:24:12,349
Because all the UI stuff is all happening in
因为所有的UI都发生了

519
00:24:12,417 --> 00:24:13,250
the main queue.
主要的队列。

520
00:24:13,319 --> 00:24:14,951
This is all happening serially,
这都是连续发生的，

521
00:24:15,020 --> 00:24:17,654
you never have to worry about two UI things accessing
您永远不必担心访问的两个UI

522
00:24:17,723 --> 00:24:19,789
the same data structure at the same time,
相同的数据结构，

523
00:24:19,858 --> 00:24:23,293
cuz they're all just marching in line, down this main queue.
因为它们都排成一行，沿着主队排。

524
00:24:23,361 --> 00:24:27,831
So, all UI activity and only UI activity, no other stuff,
所有UI活动和UI活动，没有其他东西，

525
00:24:27,900 --> 00:24:31,301
generally, runs in the UI, the main queue.
通常，在UI中运行主队列。

526
00:24:31,370 --> 00:24:33,704
And the reason we don't want other stuff running in the
我们不希望其他东西在这里运行的原因

527
00:24:33,773 --> 00:24:36,573
main queue, is we never want the main queue to be blocked.
主队列，我们不希望主队列被阻塞。

528
00:24:36,642 --> 00:24:39,743
We never want it to be off doing some computation or,
我们不希望它停止计算或者，

529
00:24:39,812 --> 00:24:41,144
certainly, never blocked waiting for
当然，永远不要阻止等待

530
00:24:41,213 --> 00:24:43,046
the network or something.
网络什么的。

531
00:24:43,115 --> 00:24:43,814
So that's the main queue,
这是主队列，

532
00:24:43,883 --> 00:24:45,682
that's the most important queue, and then,
这是最重要的队列，然后，

533
00:24:45,751 --> 00:24:47,384
there are these other queues.
还有其他的队列。

534
00:24:47,452 --> 00:24:49,986
I'm gonna talk first about the global queues.
我首先要讲的是全局队列。

535
00:24:50,055 --> 00:24:53,290
The global queues are different kind of queues.
全局队列是不同类型的队列。

536
00:24:53,359 --> 00:24:57,061
These global queues, people wait in line to go onto those,
这些全球队列，人们排队等着去看这些，

537
00:24:57,129 --> 00:24:59,596
and at the other end of the line the system has multiple
在线的另一端，系统有多个

538
00:24:59,665 --> 00:25:01,198
threads ready to go.
线程准备好了。

539
00:25:01,267 --> 00:25:04,067
And it can pull a closure off the line, give it a thread,
它可以拉出一条线，给它一条线，

540
00:25:04,136 --> 00:25:06,303
it starts running, pulls another one off,
它开始运行，又拉掉一个，

541
00:25:06,371 --> 00:25:09,072
it starts running before the first one's even done.
它在第一个人完成之前就开始运行了。

542
00:25:09,141 --> 00:25:12,209
So those are called concurrent queues.
这些被称为并发队列。

543
00:25:12,278 --> 00:25:14,979
The queues where you could be pulling people off the line
你可以把人们从队伍中拉出来的队伍

544
00:25:15,047 --> 00:25:18,415
cuz you got multiple threads to assign to the task.
因为你有多个线程来分配任务。

545
00:25:19,451 --> 00:25:21,218
So, things we do outside the UI,
我们在UI之外做的事情，

546
00:25:21,287 --> 00:25:24,688
like network things and things that block, we're generally
就像网络事物和事物一样，我们通常

547
00:25:24,756 --> 00:25:28,392
gonna do those in these global concurrent queues.
在全局并发队列中执行这些操作。

548
00:25:28,461 --> 00:25:31,261
You can also create your own serial queues and
您还可以创建自己的串行队列

549
00:25:31,330 --> 00:25:33,163
your own concurrent queues.
自己的并发队列。

550
00:25:33,232 --> 00:25:34,665
We'll talk about that in a couple slides.
我们将在几张幻灯片中讨论这个。

551
00:25:34,733 --> 00:25:36,633
You're not going to need to do that in this class.
在这门课上你不需要这么做。

552
00:25:36,702 --> 00:25:39,803
90% of the time you're either using the main queue, or

553
00:25:39,872 --> 00:25:42,772
you're using one of these global concurrent queues.
您正在使用其中一个全局并发队列。

554
00:25:42,841 --> 00:25:45,008
So let's talk about the code, how do you get a queue?
我们来讨论一下代码，如何得到一个队列?

555
00:25:45,077 --> 00:25:47,844
I need a queue because I wanna put a block of code on this
我需要一个队列，因为我想在这个上面放一个代码块

556
00:25:47,913 --> 00:25:50,614
queue, I want it to get in line to go run.
排队，我想让它排队去跑。

557
00:25:50,682 --> 00:25:51,948
Well, the main queue,
主队列,

558
00:25:52,017 --> 00:25:54,851
you just use this bar DispatchQueue.main.
你只需要使用这个条形DispatchQueue.main。

559
00:25:54,920 --> 00:25:56,620
It's a static bar, a class bar,
这是一个静态的酒吧，一个班级酒吧，

560
00:25:56,689 --> 00:25:59,089
on the class dispatch queue, and that's it,
在类调度队列中，

561
00:25:59,158 --> 00:26:02,325
you have your main queue, it couldn't be easier.
你有你的主队，这是不容易的。

562
00:26:02,394 --> 00:26:05,162
Now, getting one of these global concurrent queues,
现在，获取一个全局并发队列，

563
00:26:05,231 --> 00:26:06,863
a little bit more work.
还有一点功。

564
00:26:06,932 --> 00:26:09,632
You're going to use DispatchQueue.global instead
你将使用DispatchQueue。全球而不是

565
00:26:09,701 --> 00:26:13,404
of DispatchQueue.main, and it takes an argument there, QoS.
DispatchQueue。主要的，它需要一个参数，QoS。

566
00:26:13,472 --> 00:26:18,275
QoS stands for Quality of Service.
QoS代表服务质量。

567
00:26:18,343 --> 00:26:21,044
So this is talking about how, what
这就是我们要讨论的

568
00:26:21,113 --> 00:26:24,748
the quality of the service that the line is getting.
这条线所得到的服务质量。

569
00:26:24,817 --> 00:26:27,417
So, high quality service means things are being pulled off
因此，高质量的服务意味着事情正在被取消

570
00:26:27,486 --> 00:26:30,253
the line really fast and the threads that are being used to
这条线非常快，而且正在被使用的线程

571
00:26:30,322 --> 00:26:33,924
execute them are high priority threads that get to run a lot.
执行它们是获得大量运行的高优先级线程。

572
00:26:33,993 --> 00:26:36,092
Cuz remember there's only one processor, so
因为只有一个处理器，所以

573
00:26:36,161 --> 00:26:37,962
they often kinda share the processor.
他们经常分享处理器。

574
00:26:38,030 --> 00:26:40,563
So, high quality service means you get a lot.
因此，高质量的服务意味着你得到了很多。

575
00:26:40,632 --> 00:26:43,467
Low quality services, well, the system will pull your
低质量的服务，嗯，系统会拉动你

576
00:26:43,535 --> 00:26:46,403
thing off when it feels like it, like maybe the phone is,
当它感觉像手机的时候，

577
00:26:46,471 --> 00:26:48,772
is well, got woken up for some other reason,
好吧，因为其他原因被唤醒，

578
00:26:48,840 --> 00:26:51,007
it's not gonna wake your phone up to do it.
它不会把你的手机叫醒去做。

579
00:26:51,076 --> 00:26:54,544
And it's certainly not going to block any high priority
它当然不会阻止任何高优先级

580
00:26:54,613 --> 00:26:56,479
thing, that kind of thing.
就是这样。

581
00:26:56,548 --> 00:27:00,149
So, but the quality of service is not like a number, 0,
但是服务的质量不像数字0，

582
00:27:00,218 --> 00:27:02,919
low quality, 10, high quality, instead,
低质量，10，高质量，

583
00:27:02,988 --> 00:27:05,322
it's kind of a flavor of usage.
这是一种用法的味道。

584
00:27:05,391 --> 00:27:07,257
These are the four qualities of services here.
这里有四种服务品质。

585
00:27:07,326 --> 00:27:11,761
So user interactive is, means the user is interacting with
用户交互是指用户交互

586
00:27:11,830 --> 00:27:15,265
the UI right now, usually with a gesture.
UI现在，通常是一个手势。

587
00:27:15,334 --> 00:27:18,435
They are panning around, or pinching, and your forking off
他们正在四处淘金，或者捏着，你的分叉

588
00:27:18,503 --> 00:27:20,938
something into a thread to go do something.
某物进入某一线程去做某事。

589
00:27:21,006 --> 00:27:24,074
Now, this is usually not a case of the thing you're gonna
这通常不是你要做的事

590
00:27:24,143 --> 00:27:26,576
be doing is so intensive that it would block the main
要做的是如此的密集以至于它会阻止主要的

591
00:27:26,645 --> 00:27:29,613
thread, because the person is panning right now.
线程，因为这个人现在正在平移。

592
00:27:29,681 --> 00:27:32,783
But it might be something that can't quite keep up
但它可能是一些无法跟上的东西

593
00:27:32,851 --> 00:27:36,152
with the finger, and you're going to deal with that by,
用手指，你要处理这个，

594
00:27:36,221 --> 00:27:39,022
in this other thread, trying to keep up as best you can and
在另一个线程中，尽量保持最佳状态

595
00:27:39,091 --> 00:27:41,357
just updating the main thread as fast as you can,
只要尽快更新主线程，

596
00:27:41,426 --> 00:27:43,660
which might be a little slower than the fingers going.
这可能比手指要慢一点。

597
00:27:43,729 --> 00:27:45,262
So, you know, the finger dragging around,
所以，你知道，手指在拖动，

598
00:27:45,331 --> 00:27:47,897
maybe it's jumping a little bit because it can't calculate
也许它跳得有点高，因为它无法计算

599
00:27:47,966 --> 00:27:49,632
its new position fast enough.
它的新位置足够快。

600
00:27:49,701 --> 00:27:52,402
But the point is, this queue really needs to run,
但关键是，这个队列确实需要运行，

601
00:27:52,471 --> 00:27:55,505
almost as bad, it's almost as high priority as the main
几乎同样糟糕的是，它几乎是主要的优先级

602
00:27:55,574 --> 00:27:58,575
queue because you're doing something interactive.
排队，因为你在做一些互动的事情。

603
00:27:58,644 --> 00:28:00,844
Okay, the next one is user initiated.
下一个是用户发起的。

604
00:28:00,912 --> 00:28:04,381
What this means is this, the user currently did something
这意味着什么，用户现在做了什么

605
00:28:04,450 --> 00:28:07,184
to initiate this activity, this can be done in
要发起这个活动，就可以这样做

606
00:28:07,253 --> 00:28:09,953
this queue, so it's pretty high priority.
这个队列非常重要。

607
00:28:10,022 --> 00:28:12,789
Okay, the user did something and they're waiting for
用户做了一些事情，他们在等待

608
00:28:12,857 --> 00:28:14,090
a response presumably.
大概的回应。

609
00:28:14,159 --> 00:28:18,562
So that would be the category for our Cassini project.
这就是卡西尼项目的分类。

610
00:28:18,630 --> 00:28:22,366
We clicked Earth, or Saturn, we want that image now, and
我们点击地球，或者土星，我们现在想要那个图像

611
00:28:22,434 --> 00:28:23,633
we're waiting for it.
我们等待它。

612
00:28:23,702 --> 00:28:26,336
So we are gonna use, user initiated.
所以我们要使用，用户发起。

613
00:28:26,405 --> 00:28:28,305
Cuz the user initiated a request for it.
因为用户提出了一个请求。

614
00:28:28,374 --> 00:28:29,206
But it's gonna take a while,
但这需要一段时间，

615
00:28:29,275 --> 00:28:31,808
and the user's not interacting, we're not
而用户不交互，我们不是

616
00:28:31,876 --> 00:28:34,311
making it doing something different every time it moves.
让它每次移动都做些不同的事情。

617
00:28:34,379 --> 00:28:36,446
We were just, it's, but it was user initiated, so
我们只是，它是用户发起的，所以

618
00:28:36,515 --> 00:28:38,648
user initiated is pretty high priority.
用户发起是相当高的优先级。

619
00:28:38,717 --> 00:28:40,650
Then there's background and utility.
然后是背景和效用。

620
00:28:40,719 --> 00:28:41,952
These are somewhat similar.
这些都是有些相似的。

621
00:28:42,021 --> 00:28:46,056
Utility is truly the deepest of background processes.
实用程序确实是最深入的后台进程。

622
00:28:46,124 --> 00:28:48,625
This might be something you run once a week in your app.
这可能是你在应用程序中每周运行一次的东西。

623
00:28:48,694 --> 00:28:51,194
Maybe it cleans up the database by removing old
也许它通过删除旧的来清理数据库

624
00:28:51,263 --> 00:28:52,061
crufty stuff,
crufty东西,

625
00:28:52,130 --> 00:28:54,865
something the user doesn't even know is going on.
一些用户甚至不知道的事情正在发生。

626
00:28:54,933 --> 00:28:55,732
It's so low priority,
低优先级,

627
00:28:55,801 --> 00:28:57,267
it just kind of happens in the background.
只是在背景中发生。

628
00:28:57,335 --> 00:28:59,670
Background might be something that you, you,
背景可能是你，你，

629
00:28:59,738 --> 00:29:02,306
like maybe you're thinking ahead a little bit about
比如你在思考

630
00:29:02,374 --> 00:29:04,507
the way the user might want to use your app.
用户想要使用你的应用程序的方式。

631
00:29:04,576 --> 00:29:06,509
And so you fork something off in the background to go
所以你可以在后台取一些东西

632
00:29:06,578 --> 00:29:07,744
fetch some stuff or whatever.
去拿些东西什么的。

633
00:29:07,812 --> 00:29:10,113
The user didn't ask you to do it, but you kind of do it.
用户并没有要求你做，但你做了。

634
00:29:10,181 --> 00:29:12,482
And you kind of want it nowish but
你想要的不是它，而是

635
00:29:12,551 --> 00:29:15,318
it's okay if it takes a little while.
如果需要一点时间，就可以了。

636
00:29:15,387 --> 00:29:16,686
So you see what that one is.
你看这个是什么。

637
00:29:16,755 --> 00:29:18,989
So these are the four qualities of service and
这就是服务的四个特点

638
00:29:19,057 --> 00:29:21,658
you just need to pick which quality of service you want
你只需要选择你想要的服务质量

639
00:29:21,726 --> 00:29:22,893
for your global queue.
为你的全球队列。

640
00:29:22,961 --> 00:29:25,362
And then remember that the things you put on there
然后记住你在那里放的东西

641
00:29:25,431 --> 00:29:27,263
are going to be run concurrently, so
会同时运行吗

642
00:29:27,332 --> 00:29:29,599
they can really depend on each other.
他们真的可以互相依赖。

643
00:29:29,668 --> 00:29:33,036
I'll talk about things depending on each other in
我要讲的是相互依存的关系

644
00:29:33,105 --> 00:29:34,254
But this, you wanna think about the things you put on
但这个，你想想你穿的东西

645
00:29:34,255 --> 00:29:35,404
a second.
第二个。

646
00:29:35,473 --> 00:29:36,974
these global queues as being these
这些全球的队列就是这些

647
00:29:37,042 --> 00:29:39,475
independent little things, like go fetch this file,
独立的小东西，比如去取这个文件，

648
00:29:39,544 --> 00:29:42,179
it's all self contained, just give me this file.
都是自我控制的，给我这个文件。

649
00:29:42,247 --> 00:29:44,915
Not blocks that are gonna be somehow depending on
不是块，这要取决于

650
00:29:44,984 --> 00:29:47,283
each other's results because this is all concurrent,
彼此的结果，因为这都是并行的，

651
00:29:47,352 --> 00:29:48,852
these things can be happening at exactly the same time, so
这些事情可以同时发生，所以

652
00:29:48,920 --> 00:29:51,688
they can't really, it's not serial like the main queue.
他们不能真的，它不是串行的，就像主队列。

653
00:29:53,125 --> 00:29:55,692
Now, like I said, you've got this queue,
现在，就像我说的，你有这个队列，

654
00:29:55,761 --> 00:29:59,462
and all we're gonna do is put blocks on it and
我们要做的就是在上面加上块

655
00:29:59,531 --> 00:30:03,834
we do that with these two functions, async and sync.
我们通过这两个函数来实现，异步和同步。

656
00:30:05,270 --> 00:30:08,104
These two functions take one argument, which is a closure,
这两个函数有一个参数，即闭包，

657
00:30:08,173 --> 00:30:11,941
a function but usually it's a closure, that closure
一个函数，但通常是闭包，闭包

658
00:30:12,010 --> 00:30:14,645
function takes no arguments and returns no arguments.
函数不接受参数，不返回参数。

659
00:30:16,081 --> 00:30:17,848
And you can put anything you want in that closure.
你可以把任何你想要的东西放到那个闭包里。

660
00:30:19,852 --> 00:30:22,719
So, async means put this closure on the queue,
因此，async意味着把这个闭包放在队列上，

661
00:30:22,788 --> 00:30:26,189
put it in the line to execute, and return immediately.
将其放入行中执行，并立即返回。

662
00:30:26,258 --> 00:30:28,191
So async does nothing except for
所以async除了

663
00:30:28,260 --> 00:30:32,996
put that block into the queue, whatever queue you send it to.
把那个块放到队列中，不管发送到哪个队列。

664
00:30:33,065 --> 00:30:35,999
Sync, same thing, puts it in the queue and
同步，同样的，放到队列中

665
00:30:36,068 --> 00:30:40,103
then it says block this thread until that closure finishes
然后它说阻塞这个线程直到关闭结束

666
00:30:40,172 --> 00:30:43,373
executing on whatever queue it's on.
在任何队列上执行。

667
00:30:43,442 --> 00:30:44,941
Which could be a totally different queue.
这可能是一个完全不同的队列。

668
00:30:45,010 --> 00:30:49,645
So basically, the sync is block me until this closure
基本上，同步会阻塞我直到关闭

669
00:30:49,714 --> 00:30:53,950
finishes executing wherever you put it.
无论你把它放在哪里，都可以执行。

670
00:30:54,019 --> 00:30:57,020
So, you would never do sync on the main queue,
所以，你永远不会在主队列上同步，

671
00:30:57,089 --> 00:30:59,089
cuz we never want to block the main queue.
因为我们不想阻塞主队列。

672
00:30:59,157 --> 00:31:02,592
So, you would never say main queue.sync anything.
所以，你永远不会说主队列。任何同步。

673
00:31:02,661 --> 00:31:05,795
But you might have other queues and say,
但你可能会说，

674
00:31:05,864 --> 00:31:10,834
you know, sorry, you would say main queue, you could say main
你知道，对不起，你会说主队列，你可以说main

675
00:31:10,903 --> 00:31:13,736
queue.sync, but you would say it on another thread.
队列中。同步，但你会在另一个线程上说。

676
00:31:13,805 --> 00:31:15,472
You fire off some of the thread,
你点燃一些线，

677
00:31:15,541 --> 00:31:17,073
it's running along in the background.
它在后台运行。

678
00:31:17,142 --> 00:31:20,110
It could say main queue.sync, this code.
它可以说主队列。同步,这段代码。

679
00:31:20,178 --> 00:31:22,178
Now that code would be put on the main queue.
现在，代码将放在主队列上。

680
00:31:22,247 --> 00:31:23,746
Sometime later, we don't know when,
有时，我们不知道什么时候，

681
00:31:23,815 --> 00:31:24,981
it would run on the main queue.
它会在主队列上运行。

682
00:31:25,049 --> 00:31:28,352
Once it's done, then your thread,
一旦完成，

683
00:31:28,420 --> 00:31:32,155
your queue that issued this, would continue.
您的队列发布了这个，将会继续。

684
00:31:34,993 --> 00:31:38,361
So sync, we would only do the sync from code that is not on
所以同步，我们只会从代码中执行同步

685
00:31:38,429 --> 00:31:40,397
the main queue, cuz we never wanna block the main queue.
主队列，因为我们不想阻塞主队列。

686
00:31:40,465 --> 00:31:41,665
Question.
的问题。

687
00:31:41,733 --> 00:31:44,801
Yeah, so the question is, when I say sync, am I saying,
问题是，当我说同步的时候，我是说，

688
00:31:44,869 --> 00:31:48,238
let this block, this closure go first or something?
让这个方块，这个闭包先还是什么?

689
00:31:48,307 --> 00:31:50,540
No, okay, this has nothing to do with priority.
不，好吧，这和优先级无关。

690
00:31:50,609 --> 00:31:52,709
The priority is the quality of service.
首要的是服务的质量。

691
00:31:52,778 --> 00:31:54,211
I'm just saying put this queue,
我只是说这个队列，

692
00:31:54,280 --> 00:31:56,813
this closure onto the end of that queue.
这个关闭到该队列的末尾。

693
00:31:58,183 --> 00:31:59,582
Now, whatever queue it is,
不管它是什么队列，

694
00:31:59,651 --> 00:32:01,151
we'll have some quality of service and
我们将有一些服务质量

695
00:32:01,220 --> 00:32:03,020
it will eventually get to this thing.
它最终会到达这个。

696
00:32:03,088 --> 00:32:05,288
In the meantime, while all that's happening,
与此同时，当所有这些发生的时候，

697
00:32:05,356 --> 00:32:11,194
this queue that this code is in is waiting, it's blocked.
这个代码正在等待的队列，它被阻塞了。

698
00:32:11,263 --> 00:32:14,364
It's just blocked, waiting for that closure to finish.
它只是被阻塞，等待关闭结束。

699
00:32:14,432 --> 00:32:16,399
How that closure finishes depends totally on what queue
闭包如何完成取决于队列是什么

700
00:32:16,468 --> 00:32:18,868
you put it on, and how much other stuff is in that queue,
你把它放上去，还有多少东西在队列里，

701
00:32:18,937 --> 00:32:21,905
and whether it's a concurrent queue, all those things.
它是否是一个并发队列，所有这些东西。

702
00:32:24,243 --> 00:32:27,010
But this sync just means block me until that thing's done.
但这个同步就意味着阻止我完成它。

703
00:32:28,613 --> 00:32:29,613
Question.
的问题。

704
00:32:29,681 --> 00:32:32,115
So the question is, does running multiple threads,
问题是，运行多个线程，

705
00:32:32,184 --> 00:32:34,551
having multiple things going in multiple threads,
在多个线程中运行多个东西，

706
00:32:34,620 --> 00:32:36,419
does it slow down the main queue thread,
它会减慢主线程吗?

707
00:32:36,488 --> 00:32:38,421
the thread that is running the main queue?
运行主队列的线程?

708
00:32:38,489 --> 00:32:40,756
And the answer is no.
答案是否定的。

709
00:32:40,825 --> 00:32:43,693
It does not usually, because the main queue is getting
它通常不会，因为主要队列是获取的

710
00:32:43,762 --> 00:32:45,428
a lot of high priority.
有很多高优先级。

711
00:32:45,497 --> 00:32:48,031
So it's pretty much interrupting anything those
所以很容易打断

712
00:32:48,100 --> 00:32:50,834
other guys are doing whenever it wants to run, okay?
其他的人在想跑的时候都在做，对吧?

713
00:32:50,902 --> 00:32:51,868
So if it wants to run,
如果它想要运行，

714
00:32:51,936 --> 00:32:53,636
it pretty much gets the processor.
它几乎得到了处理器。

715
00:32:53,705 --> 00:32:57,507
The main queue is the highest priority thread that exist on
主队列是存在的最高优先级线程

716
00:32:57,576 --> 00:32:59,008
the device.
该设备。

717
00:32:59,077 --> 00:33:02,079
So it's rarely gonna be slowed down.
所以它很少会被减速。

718
00:33:02,147 --> 00:33:05,048
Now, I'm not gonna talk about this, but yes,
我不打算讲这个，但是，

719
00:33:05,116 --> 00:33:06,883
threads have overhead.
线程的开销。

720
00:33:06,952 --> 00:33:08,485
If you created thousands of threads,
如果你创造了成千上万的线程，

721
00:33:08,553 --> 00:33:10,153
that would start slowing down your computer.
这会让你的电脑慢下来。

722
00:33:10,221 --> 00:33:12,455
But again, that's why we don't really talk about threads.
但是，这也是为什么我们不讨论线程的原因。

723
00:33:12,524 --> 00:33:13,456
We talk about queues and
我们谈论排队和

724
00:33:13,525 --> 00:33:16,159
we let the iOS manage the threads cuz it knows how to
我们让iOS管理线程，因为它知道如何操作

725
00:33:16,228 --> 00:33:18,895
efficiently manage thread pools and things like that.
有效地管理线程池和类似的东西。

726
00:33:22,067 --> 00:33:25,801
You can create your own queues just using
您可以使用它创建自己的队列

727
00:33:25,870 --> 00:33:27,804
a normal initializer of DispatchQueue.
DispatchQueue的普通初始化器。

728
00:33:27,873 --> 00:33:29,673
Instead of saying DispatchQueue.main or
而不是说DispatchQueue。主要还是

729
00:33:29,741 --> 00:33:32,642
DispatchQueue.global, you say DispatchQueue
DispatchQueue。全球,你说DispatchQueue

730
00:33:32,710 --> 00:33:35,212
with the initializer that takes a label that makes
带有一个标签的初始化器

731
00:33:35,280 --> 00:33:36,813
a serial queue.
一个串行队列。

732
00:33:36,881 --> 00:33:39,950
And that label, it shows up in the debugger.
这个标签出现在调试器中。

733
00:33:40,018 --> 00:33:41,984
So in the debugger if you pause and
在调试器中，如果你暂停

734
00:33:42,053 --> 00:33:43,887
that queue is running a thread,
这个队列正在运行一个线程，

735
00:33:43,955 --> 00:33:46,122
you'll see that thread in the little debugger window on
您将在“小调试器”窗口中看到该线程

736
00:33:46,191 --> 00:33:48,825
the left in the navigator with this name, this label,
导航器中左边的这个名称，这个标签，

737
00:33:48,893 --> 00:33:51,461
so it's just purely for seeing it in the debugger.
这纯粹是在调试器中看到的。

738
00:33:51,530 --> 00:33:53,629
And if you wanna make your own concurrent queue.
如果你想创建自己的并发队列。

739
00:33:53,698 --> 00:33:56,233
A queue that has multiple threads that can be working
一个具有多个可工作线程的队列

740
00:33:56,301 --> 00:33:57,066
on things.
上的东西。

741
00:33:57,135 --> 00:34:00,936
Then same thing, except you put attributes.concurrent,
同样的，除了你把attributes. concurrent，

742
00:34:01,005 --> 00:34:02,039
in the initializer there.
在初始值设定项。

743
00:34:03,875 --> 00:34:05,175
You won't need to do that in this class and
在这个课程中你不需要这样做

744
00:34:05,243 --> 00:34:05,875
rarely do we do this.
我们很少这样做。

745
00:34:05,944 --> 00:34:08,411
It's usually main queue and
它通常是主队列

746
00:34:08,479 --> 00:34:11,814
the global queues 90% of the time.
全球排在90%的时间。

747
00:34:11,883 --> 00:34:14,584
All right, I'm only showing you the absolute tip
好吧，我只是给你们看绝对小费

748
00:34:14,652 --> 00:34:16,652
of the iceberg for multithreading.
关于多线程的冰山。

749
00:34:16,721 --> 00:34:19,055
I'm showing you the basic stuff you need to get stuff
我向你们展示了一些基本的东西

750
00:34:19,124 --> 00:34:21,757
off of the main thread but there is a lot more.
除了主线程，还有很多。

751
00:34:21,826 --> 00:34:24,760
You're gonna wanna familiarize yourself eventually with
你要让自己熟悉一下

752
00:34:24,829 --> 00:34:27,230
DispatchQueue and all the things that it can do.
DispatchQueue和它能做的所有事情。

753
00:34:27,299 --> 00:34:29,198
This stuff is all based on something
这些东西都是基于某些东西的

754
00:34:29,267 --> 00:34:31,134
called Grand Central Dispatch.
称为中央调度。

755
00:34:31,202 --> 00:34:34,370
Because when we put a closure onto a queue,
因为当我们把一个闭包放到一个队列上时，

756
00:34:34,439 --> 00:34:38,175
we call that dispatching the closure onto that queue.
我们调用它将闭包发送到该队列。

757
00:34:41,045 --> 00:34:43,579
For those of you who do know about multithreading,
对于那些了解多线程的人，

758
00:34:43,648 --> 00:34:45,648
you can do all the things you can expect,
你可以做所有你能想到的事情，

759
00:34:45,717 --> 00:34:49,018
protecting critical sections, readers and writers, you know,
保护重要的章节，读者和作家，你知道，

760
00:34:49,087 --> 00:34:50,820
single writer multiple readers.
单个作家多个读者。

761
00:34:50,889 --> 00:34:52,856
You can do synchronous dispatch, you can do locking,
可以进行同步调度，也可以锁定，

762
00:34:52,925 --> 00:34:54,291
all the things you need to do you can do.
你需要做的所有事情都可以做到。

763
00:34:54,359 --> 00:34:57,561
I'm not gonna talk about any of that, but it's all there.
我不打算讲这些，但都在那里。

764
00:35:01,266 --> 00:35:04,333
There is another API for doing multithreading,
还有一个用于多线程的API，

765
00:35:04,402 --> 00:35:08,405
OperationQueue and Operation, these are classes.
操作队列和操作，这些是类。

766
00:35:08,473 --> 00:35:10,373
Classes or structs, I guess they're classes.
类或结构，我想它们是类。

767
00:35:10,441 --> 00:35:13,142
And you'll see those occasionally in iOS API,
在iOS API中偶尔会看到，

768
00:35:13,211 --> 00:35:15,011
kinda older iOS API.
有点旧的iOS API。

769
00:35:15,079 --> 00:35:17,047
But for the program you're gonna do, again,
但是对于你要做的程序，

770
00:35:17,115 --> 00:35:19,615
unless you got the kind of multithreading problem, which
除非你有多线程问题

771
00:35:19,684 --> 00:35:22,819
is doing a parallel processing thing, not the kind of problem
做一个并行处理的事情，不是问题吗

772
00:35:22,887 --> 00:35:25,488
where you're getting something off the main queue.
你从主队列中得到一些东西。

773
00:35:25,557 --> 00:35:28,758
Operation and OperationQueue are nice because it makes easy
操作和操作队列很好，因为它很简单

774
00:35:28,826 --> 00:35:30,326
to make dependencies.
依赖关系。

775
00:35:30,395 --> 00:35:31,661
Where you say this block of code
你在哪里说这段代码

776
00:35:31,729 --> 00:35:33,696
depends on this one running first,
取决于这个先跑，

777
00:35:33,765 --> 00:35:36,632
I need the result from this one before I can do this one.
在我做这个之前，我需要这个结果。

778
00:35:36,701 --> 00:35:38,434
So you can set up those relationships,
你可以建立这些关系，

779
00:35:38,503 --> 00:35:40,703
then you can say, now I just start running them.
然后你可以说，现在我开始运行它们。

780
00:35:40,772 --> 00:35:41,604
And the system
和系统

781
00:35:41,673 --> 00:35:44,474
will make sure this one gets run before this one, etc.
确保这个在这个之前运行，等等。

782
00:35:44,543 --> 00:35:45,375
All those dependencies.
所有这些依赖关系。

783
00:35:45,444 --> 00:35:48,545
So that's Operation and OperationQueue.
这就是操作和操作队列。

784
00:35:54,085 --> 00:35:56,653
you'll see certain methods that are multithreaded.
您将看到一些多线程的方法。

785
00:35:56,654 --> 00:35:59,222
In iOS,
在iOS,

786
00:35:59,291 --> 00:36:00,856
And you'll see that in the documentation,
你会在文档中看到，

787
00:36:00,925 --> 00:36:02,491
you'll read in the documentation.
您将在文档中阅读。

788
00:36:02,560 --> 00:36:05,261
And the way it works is you're gonna see a method that takes
它工作的方式就是你会看到一个方法

789
00:36:05,330 --> 00:36:08,164
a closure as an argument, and it'll say in the documentation
一个闭包作为一个参数，它会在文档中说

790
00:36:08,232 --> 00:36:10,867
this closure is run on another thread off the main queue.
这个闭包在主队列的另一个线程上运行。

791
00:36:10,935 --> 00:36:12,168
And when you see that,
当你看到它的时候，

792
00:36:12,237 --> 00:36:15,905
you have to go, uh-oh, because any code I put in that closure
你必须要走，因为任何代码都是关闭的

793
00:36:15,974 --> 00:36:19,409
that I'm passing to this function can't be doing any
我传递给这个函数的过程是不可能的

794
00:36:19,477 --> 00:36:22,678
UI stuff because that only can happen on the main queue.
UI，因为它只会发生在主队列上。

795
00:36:22,747 --> 00:36:25,481
And this happens quite a lot, that we have a closure that
这种情况经常发生，我们有一个闭包

796
00:36:25,550 --> 00:36:27,750
we're putting on some background queue, or
我们设置了一些后台队列

797
00:36:27,819 --> 00:36:29,286
passing to some iOS function,
传递到一些iOS函数，

798
00:36:29,354 --> 00:36:32,188
that says it's not gonna put it on the main queue.
也就是说，它不会把它放到主队列上。

799
00:36:32,257 --> 00:36:35,692
But we still wanna do UI stuff, so how do we do that?
但我们还是想做UI，怎么做呢?

800
00:36:35,760 --> 00:36:38,761
We just dispatch it back to the main queue.
我们只需将它发送回主队列。

801
00:36:38,830 --> 00:36:41,564
And this is what that looks like.
这就是它的样子。

802
00:36:41,633 --> 00:36:46,669
Here is an iOS API that takes a closure as an argument and
这是一个将闭包作为参数的iOS API

803
00:36:46,738 --> 00:36:49,606
it runs that closure off the main queue.
它运行的是关闭主队列。

804
00:36:49,675 --> 00:36:52,541
I's called NSURLSession, i's used for
我被称为NSURLSession，我是用来做的

805
00:36:52,610 --> 00:36:54,477
getting the contents of URLs.
获取url的内容。

806
00:36:54,545 --> 00:36:58,547
Now, you saw in our image view controller demo, so far,
现在，你们在我们的图像视图控制器演示中看到，到目前为止，

807
00:36:58,616 --> 00:37:01,017
that we already know how to get the contents of URLs,
我们已经知道如何获取url的内容，

808
00:37:01,086 --> 00:37:03,486
we just use data contents of.
我们只使用数据内容。

809
00:37:03,555 --> 00:37:05,922
Remember, we said try data contents of.
记住，我们说的是尝试数据内容。

810
00:37:05,990 --> 00:37:09,125
And it blocked, blocked the main queue while it went and
它阻塞了，阻塞了主队列

811
00:37:09,194 --> 00:37:10,126
got that URL.
该URL。

812
00:37:10,195 --> 00:37:11,427
So that's one way to do it.
这是一种方法。

813
00:37:11,496 --> 00:37:14,631
But it kind of non-configurable.
但它是不可配置的。

814
00:37:14,699 --> 00:37:16,933
What's cool about NSURLSession is,
NSURLSession最酷的是，

815
00:37:17,001 --> 00:37:20,036
you see that argument there configuration.default?
看到这个参数了吗，默认值?

816
00:37:20,105 --> 00:37:21,537
Well, you can change that configuration.
你可以改变这个构型。

817
00:37:21,606 --> 00:37:24,040
For example, you could say, I'm gonna fetch this URL,
例如，你可以说，我要取回这个URL，

818
00:37:24,108 --> 00:37:26,876
but don't fetch it over cellular.
但不要在细胞上取它。

819
00:37:26,945 --> 00:37:28,611
Only fetch it if I happen to be on a Wi-Fi
只要我碰巧在wi - fi上，就去取它

820
00:37:28,679 --> 00:37:30,980
network, for example.
例如,网络。

821
00:37:31,049 --> 00:37:32,749
So you can configure how you want this fetching to happen.
因此，您可以配置您希望这种抓取发生的方式。

822
00:37:32,818 --> 00:37:35,885
So it's kind of a more powerful way of fetching than
这是一种更强大的抓取方式

823
00:37:35,954 --> 00:37:37,854
just saying data contents of.
只是说数据的内容。

824
00:37:37,923 --> 00:37:42,191
And the way it works is you create an NSURLSession with a,
它的工作原理是用a来创建一个NSURLSession，

825
00:37:42,260 --> 00:37:46,962
(this is an old slide, so it's just called URLSession and URL

826
00:37:47,031 --> 00:37:51,768
not NSURL), but you create it with a certain configuration,
不是NSURL，但是你用一个特定的配置来创建它，

827
00:37:51,837 --> 00:37:55,471
then you get the URL you want and then you call this
然后你得到你想要的URL然后你调用它

828
00:37:55,540 --> 00:37:59,042
method dataTask(with: url) and closure.
方法dataTask(with:url)和闭包。

829
00:37:59,110 --> 00:38:03,512
And what this does is it creates a dataTask object.
它所做的就是创建一个dataTask对象。

830
00:38:03,581 --> 00:38:06,082
With that URL that you want to get, and when, and
有了你想要得到的URL，以及何时，以及

831
00:38:06,151 --> 00:38:08,717
it goes off to fetch it, or it will in a minute.
它会去取它，或者它会在一分钟内。

832
00:38:08,786 --> 00:38:10,386
And when you send it off to fetch it,
当你把它送去取的时候，

833
00:38:10,455 --> 00:38:13,055
when it comes back it will call this closure and
当它回来的时候，它会调用这个闭包

834
00:38:13,124 --> 00:38:14,590
this closure has three arguments.
这个闭包有三个参数。

835
00:38:14,659 --> 00:38:17,493
The data it got from the URL, the NSURL or
它从URL中得到的数据，NSURL

836
00:38:17,562 --> 00:38:20,930
the URL response, and then some error,
URL响应，然后是一些错误，

837
00:38:20,999 --> 00:38:24,400
if some error happened trying to get it.
如果发生了一些错误。

838
00:38:24,469 --> 00:38:27,670
So the, that closure, so this closure is interesting cuz it,
这个闭包，这个闭包很有趣，

839
00:38:27,739 --> 00:38:29,339
the documentation will tell you,
文档会告诉你，

840
00:38:29,407 --> 00:38:32,275
this closure does not run on the main queue.
这个闭包不会在主队列上运行。

841
00:38:32,344 --> 00:38:35,878
So, that's a problem because if, (by the way, that resume,
所以，这是个问题，因为如果，

842
00:38:35,947 --> 00:38:37,513
task.resume at the bottom,
的任务。简历在底部,

843
00:38:37,582 --> 00:38:40,516
that's what actually causes it to go do the fetch),
这就是实际的取回的原因，

844
00:38:40,585 --> 00:38:43,185
so the dataTask really doesn't do anything but
dataTask实际上什么都不做

845
00:38:43,254 --> 00:38:46,522
create the task, and then when you say task.resume it goes
创建任务，然后当你说任务的时候。恢复它

846
00:38:46,591 --> 00:38:49,625
off to fetch it on some other thread, doesn't block.
在别的线程上取它，不阻塞。

847
00:38:49,694 --> 00:38:51,661
task.resume does not block obviously.
的任务。简历没有明显的阻碍。

848
00:38:52,597 --> 00:38:54,196
So when the closure,
当关闭,

849
00:38:54,265 --> 00:38:57,033
when the data is gotten and that closure is finally called
当数据得到，关闭最终被调用

850
00:38:57,101 --> 00:38:59,535
on some other queue besides the main queue.
在主队列之外的其他队列上。

851
00:38:59,604 --> 00:39:02,338
You wanna do some UI in there like you wanna show the image
你想在那里做一些UI，就像你想显示图像一样

852
00:39:02,406 --> 00:39:04,173
that you just fetched or whatever.
你只是拿来了什么的。

853
00:39:04,242 --> 00:39:06,943
And you can't do it because you're not on the main queue.
你不能这么做，因为你不在主队列上。

854
00:39:07,912 --> 00:39:09,245
So, how do you fix that?
那么，如何解决这个问题呢?

855
00:39:09,314 --> 00:39:13,082
You just put inside of this
你把它放在里面

856
00:39:13,150 --> 00:39:16,186
closure that you put right here, another dispatch.
关闭这里，另一个调度。

857
00:39:17,188 --> 00:39:18,788
Back to the main queue.
回到主队列。

858
00:39:20,158 --> 00:39:24,827
DispatchQueue.main.async with a closure.
DispatchQueue.main。异步关闭。

859
00:39:24,895 --> 00:39:26,295
And you put your UI stuff in there,
把UI放到这里，

860
00:39:26,364 --> 00:39:29,399
now it's gonna happen back on the other, on the main queue.
现在它会发生在另一个，在主队列上。

861
00:39:31,202 --> 00:39:34,404
So let's go through, I wanna show you the timing
让我们来回顾一下，我想告诉你们时间

862
00:39:34,473 --> 00:39:36,905
of each of the steps of this code right here.
这个代码的每一个步骤。

863
00:39:36,974 --> 00:39:40,009
So you can see what's happening, when.
所以你可以看到发生了什么，什么时候。

864
00:39:40,078 --> 00:39:43,145
Because multithreading is really a lot about when, and
因为多线程确实很重要

865
00:39:43,214 --> 00:39:44,880
it's the when that can confuse people when
这是什么时候会让人感到困惑的时候

866
00:39:44,949 --> 00:39:46,449
they're doing multithreading.
他们正在做多线程。

867
00:39:46,518 --> 00:39:49,852
So obviously, the first line of code is that let url,
很明显，第一行代码是，url，

868
00:39:49,921 --> 00:39:52,155
get the url, so now I have the url.
获取url，现在我有了url。

869
00:39:52,224 --> 00:39:53,889
Next, we're gonna create this dataTask.
接下来，我们要创建这个dataTask。

870
00:39:53,958 --> 00:39:56,058
This line of code, line B there, returns immediately.
这一行代码，B行，立即返回。

871
00:39:56,127 --> 00:39:58,027
Because all it does is create the dataTask,
因为它所做的就是创建dataTask，

872
00:39:58,096 --> 00:39:59,595
it doesn't actually do anything.
它实际上什么都没做。

873
00:39:59,664 --> 00:40:02,632
You pass the closure to it, but it's a non-escaping
你把它关了，但它是一个非逃避的

874
00:40:02,701 --> 00:40:06,569
Closure, hold onto it, this data task thing holds onto it.
闭包，按住它，这个数据任务保存在它上面。

875
00:40:06,638 --> 00:40:10,306
Then you do task resume, that also returns immediately.
然后你做任务简历，也会立即返回。

876
00:40:10,375 --> 00:40:12,809
But on a different queue, it starts doing the fetch.
但在另一个队列上，它开始执行取回。

877
00:40:12,877 --> 00:40:16,012
It starts trying to get the contents of that URL.
它开始尝试获取URL的内容。

878
00:40:16,081 --> 00:40:17,012
But on some other queue, so
但在另一些队列上

879
00:40:17,081 --> 00:40:20,149
that's why on this queue, this is the main queue presumably.
这就是为什么在这个队列中，这是主要的队列。

880
00:40:20,218 --> 00:40:21,450
It is returning immediately,
这是立即返回,

881
00:40:21,519 --> 00:40:23,085
task.resume returns immediately.
的任务。简历立即返回。

882
00:40:23,154 --> 00:40:26,489
So that means that line H happens immediately right
这意味着直线H会立即发生

883
00:40:26,558 --> 00:40:29,425
after task resume, boom the print firing,
任务恢复后，打印开火，

884
00:40:29,494 --> 00:40:31,761
done firing off the request.
完成了请求。

885
00:40:31,829 --> 00:40:32,895
But that's all we've done is fired
但这就是我们所做的一切

886
00:40:32,964 --> 00:40:34,097
off the request at this point.
在这一点上，请停止。

887
00:40:36,167 --> 00:40:38,901
The next line of code that's gonna happen after this one
下一行代码将在这个之后发生

888
00:40:38,970 --> 00:40:40,436
is this one.
这是一个。

889
00:40:40,505 --> 00:40:43,072
So after the URL contents come back,
URL内容回来之后，

890
00:40:43,140 --> 00:40:45,275
now this closure is gonna execute.
现在这个闭包就会执行。

891
00:40:45,343 --> 00:40:48,177
And so we're gonna have line c be executed.
所以我们要执行c行。

892
00:40:48,245 --> 00:40:51,781
So a, b, g, and h, they executed boom, boom, boom,
所以a b g h，他们执行了boom,boom,boom，

893
00:40:51,849 --> 00:40:54,550
boom, run right after each other, no delay.
砰，一声接着一声，毫不迟延。

894
00:40:54,619 --> 00:40:57,419
Then there was a delay while we went and
我们去的时候有一个耽搁

895
00:40:57,488 --> 00:40:59,055
got the URL content.
有内容的URL。

896
00:40:59,124 --> 00:41:00,923
That could be a long delay.
这可能是一个很长的延迟。

897
00:41:00,992 --> 00:41:03,859
That could be minute or more if it was a big file over
如果是一个大文件，那可能会是一分钟或更长时间

898
00:41:03,928 --> 00:41:05,227
cellular or something like that.
细胞之类的。

899
00:41:05,296 --> 00:41:08,331
So this line of code, c, you have to be careful.
所以这一行，c，你要小心。

900
00:41:08,399 --> 00:41:11,300
It could happen much later, and by the time it happens,
它可能发生在很久以后，当它发生的时候，

901
00:41:11,369 --> 00:41:13,469
you might not even care anymore.
你可能再也不在乎了。

902
00:41:13,538 --> 00:41:15,638
If you had a really slow network and a big file,
如果你有一个很慢的网络和一个大文件，

903
00:41:15,706 --> 00:41:18,341
by the time it came back, the user, they're like,
当它回来的时候，用户，他们说，

904
00:41:18,410 --> 00:41:20,476
I don't even care about it.
我甚至不关心它。

905
00:41:20,545 --> 00:41:22,512
So you, when you come back to line c right there,
当你回到c行，

906
00:41:22,580 --> 00:41:25,014
you better check and make sure that you still even care.
你最好检查一下，确保你仍然关心。

907
00:41:27,252 --> 00:41:29,118
Make sense?
有意义吗?

908
00:41:29,186 --> 00:41:31,754
All right, next thing that happens is we wanna do some UI
接下来，我们要做一些UI

909
00:41:31,823 --> 00:41:34,356
stuff with the data we got back.
我们取回的数据。

910
00:41:34,425 --> 00:41:35,524
But of course to do that,
当然，

911
00:41:35,593 --> 00:41:37,993
we have to dispatch to the main queue.
我们必须调度到主队列。

912
00:41:38,062 --> 00:41:40,062
This line of code, line d,
这一行代码d，

913
00:41:40,131 --> 00:41:45,034
also returns immediately because it's async dispatch.
还可以立即返回，因为它是异步调度。

914
00:41:45,103 --> 00:41:48,804
All it's doing is putting that closure onto the main queue.
它所做的就是将关闭放到主队列上。

915
00:41:48,873 --> 00:41:51,073
So this is the next line of code that executes.
这是执行的下一行代码。

916
00:41:51,142 --> 00:41:54,677
Notice line e has not executed yet.
注意到e还没有执行。

917
00:41:54,746 --> 00:41:57,213
Line f executes and it just says I did some stuff with
行f执行，它只是说我做了一些事情

918
00:41:57,282 --> 00:41:59,448
the data, but the UI part hasn't happened yet.
数据，但UI部分还没有发生。

919
00:41:59,517 --> 00:42:03,319
I put it on the queue, but it hasn't been executed yet
我把它放在队列上，但还没有执行

920
00:42:03,388 --> 00:42:04,854
by the main queue.
在主要的队列中。

921
00:42:06,124 --> 00:42:10,893
And then finally the UI stuff gets pulled off
最后，UI被取消了

922
00:42:10,962 --> 00:42:14,163
the main queue and executed.
主队列并执行。

923
00:42:14,232 --> 00:42:17,300
Did everyone understand that process?
大家都明白这个过程了吗?

924
00:42:17,368 --> 00:42:20,903
So to summarize, its a, b, g, h, c, d, f, e.
总结一下，a,b,g,h,c,d,f,e。

925
00:42:20,972 --> 00:42:23,973
Now this thing about this,
关于这个，

926
00:42:24,041 --> 00:42:27,944
there's actually not necessarily exactly this way.
实际上并不是这样的。

927
00:42:28,012 --> 00:42:31,914
Because when you dispatch things to the main queue from
因为当你将东西发送到主队列时

928
00:42:31,983 --> 00:42:35,651
the main queue, they could run right away.
主队列，他们可以马上运行。

929
00:42:35,720 --> 00:42:39,087
So it is possible that e could happen before f.
所以e可能在f之前发生。

930
00:42:39,156 --> 00:42:41,423
But if this was on some other queue besides the main queue,
但如果这是在主队列之外的其他队列上，

931
00:42:41,492 --> 00:42:43,659
it's very unlikely that e could happen before f.
在f之前，e很不可能发生。

932
00:42:43,728 --> 00:42:45,762
But it even could then because the main queue has so
但它甚至可以，因为主要的队列是这样的

933
00:42:45,830 --> 00:42:48,363
much priority that when you dispatch something onto it,
很重要的一点是，当你在上面发布一些东西时，

934
00:42:48,432 --> 00:42:51,534
the system might immediately go and try and process it.
系统可能会立即尝试并处理它。

935
00:42:51,603 --> 00:42:53,269
That's how high priority the main queue is.
这就是主队列的优先级。

936
00:42:53,338 --> 00:42:55,738
So it's possible that e could happen before f.
所以e可能在f之前发生。

937
00:42:55,807 --> 00:42:58,674
But I just want you to think conceptually that when you put
但我只是想让你们从概念上思考

938
00:42:58,742 --> 00:43:01,911
something on the queue, you kind of put it on the queue,
在队列上，你把它放在队列上，

939
00:43:01,980 --> 00:43:03,163
There might be other things on the main queue ahead of you.
在你前面的主要队列中可能还有其他的东西。

940
00:43:03,164 --> 00:43:04,347
could happen later.
以后可能发生。

941
00:43:05,617 --> 00:43:07,650
So definitely wouldn't run right away then.
所以肯定不会马上跑。

942
00:43:09,820 --> 00:43:11,087
So that's the timing of multithreaded.
这就是多线程的时间。

943
00:43:11,156 --> 00:43:14,623
So let's go back to our Cassini code and make it so
让我们回到卡西尼代码

944
00:43:14,692 --> 00:43:18,761
that it uses these queues to stop blocking the main thread
它使用这些队列来停止阻塞主线程

945
00:43:18,829 --> 00:43:21,464
and stop being all stuck like that.
不要再像那样被困住了。

946
00:43:22,634 --> 00:43:27,303
To do this is actually remarkably simple.
这样做其实非常简单。

947
00:43:27,372 --> 00:43:29,671
We're just gonna go back to our imageViewController,
我们将返回imageViewController，

948
00:43:29,740 --> 00:43:31,874
this is the deadly line of code.
这是一条致命的代码。

949
00:43:31,943 --> 00:43:33,042
I even put a comment in for
我甚至对此发表了评论

950
00:43:33,111 --> 00:43:36,045
this line of code when I posted this last time so
这是我上次发布的代码

951
00:43:36,114 --> 00:43:38,080
that you realize this is a terrible line of code.
你意识到这是一条可怕的代码。

952
00:43:38,149 --> 00:43:40,349
This line of code, if this is in, from now on,
这行代码，如果这是在，从现在开始，

953
00:43:40,418 --> 00:43:42,918
if you turn in homework with a line of code like this,
如果你用这样的代码来做作业，

954
00:43:42,987 --> 00:43:44,520
you're gonna get major dings.
你会得到重大消息的。

955
00:43:44,589 --> 00:43:47,656
Because one of the evaluation criteria now is gonna be no
因为其中一个评估标准是否定的

956
00:43:47,725 --> 00:43:49,558
more blocking the main queue.
更多的阻塞主队列。

957
00:43:49,627 --> 00:43:50,960
You cannot block the main queue.
不能阻塞主队列。

958
00:43:51,028 --> 00:43:54,030
That's, that's an evaluation criteria of all the homework
这是所有家庭作业的评估标准

959
00:43:54,099 --> 00:43:56,565
going forward and of your final project.
展望你的最终计划。

960
00:43:56,634 --> 00:44:00,836
All right, so we have this terrible thing, and we can't
好吧，我们有一件可怕的事，我们不能

961
00:44:00,905 --> 00:44:03,272
do this line of code like this cuz it blocks the main queue,
像这样的代码行，因为它阻塞了主队列，

962
00:44:03,341 --> 00:44:04,340
so what are we gonna do?
那我们该怎么办?

963
00:44:04,409 --> 00:44:08,978
We're just simply gonna put this call on some other queue.
我们只是把这个调用放到其他队列上。

964
00:44:09,047 --> 00:44:13,182
And I'm gonna do that by just saying DispatchQueue.global,
我要用DispatchQueue.global来做，

965
00:44:13,251 --> 00:44:14,750
I'm gonna get a global,
我将得到一个全局变量，

966
00:44:14,819 --> 00:44:17,853
one of these global concurrent queues.
其中一个全局并发队列。

967
00:44:17,922 --> 00:44:22,224
And it's asking me for the quality of service.
它要求我提供服务质量。

968
00:44:22,293 --> 00:44:24,894
And the user initiated this request, but
用户发起了这个请求，但是

969
00:44:24,963 --> 00:44:28,731
it's not interactive, so I'm gonna say userInitiated,
它不是交互式的，所以我说user发起，

970
00:44:28,800 --> 00:44:30,499
the choices there.
的选择。

971
00:44:30,568 --> 00:44:34,236
Now I've got the queue I want, and I'm just gonna
现在我有了我想要的队列，然后我就开始

972
00:44:34,305 --> 00:44:37,807
asynchronously post this code that I wanna do,
异步地发布我想要做的代码，

973
00:44:37,876 --> 00:44:41,444
this code that blocks, onto that global queue.
此代码将阻塞到全局队列。

974
00:44:41,512 --> 00:44:44,447
And at some point, that global queue is going to allocate
在某个时候，全局队列将会分配

975
00:44:44,515 --> 00:44:47,183
a thread and grab this closure off it and start running.
一根线，抓住这个关闭它并开始运行。

976
00:44:48,653 --> 00:44:50,619
Now that's gonna happen pretty darn quick, but
这很快就会发生，但是

977
00:44:50,688 --> 00:44:51,988
not necessarily instantly.
不一定立即。

978
00:44:52,991 --> 00:44:54,289
So now I've solved the problem,
现在我已经解决了这个问题，

979
00:44:54,358 --> 00:44:55,924
woo hoo, it's off the main queue.
哇，它不在主队列。

980
00:44:55,993 --> 00:44:57,560
No longer blocking the main queue because this,
不再阻塞主队列，

981
00:44:57,629 --> 00:44:58,761
which is executed on the main queue,
它在主队列上执行，

982
00:44:58,830 --> 00:45:00,263
because all of this code is on the main queue.
因为所有这些代码都在主队列上。

983
00:45:00,331 --> 00:45:02,932
We're executing all of our codes generally on
我们正在执行我们所有的代码

984
00:45:03,000 --> 00:45:07,202
the main queue.
主要的队列。

985
00:45:07,271 --> 00:45:09,438
This returns immediately.
这立即返回。

986
00:45:09,506 --> 00:45:12,842
It's async, so it immediately returns, it just puts that
它是async，所以它会立即返回，它只是把它放在这里

987
00:45:14,078 --> 00:45:16,178
closure on the queue and returns immediately.
关闭队列并立即返回。

988
00:45:16,247 --> 00:45:18,381
So no blocking the main queue, excellent.
所以没有阻塞主队列，很好。

989
00:45:18,449 --> 00:45:21,050
But you notice I got this little error here.
但是你注意到我在这里犯了一个小错误。

990
00:45:21,119 --> 00:45:23,252
Let's take a look at it, what's that thing?
让我们来看看，那是什么?

991
00:45:23,321 --> 00:45:27,223
Yeah, reference to self inside a closure.
是的，在闭包里提到self。

992
00:45:27,291 --> 00:45:29,258
You have to explicitly put self so
你必须明确地把自己放出来

993
00:45:29,326 --> 00:45:31,627
that you think about memory cycles.
你想到的是记忆周期。

994
00:45:32,930 --> 00:45:37,233
And indeed, there is a bad memory cycle here.
事实上，这里有一个糟糕的记忆周期。

995
00:45:37,301 --> 00:45:40,769
Because this closure, if you remember, this is happening
因为这个闭包，如果你还记得，这是发生的

996
00:45:40,838 --> 00:45:43,672
because I clicked on Saturn or Cassini or Earth.
因为我点击了土星或卡西尼或地球。

997
00:45:43,741 --> 00:45:46,943
And it went off, created an ImageViewController for me,
它关闭了，为我创建了一个ImageViewController，

998
00:45:47,011 --> 00:45:50,045
and that ImageView Controller is being put on screen and
这个imageviewcontroller被放到屏幕上

999
00:45:50,114 --> 00:45:52,481
it's going off to fetch this thing.
它要去取这个东西。

1000
00:45:52,550 --> 00:45:55,217
Now what if the user is like, I'm tired of waiting for
如果用户喜欢，我已经厌倦了等待

1001
00:45:55,286 --> 00:45:59,122
that Earth image, and they hit back, and go click on Saturn.
这是地球的图像，他们回击，然后点击土星。

1002
00:46:01,058 --> 00:46:01,990
When they hit back,
当他们反击,

1003
00:46:02,059 --> 00:46:05,161
what's supposed to happen to that ImageViewController?
ImageViewController会发生什么?

1004
00:46:07,798 --> 00:46:09,331
Anyone?
有人知道吗?

1005
00:46:09,400 --> 00:46:11,634
>> It's supposed to leave the heap, okay.

1006
00:46:11,703 --> 00:46:13,202
Because it was under navigation controllers on
因为它在导航控制器的下面

1007
00:46:13,271 --> 00:46:14,269
the top and I hit back.
上面和我打回去了。

1008
00:46:14,338 --> 00:46:17,807
Whoo, toss it out, but can it leave?
哇，把它扔出去，但它能离开吗?

1009
00:46:17,876 --> 00:46:20,809
No, because this closure is keeping it in
不，因为这个闭合是保持它的

1010
00:46:20,878 --> 00:46:24,847
the heap even though I don't want this any more.
即使我不再需要它了。

1011
00:46:24,915 --> 00:46:26,816
I went back because I'm now I'm going over to see
我回去是因为我现在要去看

1012
00:46:26,885 --> 00:46:27,950
Saturn instead of Earth, so
土星代替了地球，所以

1013
00:46:28,018 --> 00:46:30,118
I don't even want this Earth thing any more.
我再也不想要这个地球了。

1014
00:46:30,187 --> 00:46:32,154
So this is a bad kind of memory cycle cuz this is gonna
这是一种很糟糕的记忆周期

1015
00:46:32,222 --> 00:46:36,959
keep that ImageViewController in memory, so that's bad.
将ImageViewController保存在内存中，这样就不好了。

1016
00:46:37,028 --> 00:46:38,394
So this doesn't want to do this, so
所以这个不需要这么做

1017
00:46:38,463 --> 00:46:41,297
we're gonna fix this one using weak self.
我们要用弱的self来解决这个问题。

1018
00:46:42,566 --> 00:46:44,967
By the way, you know, I showed that you can do,
顺便说一下，你知道，我证明了你能做到，

1019
00:46:45,036 --> 00:46:46,768
weak weak self equals self.
虚弱的自我等同于自我。

1020
00:46:46,837 --> 00:46:49,472
But I'm a personally a fan of when you're using weak on
但当你用弱的时候，我是一个喜欢的人

1021
00:46:49,541 --> 00:46:50,806
self to just say weak self.
自我只是说脆弱的自己。

1022
00:46:50,875 --> 00:46:54,543
And all that does is inside of this closure, it make
它所做的一切都是在这个闭包内完成的

1023
00:46:54,612 --> 00:46:59,381
self be an optional version of itself, cuz it's weak now.
self是它自己的可选版本，因为它现在很弱。

1024
00:46:59,450 --> 00:47:02,518
So that means I have to do this because if I do finally
这意味着我必须这样做，因为如果我最后做了

1025
00:47:02,586 --> 00:47:05,921
come back from this closure and the person has hit back,
从这个封闭性回来，这个人回击了，

1026
00:47:05,989 --> 00:47:09,558
then the ImageViewController is gonna have left the heap.
然后ImageViewController会离开堆。

1027
00:47:09,627 --> 00:47:14,530
And so self with be nil, perfect, exactly what I want.
所以self是nil，完美，正是我想要的。

1028
00:47:14,599 --> 00:47:17,967
And if self is nil and I do this little optional chaining,
如果self是nil我做的是可选的链接，

1029
00:47:18,035 --> 00:47:20,135
then this whole line of code is not gonna happen,
然后这整行代码就不会发生了，

1030
00:47:20,204 --> 00:47:21,704
exactly what I want.
正是我想要的。

1031
00:47:21,772 --> 00:47:23,572
I do not want to create an image out of that
我不想创建一个图像

1032
00:47:23,641 --> 00:47:25,140
information that came back.
回来的信息。

1033
00:47:25,209 --> 00:47:26,908
Because that ImageViewController has
因为,ImageViewController

1034
00:47:26,977 --> 00:47:28,643
left the heap.
离开了堆。

1035
00:47:28,712 --> 00:47:31,613
So here I've broken this memory cycle beautifully here.
这里我把这个记忆周期写得很好。

1036
00:47:31,682 --> 00:47:33,715
Now, this does beg the question,
这就提出了一个问题，

1037
00:47:33,784 --> 00:47:36,319
surprised no one has raised their hand.
没有人举手表示惊讶。

1038
00:47:37,321 --> 00:47:38,988
How do I interrupt this closure?
如何中断这个关闭?

1039
00:47:39,056 --> 00:47:42,291
When I hit back, and that ImageViewController goes away,
当我点击返回时，ImageViewController消失了，

1040
00:47:42,360 --> 00:47:44,360
and I'm not interested in Earth any more,
我对地球不再感兴趣，

1041
00:47:44,429 --> 00:47:48,597
I'm still finishing the fetch, of Earth.
我还在完成我的取回。

1042
00:47:48,666 --> 00:47:51,833
And the answer is, you can't stop a closure
答案是，你不能停止关闭

1043
00:47:51,902 --> 00:47:54,703
that's been put on a queue, you cannot stop it.
它被放在一个队列上，你无法阻止它。

1044
00:47:54,772 --> 00:47:58,173
The only way it can stop is if it quits itself.
它能停止的唯一方法就是它自己退出。

1045
00:47:58,242 --> 00:48:00,843
So it could be looking at some global state to see if it's
因此，它可能正在研究一些全球国家，看看它是否存在

1046
00:48:00,911 --> 00:48:01,977
still relevant.
仍然相关。

1047
00:48:02,046 --> 00:48:03,879
And if it sees, I'm not relevant anymore,
如果它看到了，我就不再重要了，

1048
00:48:03,947 --> 00:48:05,081
it could return.
它可以返回。

1049
00:48:05,149 --> 00:48:07,215
So if it was doing some long running thing.
所以如果它在做一些长时间运行的事情。

1050
00:48:07,284 --> 00:48:08,417
Could do that.
可以这样做。

1051
00:48:08,486 --> 00:48:11,220
Or you can use something like NSUrlSession
或者你可以使用像NSUrlSession这样的东西

1052
00:48:11,289 --> 00:48:14,089
which is really smart about going and getting URLs.
这对于获取url非常聪明。

1053
00:48:14,158 --> 00:48:16,691
And it knows how to be interrupted and
它知道如何被打断

1054
00:48:16,760 --> 00:48:17,593
all the things like that.
诸如此类的东西。

1055
00:48:17,662 --> 00:48:20,062
So you could do something a little smarter than just this
所以你可以做一些比这更聪明的事情

1056
00:48:20,131 --> 00:48:21,096
one line of code.
一行代码。

1057
00:48:21,165 --> 00:48:24,300
But once this goes on the queue, it, it's gonna run.
但一旦它进入队列，它就会运行。

1058
00:48:26,403 --> 00:48:30,039
So it's up to it to decide not to run.
所以决定不跑是由它决定的。

1059
00:48:31,141 --> 00:48:33,008
So we fix that problem of it, but
所以我们解决了这个问题，但是

1060
00:48:33,077 --> 00:48:34,677
there's still more problems in here.
还有更多的问题。

1061
00:48:38,449 --> 00:48:41,283
What happens if this takes a minute,
如果这需要一分钟，会发生什么呢?

1062
00:48:41,352 --> 00:48:45,053
or ten minutes because slow network or whatever.
或者十分钟，因为慢速网络之类的。

1063
00:48:45,122 --> 00:48:47,823
And we get back and in the meantime,
我们回来了，同时，

1064
00:48:47,892 --> 00:48:51,527
someone called this on my ImageViewController.
有人在我的ImageViewController上调用了这个。

1065
00:48:51,595 --> 00:48:53,095
Now, our Cassini can't do that, but
现在，我们的卡西尼号不能这么做，但是

1066
00:48:53,164 --> 00:48:54,262
you could imagine an app that
你可以想象一个应用程序

1067
00:48:54,331 --> 00:48:56,632
would be showing something in the ImageViewController.
会在ImageViewController中显示一些东西。

1068
00:48:56,700 --> 00:48:58,433
And then you click on something in
然后你点击一些东西

1069
00:48:58,502 --> 00:49:02,004
the ImageViewController itself and it shows a different URL.
ImageViewController本身，它显示了一个不同的URL。

1070
00:49:03,206 --> 00:49:04,607
So someone calls this.
所以有人叫这个。

1071
00:49:04,675 --> 00:49:07,810
If I call this again, it's gonna go down here and
如果我再调用一次，它就会向下延伸

1072
00:49:07,878 --> 00:49:11,380
fetchImage again, which is here, and it's gonna dispatch
fetchImage，它在这里，它会发送

1073
00:49:11,448 --> 00:49:14,350
another closure off to go get the new image.
另一个封闭的地方去获取新的图像。

1074
00:49:16,187 --> 00:49:18,754
So now there's two closures out there fetching.
现在有两个闭包取回。

1075
00:49:18,823 --> 00:49:21,223
Now what happen when the first one comes back?
当第一个回来的时候，会发生什么呢?

1076
00:49:21,291 --> 00:49:22,458
What do I wanna do with that image?
我要怎么处理这个图像?

1077
00:49:23,961 --> 00:49:24,760
Ignore it.
忽略它。

1078
00:49:24,828 --> 00:49:27,095
Because the person said they want a new one.
因为那个人说他们想要一个新的。

1079
00:49:27,164 --> 00:49:30,566
So I better put something in here after this comes back to
所以我最好在后面加一些东西

1080
00:49:30,635 --> 00:49:33,902
see if I even care about that anymore, which is easy.
看看我是否还关心这个，这很简单。

1081
00:49:33,971 --> 00:49:40,910
I could just say for example image == self?.imageURL.
比如image = = self。imageurl。

1082
00:49:40,978 --> 00:49:45,080
So I'm sorry url == self?.imageURL.
抱歉，url = = self ?。imageurl。

1083
00:49:45,148 --> 00:49:47,916
So I'm just gonna look at this url, which is right here,
我要看看这个url，在这里，

1084
00:49:47,985 --> 00:49:49,819
got captured by this closure.
被这个闭包捕获。

1085
00:49:49,887 --> 00:49:52,454
This closure has captured this url.
这个闭包捕获了这个url。

1086
00:49:52,523 --> 00:49:56,825
I'm just gonna check if that url equals whatever
我将检查这个url是否等于什么

1087
00:49:56,894 --> 00:49:58,627
our current url is.
我们当前的url。

1088
00:49:58,696 --> 00:50:01,464
And if, if I'm not there, then it's okay.
如果我不在那里，那就没事了。

1089
00:50:01,532 --> 00:50:03,399
It's gonna be nil. So if I can equal nil, and
它会是零。如果我可以等于nil

1090
00:50:03,468 --> 00:50:04,533
there we go.
好了。

1091
00:50:04,601 --> 00:50:06,502
So here I just put a little test in there to make
我在这里做了一个小测试

1092
00:50:06,570 --> 00:50:08,771
sure that I'm still interested in that URL.
当然，我仍然对那个URL感兴趣。

1093
00:50:10,041 --> 00:50:11,674
Can everyone understand what's going on here,
大家都能理解这里发生了什么吗?

1094
00:50:11,742 --> 00:50:13,508
where url = imageURL,
url = imageURL,

1095
00:50:13,577 --> 00:50:18,247
this is a constant, a constant that got captured here.
这是一个常数，在这里得到了一个常数。

1096
00:50:18,315 --> 00:50:21,383
So i's always gonna be the URL that we went and
所以我一直是我们的URL

1097
00:50:21,452 --> 00:50:22,952
got the contents of.
得到的内容。

1098
00:50:24,355 --> 00:50:28,124
Ther's yet another problem here.
这里还有一个问题。

1099
00:50:28,192 --> 00:50:30,226
Can anyone tell me another problem with this code,
谁能告诉我这个代码的另一个问题，

1100
00:50:30,294 --> 00:50:31,127
obvious problem?
明显的问题吗?

1101
00:50:34,265 --> 00:50:35,164
I just showed you in the slides.
我刚刚给你们看了幻灯片。

1102
00:50:35,232 --> 00:50:37,232
This right here,
这里,

1103
00:50:37,301 --> 00:50:43,139
self?.image is gonna call this code down here.
自我?。图像会调用下面这里的代码。

1104
00:50:44,274 --> 00:50:46,175
That's gonna do all kinds of UI stuff.
它会做各种UI的事情。

1105
00:50:47,578 --> 00:50:49,344
It's gonna set the scrollView's content size,
它会设置scrollView的内容大小，

1106
00:50:49,413 --> 00:50:51,480
size of the imageView, size of the imageView's image.
imageView的大小，imageView的图像的大小。

1107
00:50:51,548 --> 00:50:53,481
This is all UI stuff.
这是所有UI的东西。

1108
00:50:53,550 --> 00:50:55,317
Where does that need to happen?
这种情况需要发生在哪里?

1109
00:50:55,386 --> 00:50:56,185
On the main queue.
在主队列。

1110
00:50:57,922 --> 00:51:00,422
And is this on the main queue right here?
这个在主队列上吗?

1111
00:51:00,490 --> 00:51:05,027
No, this is on this queue over here, this global queue,
不，这是在这个队列上，这个全局队列，

1112
00:51:05,096 --> 00:51:07,495
userInitiated global queue.
userInitiated全球队列。

1113
00:51:07,564 --> 00:51:10,031
That's where this is all happening, so
这就是一切发生的地方

1114
00:51:10,100 --> 00:51:12,000
that's not the main queue.
那不是主要的队列。

1115
00:51:12,069 --> 00:51:13,302
So that is illegal.
这是非法的。

1116
00:51:13,371 --> 00:51:15,671
That's gonna cause all kinds of weird behavior in your app
这将会在你的应用中造成各种奇怪的行为

1117
00:51:15,739 --> 00:51:16,304
if you do that.
如果你这样做。

1118
00:51:16,373 --> 00:51:19,275
But easily fitched, fixed,
但容易惠誉、固定

1119
00:51:19,343 --> 00:51:24,479
we'll just ditch DispatchQueue.main.async and
我们只要沟DispatchQueue.main。异步和

1120
00:51:24,548 --> 00:51:27,850
put this back on the main queue.
把这个放回主队列。

1121
00:51:30,555 --> 00:51:35,824
Now what's really cool about this syntax,
这个语法很酷，

1122
00:51:35,893 --> 00:51:40,896
I guess you would say, of doing these things is
我猜你会说，做这些事情

1123
00:51:40,965 --> 00:51:46,502
it looks very much logically like normal code.
它在逻辑上看起来很像普通代码。

1124
00:51:46,570 --> 00:51:49,705
Right, it's almost just like if thens or whatever.
对，几乎就像这样。

1125
00:51:49,774 --> 00:51:52,675
However, you do have to understand that when you do
然而，当你这样做的时候，你必须明白这一点

1126
00:51:52,743 --> 00:51:55,577
a dispatch like this, that's gonna happen asynchronously.
这样的调度，是异步发生的。

1127
00:51:55,646 --> 00:51:58,113
It's gonna happen in a different time
它会在不同的时间发生

1128
00:51:58,182 --> 00:52:00,482
than the rest of this code.
比剩下的代码要多。

1129
00:52:00,551 --> 00:52:01,584
Same thing with this one.
这个也一样。

1130
00:52:01,652 --> 00:52:02,351
This is gonna happen a little different time.
这将会发生一些不同的时间。

1131
00:52:02,419 --> 00:52:03,319
Now of course, things
当然,事情

1132
00:52:03,387 --> 00:52:05,720
that you put on the main queue tend to run pretty quick.
你放在主队列上的速度会很快。

1133
00:52:05,789 --> 00:52:10,992
But even so, you just have to be cognizant of the fact that
但即便如此，你还是要认识到这一点

1134
00:52:11,061 --> 00:52:13,495
even though it looks like this line of code is gonna happen,
即使看起来这一行代码会发生，

1135
00:52:13,564 --> 00:52:15,497
then this line, then this line, then this line,
然后这条线，然后这条线，这条线，

1136
00:52:15,566 --> 00:52:16,798
then this line, it's not gonna happen.
然后这条线，它不会发生。

1137
00:52:16,867 --> 00:52:18,400
It's gonna happen more like the slides, right,
它会更像幻灯片，对吧，

1138
00:52:18,468 --> 00:52:21,270
where things happen a little bit out of order there
哪里发生了一点变化

1139
00:52:21,338 --> 00:52:23,205
because things are happening asynchronously.
因为事情是异步发生的。

1140
00:52:23,274 --> 00:52:25,474
Async means asynchronously, out of time,
异步意味着异步，超时，

1141
00:52:25,543 --> 00:52:30,078
right, different, not lined up in time.
对，不同，没有及时排队。

1142
00:52:30,147 --> 00:52:30,980
Everybody got that?
大家都明白了吗?

1143
00:52:32,917 --> 00:52:34,316
Let's see if that fixes all our problems.
让我们看看这是否解决了我们所有的问题。

1144
00:52:38,688 --> 00:52:41,189
So remember, here we have no image.
记住，这里没有图像。

1145
00:52:41,258 --> 00:52:43,692
By the way, this is a terrible problem right here where this
顺便说一下，这是一个很严重的问题

1146
00:52:43,760 --> 00:52:45,394
comes up blank.
出现空白。

1147
00:52:45,462 --> 00:52:47,763
And I actually mentioned last week that I was gonna
上周我还提到了

1148
00:52:47,832 --> 00:52:49,765
make it extra credit for you to figure out how to not
让它额外的学分，让你知道如何不

1149
00:52:49,833 --> 00:52:51,666
make this blank in your calculator, have it
在你的计算器上做这个空白，有它

1150
00:52:51,735 --> 00:52:54,069
come up with the calculator instead of an empty graph.
用计算器来代替一个空的图。

1151
00:52:54,138 --> 00:52:56,004
But I decided instead I'm gonna show you how to
但我还是决定告诉你怎么做

1152
00:52:56,073 --> 00:52:56,838
do it today.
今天做。

1153
00:52:56,907 --> 00:52:57,772
That's why I didn't
这就是为什么我没有

1154
00:52:57,841 --> 00:52:59,574
make it extra credit in the assignment.
在作业中增加学分。

1155
00:52:59,643 --> 00:53:01,576
But anyway, so here's the detail.
但无论如何，这是细节。

1156
00:53:01,645 --> 00:53:02,711
We haven't picked an image so it's blank.
我们没有选图像，所以它是空的。

1157
00:53:02,779 --> 00:53:04,413
Now I'm gonna go back.
现在我要回去了。

1158
00:53:04,481 --> 00:53:05,314
Here's our Cassini viewController.
这是我们卡西尼viewController。

1159
00:53:05,382 --> 00:53:08,283
Now I'm gonna pick Earth, and it's loading up, but
现在我要选择地球，它正在加载，但是

1160
00:53:08,352 --> 00:53:10,085
I changed my mind.
我改变主意了。

1161
00:53:10,154 --> 00:53:12,187
Saturn, changed my mind.
土星、改变了我的想法。

1162
00:53:12,256 --> 00:53:14,823
I can change my mind now because
我现在可以改变主意了

1163
00:53:14,892 --> 00:53:16,892
those things are being fetched in some other thread.
这些东西在其他线程中被获取。

1164
00:53:16,961 --> 00:53:20,328
Now if I wait long enough, they get it and return it.
如果我等得够久，他们就会得到并归还。

1165
00:53:20,397 --> 00:53:21,062
So here I am.
所以我在这里。

1166
00:53:21,131 --> 00:53:25,300
I have Cassini here.
我在这里有卡西尼。

1167
00:53:25,369 --> 00:53:28,871
If I go back and hit Earth, again, I give up.
如果我回到地球，再次，我放弃。

1168
00:53:28,939 --> 00:53:34,476
Saturn, I'll wait, and we'll see if we get Saturn.
土星，我等一下，看看我们能不能得到土星。

1169
00:53:34,545 --> 00:53:37,179
By the way, Saturn, this is kind of a weird, I don't think
顺便说一下，土星，这有点奇怪，我不认为

1170
00:53:37,248 --> 00:53:39,914
Cassini took this photo here, this picture of the people.
卡西尼拍了这张照片，照片上的人。

1171
00:53:39,983 --> 00:53:43,986
But wait a minute, look at that, there's Saturn.
但是等一下，看看这个，土星。

1172
00:53:47,691 --> 00:53:50,225
One thing about this app, though, that's kind of bad
关于这个应用，有一点很糟糕

1173
00:53:50,294 --> 00:53:53,429
is I click on this and I get this white screen.
我点击这个，得到这个白色的屏幕。

1174
00:53:53,497 --> 00:53:55,998
Especially on a big image like this one we get this white
尤其是像这样的大图像，我们得到了白色

1175
00:53:56,066 --> 00:53:57,866
screen, it's white screen, it's white screen.
屏幕，它是白色的屏幕，白色的屏幕。

1176
00:53:57,935 --> 00:53:59,334
It's like what's happening in this app?
这就像在这个应用程序里发生了什么?

1177
00:53:59,403 --> 00:54:00,970
I don't even understand what's going on.
我甚至不知道发生了什么。

1178
00:54:02,740 --> 00:54:04,606
It would be really cool if I could give the user some
如果我能给用户一些，那就太酷了

1179
00:54:04,675 --> 00:54:07,942
feedback about what's happening.
反馈关于发生了什么。

1180
00:54:08,011 --> 00:54:11,479
Now this feedback might be something that says loading
这个反馈可能是加载

1181
00:54:11,548 --> 00:54:13,248
dot dot dot dot or something.
点·点或其他点。

1182
00:54:13,316 --> 00:54:15,350
But a really cool feedback when you're waiting for
但当你在等待的时候，会有一个很酷的反馈

1183
00:54:15,419 --> 00:54:17,185
something is a spinning, a little spinner.
有些东西是旋转的，有点旋转。

1184
00:54:17,254 --> 00:54:19,054
Have you seen those spinners?
你见过那些纺纱工吗?

1185
00:54:19,122 --> 00:54:21,289
A lot of apps have this where there's a little spinner.
很多应用都有一个小转轮。

1186
00:54:21,358 --> 00:54:22,924
So let's add a spinner to our app so
让我们在app中添加一个spinner

1187
00:54:22,993 --> 00:54:26,361
that when we click here, it's a little thing spinning
当我们点击这里，它是一个旋转的小东西

1188
00:54:26,430 --> 00:54:29,531
until an image appears, and then it goes away.
直到图像出现，然后它就消失了。

1189
00:54:29,600 --> 00:54:32,667
That turns out to be incredible easy to do,
这很容易做到，

1190
00:54:32,736 --> 00:54:35,470
because that's a common thing to want to do is to give
因为这是一件很常见的事情

1191
00:54:35,539 --> 00:54:36,304
the user feedback.
用户反馈。

1192
00:54:36,373 --> 00:54:38,573
Yes, I heard you and I'm working on it, but
是的，我听到了，我正在努力

1193
00:54:38,642 --> 00:54:39,475
I don't have it yet.
我还没有。

1194
00:54:40,611 --> 00:54:41,142
How do we do that?
怎么做呢?

1195
00:54:41,211 --> 00:54:43,845
Let's go back to our storyboard.
让我们回到故事板。

1196
00:54:43,914 --> 00:54:46,881
And this is where we're gonna wanna do that is on this
这就是我们要做的

1197
00:54:46,950 --> 00:54:48,617
viewController right here.
viewController。

1198
00:54:48,686 --> 00:54:51,619
This is where our scrollView is with our little
这是我们的滚动视图与我们的小的地方

1199
00:54:51,688 --> 00:54:53,021
imageView in there.
imageView。

1200
00:54:53,090 --> 00:54:55,457
And what we can do is just go over over here and
我们可以做的就是把它放在这里

1201
00:54:55,526 --> 00:54:56,191
get an object.
得到一个对象。

1202
00:54:56,260 --> 00:54:58,594
It's called an Activity Indicator View.
它被称为活动指示器视图。

1203
00:54:58,662 --> 00:55:01,797
Here it is right here, view an Activity Indicator View.
在这里，查看活动指示器视图。

1204
00:55:01,866 --> 00:55:05,333
And I'm just gonna drag this into my UI,
我把这个拖拽到UI中，

1205
00:55:05,402 --> 00:55:07,235
right in the middle.
在中间。

1206
00:55:07,304 --> 00:55:10,305
Now what I just did there was a very bad thing.
现在我所做的是一件非常糟糕的事情。

1207
00:55:10,373 --> 00:55:14,476
It looked fine, but it's very bad.
看起来很好，但很糟糕。

1208
00:55:14,545 --> 00:55:16,745
And it's a little subtle as to why it's bad, so
这是很微妙的，为什么它是坏的，所以

1209
00:55:16,814 --> 00:55:19,447
let's investigate this one in depth why this was bad that
让我们深入调查一下为什么这很糟糕

1210
00:55:19,516 --> 00:55:20,682
I dragged that in there.
我把它拖进去了。

1211
00:55:20,751 --> 00:55:23,519
And the way we gonna see that it's bad is by bringing
我们可以通过引入来发现它是不好的

1212
00:55:23,587 --> 00:55:27,121
out for the first time this document outline.
这是第一次，这个文档大纲。

1213
00:55:27,190 --> 00:55:29,725
This little thing in the lower left which I told you we were
在左下角的这个小东西，我告诉过你们

1214
00:55:29,793 --> 00:55:32,227
gonna talk about and here we are talking about it.
我们来谈谈这个问题。

1215
00:55:32,296 --> 00:55:35,497
This is everything that's in our storyboard in
这是故事板中的所有内容

1216
00:55:35,566 --> 00:55:39,567
outline form, in kind of text form.
提纲形式，以文本形式。

1217
00:55:39,636 --> 00:55:41,303
And when we do this,
当我们这样做的时候，

1218
00:55:41,371 --> 00:55:44,172
we look down here at this Activity Indicator View.
我们向下看这个活动指示器视图。

1219
00:55:44,241 --> 00:55:45,507
By the way, if you select something here,
顺便说一下，如果你选择了一些东西，

1220
00:55:45,576 --> 00:55:47,509
it'll select it here and vice versa.
它会在这里选择，反之亦然。

1221
00:55:47,578 --> 00:55:50,111
So this is selected, so it's showing it here.
这是选择的，所以它在这里显示。

1222
00:55:50,180 --> 00:55:53,114
And you see how these things, this is all the views, this is
你可以看到这些，这是所有的视图，这是

1223
00:55:53,183 --> 00:55:57,452
the top level view, that's the view var in the controller.
顶层视图，这是控制器中的视图var。

1224
00:55:57,521 --> 00:56:01,022
Then here is that scrollView that we made, and
这里是我们做的scrollView

1225
00:56:01,091 --> 00:56:02,624
then here is the indicator view.
然后这里是指示器视图。

1226
00:56:02,693 --> 00:56:04,460
We see how these are indented,
我们看到这些是如何缩进的，

1227
00:56:04,528 --> 00:56:06,295
that means they are subviews of each other.
这意味着它们是彼此的子视图。

1228
00:56:07,731 --> 00:56:10,499
So we made the gray activity indicator
所以我们做了灰色活动指示器

1229
00:56:10,567 --> 00:56:14,936
a subview of our Scroll View, we do not want that here.
我们的滚动视图的子视图，我们不希望在这里。

1230
00:56:15,005 --> 00:56:17,305
We want our Scroll View scrolling around our image,
我们希望滚动视图在我们的图像周围滚动，

1231
00:56:17,374 --> 00:56:20,075
we don't want it scrolling our indicator around.
我们不希望它滚动我们的指示器。

1232
00:56:20,143 --> 00:56:21,777
We want the indicator to stay in the middle.
我们希望指标保持在中间。

1233
00:56:23,847 --> 00:56:27,649
We don't want it to be a subview of Scroll View,
我们不希望它是滚动视图的子视图，

1234
00:56:27,718 --> 00:56:29,351
we want it to be a sibling.
我们希望它是一个兄弟姐妹。

1235
00:56:29,420 --> 00:56:31,352
We want them both to be at the same level,
我们希望它们都处于相同的水平，

1236
00:56:31,421 --> 00:56:32,954
one in front of the other.
一个在另一个前面。

1237
00:56:33,023 --> 00:56:36,291
And we can do that just by picking this up right here,
我们可以这样做，

1238
00:56:36,360 --> 00:56:39,227
and moving it to the same level as Scroll View.
并将其移动到与滚动视图相同的级别。

1239
00:56:39,296 --> 00:56:42,331
Now that's very hard to do in here because any time you try
这在这里很难，因为任何时候都可以

1240
00:56:42,399 --> 00:56:45,333
to pick this up and move it, it's always gonna wanna try
把它捡起来，然后移动它，它总是想尝试

1241
00:56:45,402 --> 00:56:48,303
and drop into a subview or a superview of something, so
然后进入子视图或超视图

1242
00:56:48,372 --> 00:56:50,372
it's always gonna grab on to it.
它总是会抓住它。

1243
00:56:50,440 --> 00:56:52,540
But in this document outline it's very easy.
但在这个文档大纲中，它很简单。

1244
00:56:52,609 --> 00:56:56,377
You can just pick it up and move it there.
你可以把它捡起来，然后移动它。

1245
00:56:56,446 --> 00:56:59,948
So when you do these activity indicator views in your future
所以当你在未来做这些活动指标的时候

1246
00:57:00,017 --> 00:57:01,883
apps and in your final project,
应用程序和最终项目，

1247
00:57:01,952 --> 00:57:03,952
make sure you don't accidentally make it a sub
确保你不会不小心把它变成潜艇

1248
00:57:04,021 --> 00:57:05,988
view of something that you drag it onto.
看你把它拖到的东西。

1249
00:57:06,056 --> 00:57:07,088
If it what you intend.
如果你想要的话。

1250
00:57:07,157 --> 00:57:08,990
Notice also the order matters here.
注意这里的顺序很重要。

1251
00:57:09,059 --> 00:57:11,159
This is the sub views in their, in order, and
这是它们的子视图，按顺序排列

1252
00:57:11,227 --> 00:57:13,561
remember that sub view sub zero is in the back, and
记住子视图下标0在后面

1253
00:57:13,630 --> 00:57:15,296
all the other ones are in the front.
其他的都在前面。

1254
00:57:15,365 --> 00:57:17,466
So we obviously want this activity indicator to
我们显然想要这个活动指示器

1255
00:57:17,535 --> 00:57:19,535
be in the front, in front of everything.
在前面，在所有的前面。

1256
00:57:21,005 --> 00:57:22,437
All right, so that was that.
好了，就是这样。

1257
00:57:22,506 --> 00:57:26,875
Now what we wanna do is we want to wire this activity
现在我们要做的是把这个活动连接起来

1258
00:57:26,944 --> 00:57:29,845
indicator right here up to our code.
在这里显示我们的代码。

1259
00:57:29,913 --> 00:57:31,446
Why? Because we have to tell it to
为什么?因为我们必须告诉它

1260
00:57:31,515 --> 00:57:32,214
start running.
开始运行。

1261
00:57:32,282 --> 00:57:33,648
Or actually even before we do that,
甚至在我们开始之前，

1262
00:57:33,717 --> 00:57:35,150
let's configure it a little bit.
我们来配置一下。

1263
00:57:35,219 --> 00:57:37,986
We've got it right here, we can inspect it.
我们把它放在这里，我们可以检查它。

1264
00:57:38,054 --> 00:57:40,689
Here's the inspector of it, see Activity Indicator View.
这是它的检查器，看活动指示器视图。

1265
00:57:40,758 --> 00:57:43,558
It looks kind of small to me for this big view.
在我看来，这一大图看起来有点小。

1266
00:57:43,627 --> 00:57:45,259
So I'm gonna switch to a different kind
所以我要换一种

1267
00:57:45,328 --> 00:57:47,496
which is the Large White.
这是白色的。

1268
00:57:47,565 --> 00:57:49,430
But I don't actually want it to be white
但我并不希望它是白色的

1269
00:57:49,499 --> 00:57:50,799
because the background is white.
因为背景是白色的。

1270
00:57:50,868 --> 00:57:54,502
So I'm gonna change its color to be, Iet's say blue.
我要改变它的颜色，设为蓝色。

1271
00:57:54,571 --> 00:57:56,238
So this can be large and blue.
所以这个可以是大而蓝色。

1272
00:57:56,306 --> 00:57:59,708
Also, every time I stop animating it, I want it to
而且，每次我停止动画的时候，我都想要它

1273
00:57:59,776 --> 00:58:02,143
hide itself, because I don't want it to be stopped
躲起来，因为我不想让它停下来

1274
00:58:02,212 --> 00:58:03,812
spinning, sitting there showing.
旋转,坐在那里显示。

1275
00:58:03,881 --> 00:58:06,448
Any time it stops I want it to disappear.
任何时候它停止我想要它消失。

1276
00:58:06,517 --> 00:58:07,916
Then if I start it again, it'll reappear.
如果我重新开始，它就会重新出现。

1277
00:58:07,985 --> 00:58:09,284
So that's what this button is.
这就是这个按钮。

1278
00:58:09,353 --> 00:58:12,053
This here animating would mean that it would come up
这里的动画意味着它会上升

1279
00:58:12,122 --> 00:58:12,921
animating, but
动画,但

1280
00:58:12,990 --> 00:58:16,124
I'm gonna turn it on any time I go do a background fetch.
我要在任何时候把它打开，做后台取回。

1281
00:58:16,193 --> 00:58:19,727
So I don't want it to come up with this view animating
所以我不希望它出现在这个视图中

1282
00:58:19,796 --> 00:58:20,695
already.
了。

1283
00:58:20,764 --> 00:58:21,797
That's what those all mean.
这就是它们的意思。

1284
00:58:22,999 --> 00:58:24,532
To turn it on I need to talk to it, so
我需要和它谈谈，所以

1285
00:58:24,601 --> 00:58:26,301
I need an outlet to it.
我需要一个出口。

1286
00:58:26,370 --> 00:58:29,304
So I'm just gonna control drag from it, just like any other
所以我只需要control拖动，就像其他的一样

1287
00:58:29,373 --> 00:58:31,706
outlet we would make to a button or whatever.
我们会对一个按钮或其他东西进行输出。

1288
00:58:31,775 --> 00:58:32,674
Here it is.
在这儿。

1289
00:58:32,743 --> 00:58:35,344
I'm gonna call it a spinner, that's what I like to call
我把它命名为spinner，这就是我喜欢调用的

1290
00:58:35,412 --> 00:58:37,513
my UI activity indicators, spinner.
我的UI活动指示器，spinner。

1291
00:58:38,915 --> 00:58:40,982
There's my spinner outlet right there.
这是我的spinner outlet。

1292
00:58:41,051 --> 00:58:44,252
All I need to do here is turn this thing on whenever I
我在这里要做的就是把这个东西打开

1293
00:58:44,321 --> 00:58:48,056
go off to another thread to do something.
到另一个线程去做某事。

1294
00:58:48,125 --> 00:58:50,992
So here's where I go off to another thread to do
这是我到另一个线程去做的地方

1295
00:58:51,060 --> 00:58:55,497
something, so I'm just gonna say spinner.startAnimating.
有些东西，所以我要说的是spinner.startAnimating。

1296
00:58:55,565 --> 00:58:56,765
And that's gonna start it spinning.
然后开始旋转。

1297
00:58:56,833 --> 00:58:58,666
It's gonna unhide it, if it was hidden, and
如果它被隐藏了，它就会把它隐藏起来

1298
00:58:58,735 --> 00:58:59,635
start it spinning.
启动它旋转。

1299
00:59:00,904 --> 00:59:01,470
Question?
问题吗?

1300
00:59:04,708 --> 00:59:07,943
>> Animated just make thatlittle blue thing go round

1301
00:59:08,012 --> 00:59:09,545
It just makes it spin just like all spinners.
它就像所有的纺纱器一样旋转。

1302
00:59:09,546 --> 00:59:11,079
and round.
和圆。

1303
00:59:12,449 --> 00:59:15,884
>> Yeah, well, when I inspected it over here.

1304
00:59:15,953 --> 00:59:18,987
And I did, and I didn't click this button Animating,
我没有点击这个按钮动画，

1305
00:59:19,056 --> 00:59:21,823
that just means it doesn't start out animating.
这意味着它不会开始动画。

1306
00:59:21,892 --> 00:59:25,894
I have to start it in code, that's what this means.
我必须从代码开始，这就是它的意思。

1307
00:59:25,963 --> 00:59:26,794
If I turn this on,
打开这个，

1308
00:59:26,863 --> 00:59:29,030
then as soon as my app came up it would be animating,
一旦我的应用程序出现，它就会是动画，

1309
00:59:29,099 --> 00:59:29,831
which I don't want that.
我不想那样。

1310
00:59:29,899 --> 00:59:32,700
I don't want it to start animating until I do this
我不想让它开始动画，直到我这么做

1311
00:59:32,769 --> 00:59:34,636
dispatch onto some other queue,
分派到其他队列，

1312
00:59:34,705 --> 00:59:37,605
that's when I want it to start animating.
那是我想让它开始动画的时候。

1313
00:59:37,674 --> 00:59:40,975
Now, you might imagine that the place to stop animating it
现在，你可以想象这个地方停止动画

1314
00:59:41,044 --> 00:59:42,644
might be right here.
可能是在这里。

1315
00:59:42,713 --> 00:59:47,148
spinner.stopAnimating, but and this would kinda make sense.
微调控制项。停止动画，但这是有意义的。

1316
00:59:47,217 --> 00:59:50,419
Because you know, I went off to go get this image and
因为你知道，我去取了这个图像

1317
00:59:50,487 --> 00:59:52,620
it came back, and I set the image.
它回来了，我设置了图像。

1318
00:59:52,689 --> 00:59:54,923
Now I can stop animating.
现在我可以停止动画了。

1319
00:59:54,992 --> 00:59:57,492
But actually I don't wanna do that here.
但实际上我不想在这里做。

1320
00:59:57,561 --> 01:00:00,895
And that is because I wanna stop animating
那是因为我想停止动画

1321
01:00:00,964 --> 01:00:02,797
anytime the image is set.
任何时候图像都设置好了。

1322
01:00:02,866 --> 01:00:05,466
If an image is set in my image view controller,
如果图像在图像视图控制器中设置，

1323
01:00:05,535 --> 01:00:06,901
I wanna stop animating.
我想停止动画。

1324
01:00:06,970 --> 01:00:08,770
I don't care how it got set.
我不在乎它是怎么设置的。

1325
01:00:08,839 --> 01:00:11,306
If it got set from my thing coming back, that's good.
如果它从我回来的东西中得到了集合，那很好。

1326
01:00:11,375 --> 01:00:13,174
If someone set it by saying,
如果有人说，

1327
01:00:13,243 --> 01:00:17,379
image URL equals like a local URL, I wanna stop then too.
图像URL等于本地URL，我也想停止。

1328
01:00:17,448 --> 01:00:19,180
So I'm gonna put it down here an image.
我要把它放在这里。

1329
01:00:19,249 --> 01:00:20,615
Here's where we set our image.
这是我们设置图像的地方。

1330
01:00:20,684 --> 01:00:22,450
This is the set part of it.
这是它的集合。

1331
01:00:22,519 --> 01:00:26,421
And I'm just gonna say down here, stopAnimating.
我要在这里写上，stopAnimating。

1332
01:00:26,489 --> 01:00:29,091
So, any time my image is set I'm gonna stop animating cuz
所以，每当我的图像被设置时，我就停止动画

1333
01:00:29,159 --> 01:00:31,059
it would make no sense if the image was there and
如果图像在那里，那就没有意义了

1334
01:00:31,128 --> 01:00:32,727
the thing was animating.
的动画。

1335
01:00:32,796 --> 01:00:33,895
That would never make sense for
这是没有意义的

1336
01:00:33,964 --> 01:00:36,064
an image to be showing, and it to animate at the same time.
一个要显示的图像，同时它也可以动画。

1337
01:00:36,133 --> 01:00:37,365
Because animating
因为动画

1338
01:00:37,434 --> 01:00:39,034
this thing means I'm waiting for an image.
这意味着我在等待一个图像。

1339
01:00:40,804 --> 01:00:41,803
Got it?
明白了吗?

1340
01:00:41,871 --> 01:00:44,105
Touch it, that's all you have to do to do the spinners,
触摸它，这就是你要做的所有的旋转器，

1341
01:00:44,174 --> 01:00:45,339
they're super, super simple.
他们是超级,超级简单。

1342
01:00:45,408 --> 01:00:48,342
They only makes sense when you're doing things in other
当你在做其他事情的时候，它们才有意义

1343
01:00:48,411 --> 01:00:50,178
threads with the spinner.
线程与转轮。

1344
01:00:50,247 --> 01:00:53,614
Cuz if you're me, if you're not doing something in another
如果你是我，如果你不在另一个地方做什么

1345
01:00:53,683 --> 01:00:55,316
thread then why would you?
那你为什么要这么做?

1346
01:00:55,385 --> 01:00:56,117
See, now look.
看,现在看来。

1347
01:00:56,186 --> 01:00:58,586
This came up, it's blank but it's not spinning
它是空的，但不是旋转的

1348
01:00:58,655 --> 01:01:00,422
because I haven't asked for anything yet.
因为我还没有要求什么。

1349
01:01:00,490 --> 01:01:03,224
So I'll go back here and I'll ask for Earth.
所以我要回到这里，我要求地球。

1350
01:01:03,293 --> 01:01:05,894
It says nil while doing Optional value.
它在做可选值时表示nil。

1351
01:01:05,962 --> 01:01:06,627
That's not bad.
这是不坏。

1352
01:01:06,696 --> 01:01:08,896
What happened here?
这里发生了什么?

1353
01:01:08,965 --> 01:01:11,299
Ahh, yeah, good one.
啊,是的,不错。

1354
01:01:11,368 --> 01:01:12,433
All right, so this crashed.
好了，这就崩溃了。

1355
01:01:12,502 --> 01:01:13,634
Why did this crash?
为什么这个崩溃?

1356
01:01:13,703 --> 01:01:15,770
Why did we have a problem here?
为什么会有问题呢?

1357
01:01:15,839 --> 01:01:20,809
And the answer here is that when I set
答案是，当我设置的时候

1358
01:01:20,878 --> 01:01:25,747
this image I was in prepare.
这张照片是我准备的。

1359
01:01:28,018 --> 01:01:31,486
And when I'm in prepare, my outlets are not set.
当我在准备的时候，我的销售点没有设置。

1360
01:01:32,923 --> 01:01:36,792
So I need to optional chain that right there.
所以我需要可选的链。

1361
01:01:36,860 --> 01:01:39,393
So this crash, you'll get it yourself a lot,
所以这次碰撞，你会得到很多，

1362
01:01:39,462 --> 01:01:42,930
where you prepare something and crash.
在你准备东西和碰撞的地方。

1363
01:01:42,999 --> 01:01:45,833
It crashes during prepare because you try to set
它在准备过程中崩溃，因为你试图设置

1364
01:01:45,902 --> 01:01:46,568
your outlets.
你的商店。

1365
01:01:46,637 --> 01:01:49,537
Now, this is fine for the spinner not to be set, and
现在，这对于spinner没有设置，还有

1366
01:01:49,606 --> 01:01:53,007
I'm setting the image because I never would have started it
我在设置图像，因为我永远不会启动它

1367
01:01:53,076 --> 01:01:54,609
in this condition anyway.
在这种情况下。

1368
01:01:54,677 --> 01:01:59,247
So all is well just to ignore setting the image when I'm
所以，当我在做的时候，一切都很好

1369
01:01:59,315 --> 01:02:00,382
preparing.
准备。

1370
01:02:01,618 --> 01:02:03,385
Everybody got that one?
大家都明白了吗?

1371
01:02:03,453 --> 01:02:07,389
You all have that, hundreds of times in your iOS careers
在你的iOS职业生涯中，你有几百次这样的情况

1372
01:02:07,457 --> 01:02:10,458
where you have some code that you'll prepare,
你需要准备一些代码，

1373
01:02:10,527 --> 01:02:12,393
execute that uses an outlet.
执行使用一个outlet。

1374
01:02:12,462 --> 01:02:14,162
All right, so let's go back now, we hit Earth.
好了，现在我们回到地球。

1375
01:02:14,231 --> 01:02:15,263
See it's spinning.
看到它的旋转。

1376
01:02:15,332 --> 01:02:18,833
As soon as the image gets put in here, it stops spinning,
一旦图像放到这里，它就停止旋转，

1377
01:02:18,901 --> 01:02:20,401
all right, it's gone.
好了,走了。

1378
01:02:20,470 --> 01:02:22,537
Okay, back here, spinning.
好了,回到这里,旋转。

1379
01:02:22,606 --> 01:02:23,605
Yeah, we don't want it.
是的，我们不想要。

1380
01:02:23,674 --> 01:02:27,642
Let's go here, skip it here.
我们到这里，跳过这里。

1381
01:02:32,449 --> 01:02:35,083
Now, the last thing I wanna do is this thing where,
现在，我想做的最后一件事是，

1382
01:02:35,151 --> 01:02:37,586
when the thing starts up it starts up blank.
当事情开始的时候，它就开始空白了。

1383
01:02:41,157 --> 01:02:44,058
All right, it starts blank because it's on the detail.
它开始是空的，因为它在细节上。

1384
01:02:44,127 --> 01:02:45,526
And I don't want it on the detail
我不想详细说明

1385
01:02:45,595 --> 01:02:48,230
when there's no image URL there.
当没有图像URL的时候。

1386
01:02:48,298 --> 01:02:52,133
I want it to start up here if, when I first start.
我想让它从这里开始，如果，当我第一次开始。

1387
01:02:52,202 --> 01:02:53,368
All right, so how do I do that?
好吧，那我该怎么做呢?

1388
01:02:53,437 --> 01:02:57,772
I'm gonna do that using the split view controllers.
我要用分屏视图控制器。

1389
01:02:57,841 --> 01:03:00,575
If we go look at our storyboard here.
如果我们看一下故事板。

1390
01:03:00,644 --> 01:03:03,311
I'm gonna use the delegate of this split
我要用这个分叉的委托

1391
01:03:03,380 --> 01:03:05,613
view controller right here.
视图控制器。

1392
01:03:05,682 --> 01:03:09,784
Because this split view controller asks the delegate,
因为分屏视图控制器要求委托，

1393
01:03:09,853 --> 01:03:14,890
would you like to do the job of collapsing the primary
你想做的是在初选中崩溃吗

1394
01:03:14,958 --> 01:03:16,524
view, the secondary view controller rather,
视图，二级视图控制器，

1395
01:03:16,593 --> 01:03:19,694
you know the detail, on top of the master?
你知道细节，在大师的上面?

1396
01:03:19,762 --> 01:03:22,764
Okay, so it's gonna give me the opportunity to do that.
它会给我机会来做这个。

1397
01:03:22,833 --> 01:03:26,868
And what I'm gonna do is, if there's no image URL in there,
我要做的是，如果没有图像URL，

1398
01:03:26,937 --> 01:03:30,104
I'm gonna say I did it but I'm not gonna do anything.
我说我做到了，但我什么也不想做。

1399
01:03:30,173 --> 01:03:32,774
And that's gonna cause it not to collapse the detail
这样就不会破坏细节

1400
01:03:32,842 --> 01:03:33,742
on top of the master.
在大师之上。

1401
01:03:35,245 --> 01:03:38,613
Now, I need to have one of my view controllers be the split
现在，我需要有一个视图控制器

1402
01:03:38,682 --> 01:03:40,482
view controller's delegate.
视图控制器的委托。

1403
01:03:40,550 --> 01:03:43,684
And I can't really have it be this one right here
我不能把它变成这个

1404
01:03:43,753 --> 01:03:45,720
because this one comes and goes.
因为这一个来了又去。

1405
01:03:45,788 --> 01:03:46,921
This is the Image View Controller. It gets created
这是图像视图控制器。它被创造的

1406
01:03:46,990 --> 01:03:50,024
when it's segued to and when you go away, it stops.
当它被segue到，当你离开时，它就停止了。

1407
01:03:50,093 --> 01:03:51,359
You go throw it out of the heap.
你把它扔出堆。

1408
01:03:51,428 --> 01:03:54,662
So I can't have my split view controller's delegate thrown
所以我不能把分屏视图控制器的委托扔出去

1409
01:03:54,731 --> 01:03:56,364
out of the heap all the time, so
一直从堆里出来，所以

1410
01:03:56,433 --> 01:03:59,534
instead I'm going to have this view controller be my split
相反，我要让这个视图控制器是我的拆分

1411
01:03:59,603 --> 01:04:01,436
view controller's delegate.
视图控制器的委托。

1412
01:04:02,872 --> 01:04:03,971
So here we go.
所以我们走。

1413
01:04:04,040 --> 01:04:06,507
Here's my CassiniViewController.
这是我的CassiniViewController。

1414
01:04:06,576 --> 01:04:09,477
Now where is a good place to set yourself as your own split
现在，哪里有好地方让你自己分裂

1415
01:04:09,546 --> 01:04:11,779
view controller's delegate?
视图控制器的委托吗?

1416
01:04:11,848 --> 01:04:13,214
You could probably do it in view and
你可以在视图中做

1417
01:04:13,283 --> 01:04:14,883
load and that would work.
load和that would work。

1418
01:04:14,951 --> 01:04:15,983
But I think a better,
但我觉得更好，

1419
01:04:16,052 --> 01:04:18,153
safer place to do it is awakeFromNib.
更安全的地方是awakeFromNib。

1420
01:04:19,990 --> 01:04:21,522
Cuz awakeFromNib if you remember from from
如果你还记得的话

1421
01:04:21,591 --> 01:04:24,192
the ViewController life cycle is called really early
ViewController的生命周期被称为非常早

1422
01:04:24,261 --> 01:04:25,226
in the game.
在游戏中。

1423
01:04:25,295 --> 01:04:31,065
So if I wanna set my own splitViewController's
如果我想设置自己的splitViewController

1424
01:04:31,134 --> 01:04:34,236
delegate to myself, delegate.
对自己委托,委托。

1425
01:04:36,472 --> 01:04:39,040
This is really early time to do it.
现在还为时尚早。

1426
01:04:39,108 --> 01:04:40,876
Now notice here that I'm taking my
注意这里

1427
01:04:40,944 --> 01:04:44,111
own splitViewController which might be nil,
自己的splitViewController，可能是nil，

1428
01:04:44,180 --> 01:04:45,980
because I might not be in a splitViewController.
因为我可能不在splitViewController中。

1429
01:04:46,049 --> 01:04:48,283
And I'm setting its delegate to myself.
我把它委托给自己。

1430
01:04:49,786 --> 01:04:51,819
Remember, every ViewController has this bar
记住，每个ViewController都有这个条

1431
01:04:51,888 --> 01:04:54,522
splitViewController which is the splitViewController,
splitViewController,splitViewController，

1432
01:04:54,591 --> 01:04:55,589
it's in if it is in one.
它在一个里面。

1433
01:04:55,658 --> 01:04:58,259
And so I'm getting an error here,
这里有个错误，

1434
01:04:58,328 --> 01:05:00,761
anyone know what this error is?
有人知道这个错误是什么吗?

1435
01:05:00,830 --> 01:05:03,898
Nobody?
没有人吗?

1436
01:05:03,967 --> 01:05:07,835
It says that you can not assign a CassiniViewController
它说你不能分配一个CassiniViewController

1437
01:05:07,904 --> 01:05:11,806
to be a UISplitViewControllerDelegate.
UISplitViewControllerDelegate。

1438
01:05:11,875 --> 01:05:14,743
You can't make this equal this, that's because this is
你不能让它等于这个，因为这是

1439
01:05:14,811 --> 01:05:17,712
CassiniViewController is not a UISplitViewDelegate.
CassiniViewController不是一个UISplitViewDelegate。

1440
01:05:17,781 --> 01:05:21,516
UISplitViewControllerDelegate.
UISplitViewControllerDelegate。

1441
01:05:21,584 --> 01:05:24,853
We have to say that it's a UISplitViewControllerDelegate.
我们不得不说,这是一个UISplitViewControllerDelegate。

1442
01:05:26,789 --> 01:05:30,258
Okay, once we say that, that resolves this error.
好的，一旦我们这么说，它就解决了这个错误。

1443
01:05:30,327 --> 01:05:33,027
All the methods in that protocol are optional.
该协议中的所有方法都是可选的。

1444
01:05:33,095 --> 01:05:34,896
So, we've satisfied the protocol,
我们已经满足了这个协议，

1445
01:05:34,964 --> 01:05:36,964
which is kinda weird.
这是有点奇怪的。

1446
01:05:37,033 --> 01:05:38,833
But now we can implement any of the ones we want.
但是现在我们可以实现我们想要的任何一个。

1447
01:05:38,902 --> 01:05:39,734
Here's a trick for you.
这里有个小窍门。

1448
01:05:39,803 --> 01:05:41,836
If you want, if you're a delegate and
如果你想，如果你是一名代表

1449
01:05:41,905 --> 01:05:43,872
you wanna find out what methods are,
你想知道方法是什么，

1450
01:05:43,941 --> 01:05:46,474
just start typing the name of the class.
只要开始键入类的名称即可。

1451
01:05:46,543 --> 01:05:47,642
So here's splitView and
这是栏

1452
01:05:47,710 --> 01:05:50,044
here's all the splitViewControllerDelegates.
这是所有splitViewControllerDelegates。

1453
01:05:50,113 --> 01:05:51,512
You have to have done this part first.
你必须先做这部分。

1454
01:05:51,581 --> 01:05:53,515
You have to say you're a delegate first.
你必须先说你是代表。

1455
01:05:53,583 --> 01:05:55,750
Once you do that, it's gonna show all these, right,
一旦你这样做了，它就会显示出所有这些，对吧?

1456
01:05:55,818 --> 01:05:58,085
these are all the things splitViewDelegate can do.
这些都是splitViewDelegate可以做的事情。

1457
01:05:58,154 --> 01:06:01,189
And we want this one right here at the top.
我们要把这个放在上面。

1458
01:06:01,258 --> 01:06:02,990
CollapseSecondary onto primary.
CollapseSecondary到初选。

1459
01:06:03,059 --> 01:06:04,558
So I'm gonna double-click that.
我要双击它。

1460
01:06:04,627 --> 01:06:09,497
I'll show you these arguments a little easier to see if I do
我会给你们看一些更容易看的论证

1461
01:06:09,566 --> 01:06:10,231
this.
这一点。

1462
01:06:12,369 --> 01:06:20,141
That and then this one.
然后这个。

1463
01:06:20,210 --> 01:06:22,176
So this splitViewControllerDelegate
所以这splitViewControllerDelegate

1464
01:06:22,245 --> 01:06:24,712
method has three arguments, one is the sender,
方法有三个参数，一个是sender，

1465
01:06:24,781 --> 01:06:27,181
that's the splitViewController asking you.
这是splitViewController问你。

1466
01:06:27,250 --> 01:06:29,851
Here, it's asking me please collapse
在这里，它在问我是否可以折叠

1467
01:06:29,919 --> 01:06:33,888
this secondaryViewController, that's a detail onto
这个第二个视图控制器，这是一个细节

1468
01:06:33,956 --> 01:06:36,824
this primaryViewController that's the master.
这个primaryViewController是master。

1469
01:06:36,893 --> 01:06:40,561
So this what happens when we first start up, a blank detail
这就是我们第一次开始的时候，一个空白的细节

1470
01:06:40,630 --> 01:06:44,465
gets put on top of the master, and we don't want that.
把它放在大师的上面，我们不希望这样。

1471
01:06:44,534 --> 01:06:48,770
But we only don't want that if that detail is blank.
但我们不希望这个细节是空白的。

1472
01:06:48,838 --> 01:06:54,074
So I'm gonna go here and say if the PrimaryViewController
我要在这里输入，如果PrimaryViewController

1473
01:06:54,143 --> 01:06:57,112
is myself, because if the PrimaryViewController is not
如果主视图控制器不是

1474
01:06:57,180 --> 01:06:59,413
myself, then the things are gone weird here,
我自己，然后事情变得奇怪了，

1475
01:06:59,482 --> 01:07:00,214
but it should be.
但它应该。

1476
01:07:00,283 --> 01:07:03,717
So I'm gonna say if the PrimaryViewController.conte-
所以我想说如果PrimaryViewController.conte -

1477
01:07:03,786 --> 01:07:07,856
nts, because I might be in navigation controller equals
nts，因为我可能在导航控制器中

1478
01:07:07,924 --> 01:07:10,425
myself, remember contents is this thing down here.
我自己，记住内容是下面这个东西。

1479
01:07:11,461 --> 01:07:12,860
So, I'm doing that there.
我在这里做这个。

1480
01:07:12,929 --> 01:07:16,497
Then I say if I can let the ImageViewController equal
然后我说，如果我能让ImageViewController等于

1481
01:07:16,566 --> 01:07:20,334
the secondaryViewController, that's the detail.
第二个视图控制器，这是detail。

1482
01:07:20,403 --> 01:07:21,636
It's this argument right here.
就是这个参数。

1483
01:07:21,705 --> 01:07:22,803
It can pass to me,
它可以传给我，

1484
01:07:22,872 --> 01:07:27,509
it's the thing that is asking me to collapse on top of it.
这就是让我崩溃的原因。

1485
01:07:27,577 --> 01:07:31,545
SecondaryViewController as an ImageViewController.
SecondaryViewController ImageViewController。

1486
01:07:31,614 --> 01:07:34,448
And again here, I wanna do contents.
在这里，我想做内容。

1487
01:07:34,517 --> 01:07:36,518
So that's inside the NavigationController.
这是导航控制器的内部。

1488
01:07:37,887 --> 01:07:38,853
But that's not all.
但这还不是全部。

1489
01:07:38,922 --> 01:07:41,488
It's not just if I have an ImageViewController being
它不只是如果我有一个ImageViewController存在

1490
01:07:41,557 --> 01:07:43,157
asked to collapse on top of me.
被要求在我身上崩溃。

1491
01:07:43,226 --> 01:07:46,795
But I wanna make sure that that IVC's imageURL.
但我要确保IVC的imageURL。

1492
01:07:49,032 --> 01:07:51,399
Equals nil.
等于零。

1493
01:07:51,467 --> 01:07:54,402
So if splitViewController's asking me to collapse
如果splitViewController要求我崩溃

1494
01:07:54,471 --> 01:07:57,538
an ImageViewController that has a blank image,
一个有空白图像的ImageViewController，

1495
01:07:57,607 --> 01:08:02,043
I'm going to return true to say, yep, I did it.
我将返回true，说，是的，我做到了。

1496
01:08:02,112 --> 01:08:03,511
But I'm not actually going to do anything.
但我不会做任何事情。

1497
01:08:03,580 --> 01:08:05,713
Because I don't want that to happen.
因为我不想让这种事情发生。

1498
01:08:05,782 --> 01:08:09,250
So I'm kinda faking out this splitViewController there.
我在这里假装这个splitViewController。

1499
01:08:09,318 --> 01:08:11,419
Otherwise I'm gonna return false, which means, no,
否则我将返回false，这意味着，不，

1500
01:08:11,488 --> 01:08:14,155
I couldn't do this collapse, so you do it.
我不能这么做，所以你这么做。

1501
01:08:14,224 --> 01:08:19,093
Now the splitViewController will do it itself.
splitViewController本身也会这样做。

1502
01:08:19,161 --> 01:08:23,431
So it's kinda funky, but I just wanted to show you this,
这有点怪，但我只是想给你们看这个，

1503
01:08:23,499 --> 01:08:26,734
to show you that there are a little more complicated ways
为了向你们展示，有一些更复杂的方法

1504
01:08:26,803 --> 01:08:28,469
to do things then I sometimes show.
为了做事情，我有时会表现出来。

1505
01:08:28,538 --> 01:08:29,304
But look what happened.
但是看发生了什么事。

1506
01:08:29,372 --> 01:08:35,043
I ran and I did not get that blank VieController.
我跑了，没有得到那个空白的控制。

1507
01:08:35,111 --> 01:08:36,611
Because I told splitViewController
因为我告诉splitViewController

1508
01:08:36,680 --> 01:08:39,480
that I collapsed it on there, but I didn't really so
我把它倒在那里了，但我真的没有

1509
01:08:39,548 --> 01:08:40,448
it did nothing.
它什么也没做。

1510
01:08:40,517 --> 01:08:43,250
But if I click on one now the image url is not nil and so
但是如果我点击一个，图像url不是nil

1511
01:08:43,319 --> 01:08:45,019
it did do the collapse for me.
它确实为我崩溃了。

1512
01:08:47,991 --> 01:08:51,659
All right, so that's it.
好了，就是这样。

1513
01:08:51,727 --> 01:08:56,498
Let's get back to our slides and do our last topic here.
让我们回到幻灯片，在这里做最后一个主题。

1514
01:08:59,569 --> 01:09:01,135
Which is our text field.
这就是我们的文本字段。

1515
01:09:01,204 --> 01:09:02,636
So I'm just gonna throw in text field in here,
我在这里输入文本框，

1516
01:09:02,705 --> 01:09:06,507
cuz you're, it's going to be included in our next demo and
因为你是，它将会被包括在我们的下一个demo中

1517
01:09:06,576 --> 01:09:10,077
in your next assignment, it's a pretty easy little class,
在下一个作业中，这是一个很简单的课程，

1518
01:09:10,146 --> 01:09:11,278
UITextField.
UITextField。

1519
01:09:11,347 --> 01:09:13,113
It's very similar to UILabel.
它和UILabel非常相似。

1520
01:09:13,182 --> 01:09:14,549
The difference is it's editable.
区别在于它是可编辑的。

1521
01:09:15,751 --> 01:09:18,553
UILabel, if you touch on it, nothing happens.
UILabel，如果你触碰它，什么也不会发生。

1522
01:09:18,621 --> 01:09:20,321
But you do UITextField, if you touch on it,
但是你做UITextField，如果你接触它，

1523
01:09:20,390 --> 01:09:23,858
a little blinking cursor happens and the keyboard will
一个闪烁的光标发生了，键盘就会

1524
01:09:23,926 --> 01:09:26,361
come up from the bottom, and you can use your thumbs and
从底部上来，你可以用你的拇指和

1525
01:09:26,429 --> 01:09:29,630
type, or, if you have an iPad with a physical keyboard,
输入，或者，如果你有一个带有物理键盘的iPad，

1526
01:09:29,699 --> 01:09:30,732
you could type or whatever.
你可以打字或者随便什么。

1527
01:09:32,502 --> 01:09:34,135
That's all the UITextField is.
这就是UITextField。

1528
01:09:34,204 --> 01:09:36,871
Now because it's editable, it's got some little
因为它是可编辑的，它有一些

1529
01:09:36,939 --> 01:09:39,440
intricacies that are quite a bit different than UILabel.
与UILabel有很大不同的复杂之处。

1530
01:09:39,509 --> 01:09:42,076
It still has things like attributed text,
它还有一些属性，

1531
01:09:42,145 --> 01:09:44,312
and you can set the font, and all these things,
你可以设置字体，以及所有这些，

1532
01:09:44,380 --> 01:09:47,848
because it's very much like a UILabel in that way.
因为它很像UILabel。

1533
01:09:47,917 --> 01:09:51,285
But there's this keyboard, okay, when you are in
但这是键盘，当你进来的时候

1534
01:09:51,353 --> 01:09:56,391
UITextField and you touch on it, it brings up a keyboard.
UITextField，你触摸它，它会弹出一个键盘。

1535
01:09:56,459 --> 01:09:59,294
So how does that keyboard show and not show?
那么这个键盘是怎么显示出来的呢?

1536
01:09:59,362 --> 01:10:03,431
Well, the keyboard shows any time, any view,
键盘可以显示任何时间，任何视图，

1537
01:10:03,500 --> 01:10:06,501
in the view hierarchy, becomes the first responder or
在视图层次结构中，成为第一个响应器

1538
01:10:06,569 --> 01:10:07,701
what's called the first responder.
所谓的第一反应者。

1539
01:10:07,770 --> 01:10:11,072
And the first responder means it wants to be the thing that
第一反应者的意思是它想要变成这样

1540
01:10:11,140 --> 01:10:12,807
gets key events from the keyboard,
从键盘获取关键事件，

1541
01:10:12,876 --> 01:10:16,343
it's the first responder for key events.
它是关键事件的第一反应者。

1542
01:10:16,412 --> 01:10:19,947
You can make your UITextField start it cursor blinking and
你可以让你的UITextField开始它的光标闪烁

1543
01:10:20,016 --> 01:10:22,684
make the keyboard come up by sending it the message become
通过发送消息，让键盘弹出

1544
01:10:22,752 --> 01:10:24,418
first responder.
第一响应者。

1545
01:10:24,487 --> 01:10:26,721
If you tell your UITextField to become the first responder,
如果你告诉UITextField成为第一反应者，

1546
01:10:26,790 --> 01:10:27,888
the keyboard will appear, so
键盘会出现

1547
01:10:27,957 --> 01:10:30,758
that's how you make the keyboard up here.
这就是你在上面创建键盘的方法。

1548
01:10:30,827 --> 01:10:33,494
And similarly if you want the keyboard to go away and
类似的，如果你想让键盘消失

1549
01:10:33,563 --> 01:10:36,564
the blinking caret to go away, say resignFirstResponder
闪烁的汽车消失了，resignFirstResponder说

1550
01:10:36,632 --> 01:10:39,534
to the TextField that is the current first responder and
对于TextField，它是当前的第一反应者和

1551
01:10:39,602 --> 01:10:40,434
it will go away.
它将消失。

1552
01:10:40,503 --> 01:10:42,136
So that's how you control the keyboard.
这就是控制键盘的方法。

1553
01:10:42,205 --> 01:10:45,406
UITextField has a delegate.
UITextField委托。

1554
01:10:45,474 --> 01:10:47,641
It has about actually ten delegate methods.
它实际上有十种委托方法。

1555
01:10:47,710 --> 01:10:49,710
Can do quite a lot of interesting things.
可以做很多有趣的事情。

1556
01:10:49,778 --> 01:10:53,213
For example, when the keyboard comes up, most keyboards,
例如，当键盘出现，大多数键盘，

1557
01:10:53,282 --> 01:10:55,516
have a Return key in the lower right hand corner.
在右下角有一个返回键。

1558
01:10:57,120 --> 01:10:58,919
And when you hit that Return key,
当你点击返回键时，

1559
01:10:58,988 --> 01:11:00,487
you get this delegate method.
得到这个委托方法。

1560
01:11:00,556 --> 01:11:02,723
Text field show return, it returns a bool.
文本字段显示返回，返回一个bool。

1561
01:11:02,791 --> 01:11:04,158
It's basically saying,
基本上说,

1562
01:11:04,227 --> 01:11:07,094
should I do what I normally do when you press Return?
当你按下回车键时，我应该做我通常做的吗?

1563
01:11:07,163 --> 01:11:09,162
Because text fields are also controls,
因为文本字段也是控件，

1564
01:11:09,231 --> 01:11:10,398
they can do target action.
他们可以做目标动作。

1565
01:11:11,701 --> 01:11:13,033
So it's kind of asking you here,
所以这是在问你，

1566
01:11:13,102 --> 01:11:14,602
should I do target action today?
我今天应该做目标行动吗?

1567
01:11:14,671 --> 01:11:17,204
You know, some control dragged to an IBaction,
你知道，有些控制被拖到IBaction，

1568
01:11:17,273 --> 01:11:18,539
should I send that?
我应该发送吗?

1569
01:11:18,608 --> 01:11:20,908
It's what it's asking here what should I return.
它问的是我应该返回什么。

1570
01:11:20,977 --> 01:11:23,911
But one thing you can do and should return you might return
但有一件事你可以做，也应该回报你

1571
01:11:23,980 --> 01:11:26,781
yes, but you might also resignFirstResponder.
是的，但你也可以重新注册。

1572
01:11:26,850 --> 01:11:28,015
Because when it hits Return,
因为当它点击返回时，

1573
01:11:28,083 --> 01:11:29,283
you want the keyboard to go away.
你想要键盘消失。

1574
01:11:29,352 --> 01:11:31,318
Because otherwise the keyboard will not go away
否则键盘不会消失

1575
01:11:31,387 --> 01:11:32,553
when it hits Return.
当它到达回报。

1576
01:11:32,622 --> 01:11:33,821
Even if you have target action,
即使你有目标行动，

1577
01:11:33,890 --> 01:11:36,290
it's not gonna make that keyboard go away.
它不会让键盘消失。

1578
01:11:36,359 --> 01:11:38,826
It's very common that you wanna implement a text
你想要实现一个文本是很常见的

1579
01:11:38,894 --> 01:11:39,726
field delegate,
领域的委托,

1580
01:11:39,795 --> 01:11:42,630
just to make the keyboard go away when you hit Return.
只是为了让键盘在你点击返回时消失。

1581
01:11:44,467 --> 01:11:47,235
What other delegate methods does a TextField have?
TextField有哪些其他委托方法?

1582
01:11:47,303 --> 01:11:51,405
You can find out every time it resigns first responder.
你可以在每次resignfirstresponder的时候发现它。

1583
01:11:51,474 --> 01:11:54,174
It will send its delegate the method didEndEditing.
它将发送它的委托方法didEndEditing。

1584
01:11:54,243 --> 01:11:56,944
So this is a good way to find out, I'd better get the text
所以这是一个很好的发现方法，我最好还是把课文写出来

1585
01:11:57,013 --> 01:11:59,113
out of there and go do something with it.
离开那里，去做些事情。

1586
01:11:59,182 --> 01:12:01,449
Because someone hit Return, or
因为有人回车，或者

1587
01:12:01,517 --> 01:12:04,785
did something that caused resignFirstResponder to happen
有什么东西引起了resignFirstResponder的发生吗

1588
01:12:04,854 --> 01:12:06,787
so this method gets sent to you.
这个方法被发送给你。

1589
01:12:06,856 --> 01:12:08,956
In fact, this is probably a more common way to
事实上，这可能是更常见的方法

1590
01:12:09,025 --> 01:12:10,524
get the text out of a text field
从文本框中获取文本

1591
01:12:10,593 --> 01:12:14,461
then target/action is to implement its delegate.
然后目标/操作是实现它的委托。

1592
01:12:14,530 --> 01:12:18,265
And in end editing you get the text out of there.
最后编辑你会得到文本。

1593
01:12:18,334 --> 01:12:19,500
Or you could even grab it
或者你甚至可以抓住它

1594
01:12:19,569 --> 01:12:21,536
out of there in should return if you want.
如果你想要的话，可以从那里回来。

1595
01:12:22,872 --> 01:12:24,138
So text field is a control.
所以文本框是一个控件。

1596
01:12:24,207 --> 01:12:27,207
You can do target action, just Ctrl drag.
你可以做目标动作，按Ctrl拖动。

1597
01:12:27,276 --> 01:12:29,510
It has certain events that can cause target action to happen
它有某些事件可以导致目标动作发生

1598
01:12:29,579 --> 01:12:30,611
just like a button actually.
就像一个按钮。

1599
01:12:30,680 --> 01:12:33,513
And you can right click on a text field in a storyboard to
你可以右键点击故事板中的文本框

1600
01:12:33,582 --> 01:12:35,416
see what it can do there.
看看它能做什么。

1601
01:12:35,484 --> 01:12:39,052
The keyboard, you can change the kind of keyboard.
键盘，你可以改变键盘的种类。

1602
01:12:39,121 --> 01:12:42,056
The keyboard, for example, there's a keyboard for
键盘，比如，有一个键盘

1603
01:12:42,125 --> 01:12:45,525
entering URLs, and it's got a button on there, .com.
输入url，它在那里有一个按钮。

1604
01:12:45,594 --> 01:12:47,794
I think it even has a button, HTTP so
我想它甚至有一个按钮，HTTP

1605
01:12:47,863 --> 01:12:50,431
that you can quickly enter a URL.
你可以快速输入一个URL。

1606
01:12:50,499 --> 01:12:52,733
There's another URL which is like a phone dialer,
还有一个URL，像一个电话拨号器，

1607
01:12:52,801 --> 01:12:55,369
which is the keypad, or another, a keypad rather.
这是键盘，或者另一个，键盘。

1608
01:12:55,438 --> 01:12:56,704
It's like a phone dialer, so
它就像电话拨号器一样

1609
01:12:56,773 --> 01:12:58,772
it just has the numbers or whatever.
它只是有数字之类的。

1610
01:12:58,841 --> 01:13:00,174
So you can specify that.
你可以指定。

1611
01:13:00,242 --> 01:13:01,942
And the way you specify those things is you
你指定这些东西的方式就是你

1612
01:13:02,011 --> 01:13:05,379
don't send any messages to any keyboard object.
不要向任何键盘对象发送任何消息。

1613
01:13:05,447 --> 01:13:07,981
You send it to any object that is using the keyboard that
你把它发送给任何使用键盘的对象

1614
01:13:08,050 --> 01:13:10,584
implements the protocol UITextInputTraits.
实现了协议UITextInputTraits。

1615
01:13:10,653 --> 01:13:13,988
UITextInputTraits is a protocol that has
uitextinputtrait是一个具有的协议

1616
01:13:14,057 --> 01:13:16,924
all these things shown here in it and
所有这些都显示在它里面

1617
01:13:16,993 --> 01:13:20,594
when you send it to something like a text field
当你把它发送到文本框的时候

1618
01:13:20,663 --> 01:13:24,265
it configures its keyboard to match that.
它配置键盘来匹配它。

1619
01:13:26,002 --> 01:13:27,802
If you want auto correction in your text field,
如果你想在文本框中自动更正，

1620
01:13:27,871 --> 01:13:30,671
where you're typing and you're mistyping, and
你在打什么，你在哪里

1621
01:13:30,740 --> 01:13:32,940
it's autocorrecting as you go, you can get that.
它是自动修正的，你可以得到它。

1622
01:13:33,008 --> 01:13:36,610
Just set your auto correction type there to .yes in your
只需设置自动更正类型。是的在你

1623
01:13:36,679 --> 01:13:37,477
text field.
文本字段。

1624
01:13:37,546 --> 01:13:40,081
So you're sending these, these vars are on text field.
你发送这些，这些vars在文本框上。

1625
01:13:40,149 --> 01:13:44,184
But they're on text field because text field implements
但是它们在文本字段上，因为文本字段实现了

1626
01:13:44,253 --> 01:13:47,554
the UITextInputTraits protocol.
UITextInputTraits协议。

1627
01:13:47,623 --> 01:13:49,356
And you can do secure text for
你可以为它做安全的文本

1628
01:13:49,425 --> 01:13:52,059
passwords and all that kind of stuff.
密码之类的东西。

1629
01:13:52,127 --> 01:13:53,527
In other words, if you're looking to control your
换句话说，如果你想控制你的

1630
01:13:53,596 --> 01:13:55,830
keyboard, don't look in text field per se,
键盘，不要看文本框本身，

1631
01:13:55,899 --> 01:13:57,965
go look at this UITextInputTrait protocol, and
去看看这个UITextInputTrait协议

1632
01:13:58,033 --> 01:14:01,635
you'll see what you can do for your keyboard.
你会看到你能用键盘做什么。

1633
01:14:01,704 --> 01:14:04,204
You can also set an accessory view in your keyboard,
你也可以在你的键盘上设置一个附属视图，

1634
01:14:04,273 --> 01:14:07,942
a little view along the top of your keyboard that is just for
在你的键盘的顶部有一个小的视图

1635
01:14:08,010 --> 01:14:09,009
your app.
你的应用程序。

1636
01:14:09,078 --> 01:14:09,677
That's kind of fun.
这是一种乐趣。

1637
01:14:09,745 --> 01:14:10,811
You just, again,
你只是,

1638
01:14:10,880 --> 01:14:13,347
just TextInputTraits protocol thing.
只是TextInputTraits协议的事情。

1639
01:14:14,850 --> 01:14:15,783
One thing about the keyboard,
关于键盘，

1640
01:14:15,851 --> 01:14:19,086
I'm actually not gonna talk about this because of time.
我不会因为时间而讨论这个问题。

1641
01:14:19,155 --> 01:14:21,555
We'll talk about this in a later lecture.
我们稍后会讲到这个。

1642
01:14:21,624 --> 01:14:24,124
But the keyboard when it comes up it actually covers up
但当键盘出现的时候，它实际上会遮住

1643
01:14:24,193 --> 01:14:25,426
your views.
你的观点。

1644
01:14:25,494 --> 01:14:28,161
So you better make sure that text field is not underneath
所以最好确保文本字段不在下面

1645
01:14:28,230 --> 01:14:29,230
the keyboard.
键盘。

1646
01:14:29,298 --> 01:14:30,965
Otherwise keyboard will come up and
否则键盘会出现

1647
01:14:31,034 --> 01:14:32,500
people will not be able to type in your text.
人们将无法输入你的文本。

1648
01:14:32,569 --> 01:14:34,969
And I see a lot of final projects that do this,
我看到很多最终的项目，

1649
01:14:35,038 --> 01:14:36,603
where you have your nice UI and
你有好的UI和

1650
01:14:36,672 --> 01:14:39,206
you've got a lot of text fields on there.
这里有很多文本字段。

1651
01:14:39,275 --> 01:14:41,975
And you've got some text fields towards the bottom of
你有一些文本框在底部

1652
01:14:42,044 --> 01:14:44,545
the screen and when I try to run your app and do it and
当我试着运行你的应用程序并做它的时候

1653
01:14:44,613 --> 01:14:46,814
I click it, I am running it on a real device,
我点击它，我在一个真实的设备上运行它，

1654
01:14:46,882 --> 01:14:49,984
there's no keyboard I can't type in the simulator.
没有键盘，我不能在模拟器上打字。

1655
01:14:50,052 --> 01:14:52,653
One thing about when you're doing text field, be careful
当你在做文本字段时，要注意一点

1656
01:14:52,722 --> 01:14:55,222
because in the simulator you can just type on the keyboard.
因为在模拟器中，你可以在键盘上输入。

1657
01:14:55,291 --> 01:14:57,892
But in the real world the keyboard's gonna slide out
但在现实世界里，键盘会滑出

1658
01:14:57,960 --> 01:14:59,360
from the bottom.
从底部。

1659
01:14:59,428 --> 01:15:01,962
So students often will do their final projects do
所以学生通常会做最后的项目

1660
01:15:02,030 --> 01:15:03,297
the whole thing in the simulator.
在模拟器中。

1661
01:15:03,365 --> 01:15:05,732
They only barely do it on the device even though that's
他们只在设备上做，即使那是

1662
01:15:05,801 --> 01:15:07,601
absolutely required for your final project by the way.
顺便说一下，你的期末项目绝对需要。

1663
01:15:07,669 --> 01:15:11,004
And they turn it in and bam they get dinged pretty hard
他们把它打开，砰的一声，他们变得很硬

1664
01:15:11,073 --> 01:15:13,607
because I can't use their app.
因为我不能使用他们的应用。

1665
01:15:13,676 --> 01:15:16,176
Because this keyboard comes up and covers up the text fields
因为这个键盘出现并覆盖了文本字段

1666
01:15:16,245 --> 01:15:19,279
that they're wanting me to enter text into.
他们想让我输入文字。

1667
01:15:19,348 --> 01:15:21,249
The way you find out about the keyboard and
你了解键盘和键盘的方法

1668
01:15:21,317 --> 01:15:24,819
where it came over is using these observers.
它在哪里使用这些观察者。

1669
01:15:24,887 --> 01:15:27,387
And you're basically gonna observe the window, and
你基本上要观察窗户

1670
01:15:27,456 --> 01:15:30,724
the window is gonna send you this little notification that
窗口会发送给你这个小通知

1671
01:15:30,793 --> 01:15:33,527
says, hey, keyboard just came up, and in the notification
嘿，键盘刚刚出现，在通知中

1672
01:15:33,596 --> 01:15:34,962
that's sent to you, there's gonna be information
那是发给你的，会有信息的

1673
01:15:35,030 --> 01:15:38,032
about the rectangle that the keyboard used to cover you,
关于键盘用来覆盖你的矩形，

1674
01:15:38,100 --> 01:15:41,402
and you have to move your UI out of the way.
你必须把你的UI移开。

1675
01:15:41,471 --> 01:15:44,338
Hopefully you're in a scrollable thing like a table
希望你在一个可以滚动的东西里，像一张桌子

1676
01:15:44,407 --> 01:15:46,440
view or just a scroll view.
视图，或者只是一个滚动视图。

1677
01:15:46,509 --> 01:15:49,643
But if not then you just gotta move, set the frame of your
但如果不是这样，你就得动起来，设置好你的框架

1678
01:15:49,712 --> 01:15:52,713
super view or something to move that thing up.
超视图或其他东西来移动这个东西。

1679
01:15:52,782 --> 01:15:54,548
Because it's your responsibility to make sure
因为你有责任确保

1680
01:15:54,616 --> 01:15:56,617
that the keyboard is not covering something that's
键盘没有覆盖一些东西

1681
01:15:56,686 --> 01:15:57,585
necessarily to user UI.
一定要用户界面。

1682
01:15:57,654 --> 01:16:01,288
So when you're doing your final projects
所以当你在做最后的项目时

1683
01:16:01,357 --> 01:16:03,891
do it on a device.
在设备上做。

1684
01:16:03,959 --> 01:16:05,993
Otherwise you are very likely to run into this problem.
否则你很可能会遇到这个问题。

1685
01:16:06,062 --> 01:16:07,762
So we'll talk about these observers,
我们会谈到这些观察者，

1686
01:16:07,830 --> 01:16:10,430
these notification sender and stuff in a future lecture.
这些通知发送者和内容在未来的讲座中。

1687
01:16:10,499 --> 01:16:13,600
There's other text field properties not
还有其他文本字段属性不是

1688
01:16:13,669 --> 01:16:16,637
related to the keyboard, like it does the auto shrinking and
与键盘有关，就像它自动收缩和

1689
01:16:16,705 --> 01:16:18,405
all that stuff that we saw with UI labels so
我们在UI标签上看到的东西

1690
01:16:18,474 --> 01:16:20,841
you can control that stuff with text field.
你可以用文本框来控制这些东西。

1691
01:16:20,910 --> 01:16:23,945
I'll let you look at the doc to figure all that stuff out.
我会让你看医生把这些东西弄清楚。

1692
01:16:25,581 --> 01:16:28,949
Text fields also have a little right and left accessory view.
文本域也有一些右和左附属视图。

1693
01:16:29,018 --> 01:16:31,852
These little overviews for like a search button.
这些小的超视图就像一个搜索按钮。

1694
01:16:31,921 --> 01:16:35,456
Or little, you can put little exclamation points in there,
或者，你可以在里面放上感叹号，

1695
01:16:35,525 --> 01:16:36,757
things like that.
类似这样的事情。

1696
01:16:36,825 --> 01:16:37,825
So you can look for that as well.
所以你也可以找它。

1697
01:16:37,893 --> 01:16:40,661
That's it.
就是这样。

1698
01:16:40,730 --> 01:16:42,863
On Wednesday I'm gonna do TableView.
周三我要做TableView。

1699
01:16:42,932 --> 01:16:44,999
Big old lecture with a big old demo.
大旧的演讲，有一个大的旧demo。

1700
01:16:45,068 --> 01:16:46,433
And that's what your homework's gonna be about.
这就是你们的作业。

1701
01:16:46,502 --> 01:16:49,569
Friday, we have a section it's going to be on
周五，我们有一节课

1702
01:16:49,638 --> 01:16:52,406
CollectionView which I'd love to teach in main lecture
我想在主课上教的是CollectionView

1703
01:16:52,475 --> 01:16:53,940
because it's really an important class.
因为这是一个很重要的课程。

1704
01:16:54,009 --> 01:16:57,177
It's very much like TableView but more flexible,
它很像TableView，但更灵活，

1705
01:16:57,246 --> 01:16:59,246
a little more powerful than TableView.
比TableView更强大一些。

1706
01:16:59,315 --> 01:17:00,914
You kind of need to know TableView first,
你首先需要知道TableView，

1707
01:17:00,983 --> 01:17:02,483
that's why we do TableView on Wednesday and
这就是为什么我们在周三和

1708
01:17:02,551 --> 01:17:04,418
then the CollectionView on Friday.
然后是周五的CollectionView。

1709
01:17:04,487 --> 01:17:06,987
Then next week I'll be doing the object oriented database,
下周我会讲面向对象的数据库，

1710
01:17:07,056 --> 01:17:09,556
called Core Data, and you'll be integrating that into your
称为Core Data，你将把它集成到你的

1711
01:17:09,625 --> 01:17:11,959
assignment 4 to make your assignment 5.
任务4，让你的作业完成。

1712
01:17:12,028 --> 01:17:13,594
That's it, see you then.
就这样，到时候见。

1713
01:17:15,264 --> 01:17:25,572
>> For more please visit us at stanford.edu.
>> 更多课程详见 stanford.edu

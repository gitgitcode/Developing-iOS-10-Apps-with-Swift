1
00:00:00,401 --> 00:00:04,535
本字幕由志愿者义务贡献，采用许可协议
知识共享 署名-非商业性使用-相同方式共享 3.0 美国

2
00:00:04,604 --> 00:00:07,838
Stanford University.
斯坦福大学

3
00:00:07,907 --> 00:00:11,109
>> All right, well, welcome to Stanford CS193P.
欢迎参加 2017 年冬季学期斯坦福

4
00:00:11,177 --> 00:00:16,980
This is Developing iOS Application, Winter of 2017.
这是iOS的应用，2017年的冬天。
CS193P 课程，iOS 应用程序开发
CS193P课程,iOS应用程序开发

5
00:00:17,049 --> 00:00:19,983
And the only topic for today is a big one, Core Data,
今天唯一的主题是，Core Data，

6
00:00:20,052 --> 00:00:23,019
which is an object oriented database.
这是一个面向对象的数据库。

7
00:00:23,088 --> 00:00:24,821
But before I dive into this,
在我深入这个问题之前，

8
00:00:24,889 --> 00:00:28,324
I'm actually going to revisit that demo we did last time
我将重新回顾上次我们做的那个demo

9
00:00:28,393 --> 00:00:31,260
just briefly, because we ran out of time and so
简单来说，因为时间不够了

10
00:00:31,329 --> 00:00:34,262
I wasn't able to show you the refresh control.
我不能给你展示刷新控制。

11
00:00:34,331 --> 00:00:35,797
Now I posted the code for it, so
现在我发布了代码

12
00:00:35,866 --> 00:00:38,066
I'm not gonna type all the code in here.
我不会在这里键入所有代码。

13
00:00:38,134 --> 00:00:40,701
But I'm just gonna briefly show you
但我只是简单地告诉你们

14
00:00:40,770 --> 00:00:43,270
how that refresh control worked, okay?
刷新控制是如何起作用的?

15
00:00:43,339 --> 00:00:45,171
Okay, so we missed that.
好吧，我们错过了。

16
00:00:45,240 --> 00:00:47,907
So here is the app we had from last time.
这是我们上次的应用。

17
00:00:47,976 --> 00:00:50,977
By the way, I have modified our app
顺便说一下，我已经修改了我们的应用程序

18
00:00:51,046 --> 00:00:53,045
here to change our request a little bit.
这里要稍微改变一下我们的要求。

19
00:00:53,113 --> 00:00:55,347
If you remember this line of code from last time,
如果你还记得上次的代码，

20
00:00:55,416 --> 00:00:56,815
it used to just have the query.
它过去只有查询。

21
00:00:56,884 --> 00:01:00,718
But I've changed it to also filter out retweets and
但我改变了它，也过滤了retweets和

22
00:01:00,787 --> 00:01:04,188
I've also put on the safe filter, which hopefully will
我也加入了安全滤镜，但愿如此

23
00:01:04,257 --> 00:01:06,624
make it so that when I do these look ups,
当我做这些的时候，

24
00:01:06,692 --> 00:01:10,227
these sort of up looks, we don't get stuff on the screen,
这些看起来，我们没有在屏幕上看到东西，

25
00:01:10,296 --> 00:01:12,129
you know this is a family show,
你知道这是一个家庭表演，

26
00:01:12,197 --> 00:01:15,331
so we don't want to see some of that stuff.
所以我们不想看到这些东西。

27
00:01:15,400 --> 00:01:17,666
Anyway, hopefully, that'll work.
无论如何,希望这将工作。

28
00:01:17,735 --> 00:01:19,735
So let's go back here and
我们回到这里

29
00:01:19,804 --> 00:01:22,571
take a look at what this looks like.
看看这是什么样子。

30
00:01:22,640 --> 00:01:24,272
There's my simulator right here.
这是我的模拟器。

31
00:01:24,341 --> 00:01:25,273
So let's go ahead and search.
我们继续搜索。

32
00:01:25,341 --> 00:01:29,710
Let's try Trump again and cross our fingers, all right.
让我们再试试特朗普，交叉手指，好吧。

33
00:01:29,779 --> 00:01:34,949
So that's not, I don't see anything too terrible there.
那不是，我在那里没有看到任何可怕的东西。

34
00:01:35,017 --> 00:01:38,752
Okay so what we added was this UI where we can pull down.
我们添加的是这个UI，我们可以把它拉下来。

35
00:01:38,821 --> 00:01:40,153
Okay and it adds more tweets,
它添加了更多的推文，

36
00:01:40,221 --> 00:01:41,888
you see how it added a tweet there?
你知道它是如何在那里添加一条tweet的吗?

37
00:01:41,957 --> 00:01:43,589
We have the second pull right there,
我们有第二个拉力，

38
00:01:43,658 --> 00:01:44,724
this was with the first pull.
这是第一次。

39
00:01:44,792 --> 00:01:49,895
And we pull down again, no tweets this time, okay?
我们再次向下拉，这次没有推文，好吗?

40
00:01:49,964 --> 00:01:52,431
So each time we pull down it's doing another twitter
所以每次我们拉下它，它都在做另一个twitter

41
00:01:52,499 --> 00:01:53,497
fetch, and
取回,

42
00:01:53,566 --> 00:01:57,268
may get more tweets depending if people are tweeting or not.
可能会得到更多的推文，这取决于人们是否在推特。

43
00:01:57,337 --> 00:01:59,503
So let's take a look at the code to do this, again,
让我们再看一遍代码，

44
00:01:59,572 --> 00:02:01,004
I posted this code, but
我发布了这个代码，但是

45
00:02:01,073 --> 00:02:02,539
we'll just look at it, I'm not gonna type it all in,
我们来看看，我不会全部输入，

46
00:02:02,608 --> 00:02:04,207
we're just gonna look at it real quick.
我们很快地看一下。

47
00:02:04,275 --> 00:02:07,042
First of all, let's talk about how do I get this UI where
首先，我们来讨论一下如何得到这个UI

48
00:02:07,111 --> 00:02:11,280
we pull down and it calls a method, or whatever?
我们向下拉，它调用一个方法，或者其他什么?

49
00:02:11,349 --> 00:02:14,150
So let's go to look in our storyboard.
我们来看看故事板。

50
00:02:16,854 --> 00:02:19,787
All right, so here's our storyboard, and
好的，这是我们的故事板

51
00:02:19,856 --> 00:02:23,691
what I did was I just selected my table view controller and
我所做的就是选择了我的表视图控制器

52
00:02:23,760 --> 00:02:26,193
I went down here to this refreshing.
我到这里来，让人耳目一新。

53
00:02:26,262 --> 00:02:27,360
You see that refreshing choice?
你看到那个令人耳目一新的选择了吗?

54
00:02:27,429 --> 00:02:30,864
And I changed it from disabled to enabled, and when I set it
我将它从禁用状态改为启用，当我设置它的时候

55
00:02:30,933 --> 00:02:33,466
to enabled nothing changed here in the UI.
在UI中没有启用任何更改。

56
00:02:33,535 --> 00:02:36,436
You can't see any spinning thing, but
你看不到任何旋转的东西，但是

57
00:02:36,504 --> 00:02:40,072
over here in the document outline it created this
在文档大纲中，它创建了这个

58
00:02:40,141 --> 00:02:42,340
refresh control right here.
刷新控制。

59
00:02:42,409 --> 00:02:45,977
And so I can control drag from the document outline just as I
我可以从文档大纲中control拖动

60
00:02:46,046 --> 00:02:47,145
can through here.
可以在这里通过。

61
00:02:47,214 --> 00:02:49,680
So all I did to make this work is I just brought up
所以我所做的一切就是我刚刚提出的

62
00:02:49,749 --> 00:02:52,082
my controller right here.
我的控制器。

63
00:02:52,151 --> 00:02:53,784
And here's the method I did it with right here.
这是我在这里做的方法。

64
00:02:53,853 --> 00:02:58,188
I just Ctrl dragged from the Refresh Control to this method
我只是从刷新控制中拖拽到这个方法

65
00:02:58,256 --> 00:03:00,590
called refresh, okay?
称为刷新?

66
00:03:00,659 --> 00:03:04,360
That's all I did to, to make that happen.
这就是我所做的一切，让这一切发生。

67
00:03:04,429 --> 00:03:05,627
And inside refresh,
在刷新,

68
00:03:05,696 --> 00:03:08,363
I just called that same method I had before, searchForTweets.
我刚才调用了同样的方法，searchForTweets。

69
00:03:08,432 --> 00:03:10,698
This one right here, the one that search for tweets.
这个在这里，搜索推文的那个。

70
00:03:10,767 --> 00:03:12,533
And that used to look like this,
以前是这样的，

71
00:03:12,602 --> 00:03:14,368
I only changed one thing in here.
我在这里只改变了一件事。

72
00:03:14,437 --> 00:03:17,805
It used to just get the twitterRequest by
它过去只是得到了twitterRequest

73
00:03:17,873 --> 00:03:19,873
looking at our search term up here.
看这里的搜索项。

74
00:03:19,942 --> 00:03:21,475
Remember this function?
还记得这个函数吗?

75
00:03:21,543 --> 00:03:25,144
And all I did was added this, which says, if
我所做的就是加上这个，如果

76
00:03:25,213 --> 00:03:29,849
the lastTwitterRequest has a newer version, then use that.
lastTwitterRequest有一个新版本，然后使用它。

77
00:03:29,918 --> 00:03:33,319
But if it doesn't, then default back to doing to query
但如果它没有，则默认返回执行查询

78
00:03:33,388 --> 00:03:35,053
request the way we used to.
请求我们过去的方式。

79
00:03:35,122 --> 00:03:37,355
The only other things that I had to do was turn the refresh
我唯一要做的其他事情就是刷新

80
00:03:37,424 --> 00:03:39,524
control off, you do that with the end refreshing.
控制，你这样做最后让人耳目一新。

81
00:03:39,593 --> 00:03:42,159
So I just did that when I went back to the main queue here,
所以当我回到主队列时，

82
00:03:42,228 --> 00:03:44,328
to get my results, so I turned it off.
为了得到结果，我关掉了它。

83
00:03:44,397 --> 00:03:45,562
I also turned it off if for
我也把它关掉了

84
00:03:45,631 --> 00:03:48,265
some reason I couldn't get any request or whatsoever.
我无法得到任何请求。

85
00:03:48,333 --> 00:03:50,634
Okay, there's nothing in the search term field and
在搜索项字段中没有

86
00:03:50,702 --> 00:03:53,002
I couldn't get a newer version of my last request.
我无法得到我最后一个请求的新版本。

87
00:03:53,071 --> 00:03:55,771
So I just said, I'm gonna make sure that thing is not
所以我只是说，我要确保那个东西不是

88
00:03:55,840 --> 00:03:57,940
spinning and spinning forever.
旋转,旋转,直到永远。

89
00:03:58,009 --> 00:03:59,374
They wanna get out of here with that.
他们想要离开这里。

90
00:03:59,443 --> 00:04:02,110
And the only other thing I had to do was up here,
我唯一要做的就是在这里，

91
00:04:02,178 --> 00:04:05,813
when the search text changes, someone types#Stanford or
当搜索文本发生变化时，就会有人键入# Stanford或

92
00:04:05,882 --> 00:04:09,250
something like that, I need to invalidate that last Twitter
像这样，我需要让最后的Twitter失效

93
00:04:09,318 --> 00:04:12,152
request so that it's not trying to get new versions
请求，这样它就不会尝试获得新的版本

94
00:04:12,221 --> 00:04:13,920
of the previous one that I had.
我之前说过的。

95
00:04:13,989 --> 00:04:16,589
I want it to do the new one.
我想让它做新的。

96
00:04:16,658 --> 00:04:20,226
And the way that I made it so that we had these little
我做这些的方法就是我们有这些小的

97
00:04:20,295 --> 00:04:24,296
titles right here, see these titles two, three, four, five?
这里的标题，看这些标题2,3,4,5 ?

98
00:04:24,365 --> 00:04:27,132
I implemented another UI table view data source method,
我实现了另一个UI表视图数据源方法，

99
00:04:27,201 --> 00:04:28,900
this one down here.
下面这一个。

100
00:04:28,969 --> 00:04:31,203
Called titleForHeaderInSection.
叫titleForHeaderInSection。

101
00:04:31,271 --> 00:04:33,437
I just put titles on the sections.
我只是把标题写在了章节上。

102
00:04:33,506 --> 00:04:36,974
Remember, each section is another pull from Twitter.
记住，每一节都是推特的另一项内容。

103
00:04:37,043 --> 00:04:38,642
And so I just have each title.
所以我只有一个标题。

104
00:04:38,711 --> 00:04:41,377
It's actually gonna be the count of things I had minus
它实际上是我得到的数减去的数

105
00:04:41,446 --> 00:04:42,312
the section number.
部分号码。

106
00:04:42,381 --> 00:04:44,146
So the top one is section zero.
最上面的是section 0。

107
00:04:44,215 --> 00:04:45,814
So section zero is gonna show
所以section 0会显示出来

108
00:04:45,883 --> 00:04:47,115
the number of pulls that I've made.
我做的抽拉次数。

109
00:04:47,184 --> 00:04:48,516
tweets.count is how many pulls I made.
tweet。数是我赚了多少钱。

110
00:04:48,585 --> 00:04:50,151
And it's obviously gonna
这显然会

111
00:04:50,219 --> 00:04:51,853
decrement as the sections go down.
当截面下降时，减量。

112
00:04:54,123 --> 00:04:57,391
Okay, so that's what gave us this.
这就是我们得到的结果。

113
00:04:57,460 --> 00:04:58,892
And you can see that the longer we wait,
你可以看到，我们等待的时间越长，

114
00:04:58,961 --> 00:05:01,661
obviously it pulls more information,
很明显，它能获取更多信息，

115
00:05:01,730 --> 00:05:02,829
as tweets pile up.
因为微博也应接不暇了。

116
00:05:04,331 --> 00:05:08,334
Okay, let's go back to our slides.
好的，我们回到幻灯片。

117
00:05:08,402 --> 00:05:10,202
All right, here we go.
好了，开始吧。

118
00:05:10,271 --> 00:05:13,871
So Core Data is this big framework inside of iOS for
Core Data是iOS内部的一个大框架

119
00:05:13,940 --> 00:05:16,574
doing object-oriented databases.
做面向对象数据库。

120
00:05:16,643 --> 00:05:19,409
So let's talk a little bit about what that means.
让我们稍微谈一下这意味着什么。

121
00:05:19,478 --> 00:05:21,545
So, when do you need a database?
那么，什么时候需要数据库呢?

122
00:05:21,613 --> 00:05:23,814
Well you need a database when you have a large amount of
当你有大量的时候你需要一个数据库

123
00:05:23,882 --> 00:05:26,916
data, and especially if you want to kind of make queries
数据，特别是如果你想查询

124
00:05:26,985 --> 00:05:30,153
into that data and find out things about that data and
输入数据并找出有关数据的信息

125
00:05:30,221 --> 00:05:32,654
the relationships between all the things in there.
所有事物之间的关系。

126
00:05:32,723 --> 00:05:34,089
You really can't do that by like,
你真的不能那样做，

127
00:05:34,158 --> 00:05:36,558
taking a big dictionary or a big array and
拿一本大字典或大数组

128
00:05:36,627 --> 00:05:39,627
searching through it, you need a database.
通过搜索，您需要一个数据库。

129
00:05:39,696 --> 00:05:42,797
And so there's a lot of technologies for databases out
所以有很多关于数据库的技术

130
00:05:42,866 --> 00:05:45,766
there but most of them are not object-oriented.
但大多数都不是面向对象的。

131
00:05:45,835 --> 00:05:48,769
So we have this framework that Apple provides called
我们有一个苹果提供的框架

132
00:05:48,837 --> 00:05:51,705
Core Data, it's what we call an object-oriented database
Core Data，我们称之为面向对象的数据库

133
00:05:51,774 --> 00:05:55,108
but actually, it's really not an object-oriented database
但实际上，它并不是面向对象的数据库

134
00:05:55,177 --> 00:05:56,976
on the inside.
在内部。

135
00:05:57,045 --> 00:05:59,411
It's only an object-oriented database on the outside.
它只是一个面向对象的数据库。

136
00:05:59,480 --> 00:06:01,247
The side that you look at.
你看到的那一边。

137
00:06:01,315 --> 00:06:04,950
Underneath, it's actually a relational database usually.
在下面，它通常是一个关系数据库。

138
00:06:05,018 --> 00:06:08,987
Now Core Data is designed to have any backend of storage.
现在Core Data被设计成具有任何后端存储。

139
00:06:09,055 --> 00:06:11,589
But it's primary implementation is on top of
但它的主要实现是在上面

140
00:06:11,657 --> 00:06:13,957
SQL which is a relational database.
是一个关系数据库。

141
00:06:14,026 --> 00:06:18,061
How many people know what SQL Database is?
有多少人知道SQL数据库是什么?

142
00:06:18,130 --> 00:06:19,396
Okay, almost all of you, good.
好了，几乎所有人都很好。

143
00:06:19,464 --> 00:06:25,268
So, if we had to do databases in our iOS apps using SQL,
如果我们在iOS应用中使用SQL做数据库，

144
00:06:25,336 --> 00:06:27,870
we'd be like no, I have to learn this whole query
我们会像不一样，我必须学习整个查询

145
00:06:27,939 --> 00:06:29,705
language, and how am I gonna do this?
语言，我该怎么做呢?

146
00:06:29,774 --> 00:06:32,708
Not to worry, we don't have to know any SQL to use core Data.
不用担心，我们不需要知道任何SQL来使用core Data。

147
00:06:32,776 --> 00:06:35,543
No SQL whatsoever- we're just gonna purely do this
没有SQL，我们只需要这样做

148
00:06:35,612 --> 00:06:38,280
on the object side.
在对象方面。

149
00:06:38,348 --> 00:06:39,380
So how does this work?
那么它是如何工作的呢?

150
00:06:39,449 --> 00:06:40,380
How does core Data work?
core Data是如何工作的?

151
00:06:40,449 --> 00:06:43,551
Well, first we're gonna create a visual mapping
首先，我们要创建一个可视映射

152
00:06:43,619 --> 00:06:45,985
between things in our database and
在我们的数据库和

153
00:06:46,054 --> 00:06:48,688
some objects that we're gonna be able to program with
一些我们可以编程的对象

154
00:06:48,757 --> 00:06:51,791
in our object-oriented code that we like.
在我们喜欢的面向对象代码中。

155
00:06:51,860 --> 00:06:54,793
And kinda roughly, it's
有点粗略,它

156
00:06:54,862 --> 00:06:58,597
the tables in the database are kinda gonna be objects.
数据库中的表有点像对象。

157
00:06:58,666 --> 00:07:01,833
And the columns in the tables are kind of vars.
表格中的列是vars。

158
00:07:01,902 --> 00:07:04,069
But we don't even really care what it's doing there.
但我们甚至不关心它在那里做什么。

159
00:07:04,137 --> 00:07:06,737
What we're gonna focus on is this visual map,
我们要关注的是这个可视地图，

160
00:07:06,806 --> 00:07:10,607
this visual description basically of our schema.
这个视觉描述基本上就是我们的模式。

161
00:07:10,676 --> 00:07:12,509
Okay, how many people know what the word schema means?
有多少人知道图式是什么意思?

162
00:07:12,578 --> 00:07:15,812
Okay, so two-thirds of you.
好的，三分之二的人。

163
00:07:15,881 --> 00:07:18,748
So schema is basically the description of what's
图式基本上就是对事物的描述

164
00:07:18,816 --> 00:07:22,218
in your database, not the contents of it but how all its
在你的数据库中，不是它的内容，而是它的全部

165
00:07:22,287 --> 00:07:24,687
data types are and how they relate to each other, etc.
数据类型是和它们如何相互关联的，等等。

166
00:07:24,756 --> 00:07:27,923
So we're gonna do all that graphically.
我们要用图形来做。

167
00:07:27,992 --> 00:07:30,325
And this is what it looks like.
这就是它的样子。

168
00:07:30,394 --> 00:07:33,428
First, if I wanna use Core Data in my app,
首先，如果我想在app中使用Core Data，

169
00:07:33,497 --> 00:07:37,498
I'm almost certainly going to wanna click this button
我几乎肯定会想要点击这个按钮

170
00:07:37,567 --> 00:07:39,366
that says Use Core Data.
这就是说使用核心数据。

171
00:07:39,435 --> 00:07:41,869
We've seen it every time we've created an app, and we haven't
每次我们创建一个应用程序，我们都见过它

172
00:07:41,938 --> 00:07:43,870
clicked it so far, but now we are going to click it.
到目前为止，点击它，但现在我们要点击它。

173
00:07:43,939 --> 00:07:45,872
And clicking Use Core Data there,
点击使用Core Data，

174
00:07:45,940 --> 00:07:48,875
is gonna create two things for us, this visual map,
为我们创建了两个东西，这个可视映射，

175
00:07:48,943 --> 00:07:50,943
and some code in your App Delegate.
以及App委托中的一些代码。

176
00:07:51,012 --> 00:07:52,878
And I'm gonna talk about both of those things.
我要谈谈这两件事。

177
00:07:52,946 --> 00:07:54,112
Now before I go to the next slide,
在下一张幻灯片之前，

178
00:07:54,181 --> 00:07:56,948
notice that the name of this app is CoreDataExample.
请注意，此应用程序的名称为CoreDataExample。

179
00:07:57,017 --> 00:07:59,317
That's the, just the name of the app that I typed in there.
这就是我在这里输入的应用程序的名字。

180
00:08:00,487 --> 00:08:03,386
So when I create this app, clicking that
当我创建这个应用时，点击它

181
00:08:03,455 --> 00:08:06,790
Use Core Data on, you'll see that it created this file,
使用Core Data，你会看到它创建了这个文件，

182
00:08:06,859 --> 00:08:10,260
CoreDataExample.xcdatamodeld.
CoreDataExample.xcdatamodeld。

183
00:08:10,329 --> 00:08:12,395
So it chose the name of my app as it.
所以它选择了我的app的名字。

184
00:08:12,463 --> 00:08:16,332
And this is going to be our data model, all right?
这将是我们的数据模型?

185
00:08:16,401 --> 00:08:18,433
And so we'll, we'll talk about the AppDelegate
我们会讲到AppDelegate

186
00:08:18,502 --> 00:08:21,570
code that Use Core Data also generated a little bit later.
使用核心数据的代码也会在稍后生成。

187
00:08:21,639 --> 00:08:25,473
Right now we're gonna focus on this data model file.
现在我们关注这个数据模型文件。

188
00:08:25,542 --> 00:08:28,977
All right, but before we even do that, what happens if we
好的，但在我们做之前，如果我们

189
00:08:29,045 --> 00:08:32,413
have an existing app and you did not click Use Core Data?
有一个现有的应用程序，你没有点击使用Core Data吗?

190
00:08:32,482 --> 00:08:34,748
And now you decided, hey, I wanna add core data.
现在你决定，嘿，我想添加core data。

191
00:08:34,817 --> 00:08:38,318
Like maybe Smashtag Assignment 5 comes out and
比如Smashtag任务5出来了

192
00:08:38,386 --> 00:08:40,953
I tell you to add some Core Data to Smashtag.
我告诉您添加一些Core Data到Smashtag。

193
00:08:41,022 --> 00:08:42,789
And you're like, woh, I can't go back and
你说，哇，我不能回去了

194
00:08:42,857 --> 00:08:44,690
click Use Core Data, it's too late.
点击使用Core Data，太晚了。

195
00:08:44,759 --> 00:08:47,726
So you're gonna have to create this data model file
你需要创建这个数据模型文件

196
00:08:47,794 --> 00:08:48,827
using new file.
使用新文件。

197
00:08:48,896 --> 00:08:51,463
So you just go to File > New > File like this.
你只需要像这样打开>新的>文件。

198
00:08:51,532 --> 00:08:52,830
You're not gonna pick any of
你不会选择任何一个

199
00:08:52,899 --> 00:08:54,465
the things we've picked so far.
到目前为止我们所选的东西。

200
00:08:54,533 --> 00:08:56,600
You're gonna scroll down to the section that
你要向下滚动到那部分

201
00:08:56,668 --> 00:08:57,401
says Core Data.
核心数据表示。

202
00:08:57,469 --> 00:08:59,669
And inside there these, there's two things,
在这里面，有两件事，

203
00:08:59,738 --> 00:09:01,137
Data Model and Mapping Model.
数据模型和映射模型。

204
00:09:01,206 --> 00:09:04,406
And make sure you pick Data Model because that's what you
确保你选择了数据模型，因为那就是你

205
00:09:04,475 --> 00:09:06,775
want to do here is create your data model,
这里要做的是创建数据模型，

206
00:09:06,844 --> 00:09:09,511
your schema essentially, for your database.
对于数据库，您的模式本质上是这样的。

207
00:09:09,580 --> 00:09:11,179
It's gonna ask you what you wanna call it.
它会问你想叫什么。

208
00:09:11,247 --> 00:09:13,948
Now, you don't have to call this the same as the name of
现在，你不必把这个叫做

209
00:09:14,017 --> 00:09:16,484
your application like Use Core Data button does.
你的应用就像使用Core Data按钮一样。

210
00:09:16,552 --> 00:09:17,584
You can call it anything you want.
你可以叫它任何你想要的东西。

211
00:09:17,653 --> 00:09:20,220
So here, just to be different, I've called it Model,
这里，为了不一样，我把它叫做模型，

212
00:09:20,289 --> 00:09:21,955
it's my model.
这是我的模型。

213
00:09:22,023 --> 00:09:23,355
And by the way,
顺便说一下,

214
00:09:23,424 --> 00:09:27,994
your core data is usually the model of a lot of MVCs.
您的核心数据通常是许多mvc的模型。

215
00:09:28,062 --> 00:09:31,429
Okay, a lot of MVCs, their job is going to be to display
很多mvc，它们的任务就是显示

216
00:09:31,498 --> 00:09:35,167
the data in the database, and so this data model is actually
数据库中的数据，实际上是这个数据模型

217
00:09:35,236 --> 00:09:37,568
the MVC model as well for a lot of MVCs.
MVC模型也适用于许多MVC。

218
00:09:37,637 --> 00:09:39,737
So I'll call this one model, and
我把这个叫做模型

219
00:09:39,806 --> 00:09:42,773
you can see it created model.xedatamodeld.
您可以看到它创建了model . xedatamodeld。

220
00:09:42,842 --> 00:09:46,477
So whether you get that file by doing Use Core Data or
所以不管你是通过使用Core Data获取这个文件

221
00:09:46,545 --> 00:09:48,445
whether you get it by creating it yourself,
不管你是通过自己创造，

222
00:09:48,514 --> 00:09:51,281
you're gonna have this mapping file.
你会有这个映射文件。

223
00:09:51,350 --> 00:09:54,017
Now, let me go back to that AppDelegate thing.
现在，让我回到那个AppDelegate的事情。

224
00:09:54,085 --> 00:09:56,819
I said they was gonna put some code in your AppDelegate.
我说过他们会在你的应用程序中添加一些代码。

225
00:09:56,888 --> 00:09:58,954
It's very small amount of code.
这是非常小的代码。

226
00:09:59,023 --> 00:10:01,089
But I wanted to show it to you right here.
但我想在这里展示给你们看。

227
00:10:01,158 --> 00:10:02,891
This is what it looks like.
这就是它的样子。

228
00:10:02,960 --> 00:10:05,794
It just creates this one var right here.
它只会在这里创建一个var。

229
00:10:07,296 --> 00:10:10,130
By the way, if you didn't do Use Core Data, of course,
顺便说一下，如果你没有使用Core Data，当然，

230
00:10:10,199 --> 00:10:12,198
you need this code in your AppDelegate,
在AppDelegate中需要这个代码，

231
00:10:12,267 --> 00:10:13,799
how are you gonna get it?
你将如何得到它?

232
00:10:13,868 --> 00:10:16,669
Just go create some dummy application.
只需要创建一些虚拟应用程序。

233
00:10:16,738 --> 00:10:19,405
Call it Foo, it doesn't really matter what you call it.
把它叫做Foo，它并不重要。

234
00:10:19,474 --> 00:10:21,707
Click Use Core Data when you create it and
创建时单击使用核心数据

235
00:10:21,775 --> 00:10:24,610
then copy this code from that AppDelegate to here.
然后将该代码从AppDelegate复制到这里。

236
00:10:24,678 --> 00:10:27,913
Okay, the code is identical from every app.
好的，每个应用程序的代码都是相同的。

237
00:10:27,981 --> 00:10:31,115
The only difference between any of those things is this
它们之间唯一的区别就是这个

238
00:10:31,183 --> 00:10:32,549
one string right here.
一个字符串。

239
00:10:32,618 --> 00:10:33,384
You see that string?
你看到那个字符串?

240
00:10:33,453 --> 00:10:36,253
That's the name of that xcmodeld file, so
这就是xcmodeld文件的名称

241
00:10:36,321 --> 00:10:37,520
datamodeld file.
datamodeld文件。

242
00:10:37,589 --> 00:10:39,021
So with our core data example,
以我们的核心数据为例，

243
00:10:39,090 --> 00:10:41,190
this string would be CoreDataExample.
这个字符串就是CoreDataExample。

244
00:10:41,259 --> 00:10:43,692
When we went back and created it on our own with new file,
当我们用新文件创建它时，

245
00:10:43,761 --> 00:10:45,093
of course, we called it Model.
当然，我们称之为模型。

246
00:10:45,162 --> 00:10:49,130
So just make sure this string matches the name of the file,
所以要确保这个字符串匹配文件的名称，

247
00:10:49,198 --> 00:10:53,100
the xcmodel datamodeld file, okay?
xcmodel datamodeld文件?

248
00:10:53,169 --> 00:10:55,736
So that's what you need to do if you didn't do the use
如果你不使用它，那就是你需要做的

249
00:10:55,805 --> 00:10:57,805
Code Data originally you are going back and
代码数据最初你要回去

250
00:10:57,874 --> 00:10:59,038
adding it- just copy and paste.
添加-只是复制和粘贴。

251
00:10:59,107 --> 00:11:03,509
It's only this one var really, it does provide another thing
它只是一个var，它提供了另一个东西

252
00:11:03,578 --> 00:11:06,946
in your AppDelegate which is a function called saveContext.
在AppDelegate中，这是一个叫做saveContext的函数。

253
00:11:07,014 --> 00:11:08,147
It's a very simple little function.
这是一个非常简单的函数。

254
00:11:08,215 --> 00:11:11,016
I'm gonna show you how you could write it yourself.
我来告诉你怎么自己写。

255
00:11:11,085 --> 00:11:12,918
If you wanna copy it in, you can.
如果你想复制它，你可以。

256
00:11:12,987 --> 00:11:16,321
Also I notice that they have applicationWillTerminate which
另外，我注意到他们已经应用了

257
00:11:16,390 --> 00:11:18,790
is this application, AppDelegate method,
是这个应用程序，AppDelegate方法，

258
00:11:18,858 --> 00:11:21,592
that gets called right before you get terminated or
这在你被终止之前就被调用了

259
00:11:21,661 --> 00:11:24,594
you terminate it in any way and they call saveContext.
你以任何方式终止它，它们调用saveContext。

260
00:11:24,663 --> 00:11:26,129
Well, it's a kind of an idea, a good idea.
好吧，这是一种想法，一个好主意。

261
00:11:26,198 --> 00:11:28,198
saveContext() just saves your database.
saveContext()只是保存数据库。

262
00:11:28,267 --> 00:11:30,566
That's what saveContext does, all right?
这就是saveContext的作用?

263
00:11:30,635 --> 00:11:33,903
So this is how you can make up if you didn't do it.
所以如果你不这样做，你就可以弥补。

264
00:11:33,971 --> 00:11:37,139
So anyway, you can see that the only thing in here
无论如何，你可以看到这里唯一的东西

265
00:11:37,208 --> 00:11:39,641
is this lazy var persistentContainer, and
这是一个懒惰的var持久容器吗

266
00:11:39,709 --> 00:11:41,209
I'm gonna talk all about persistentContainer,
我要讲的是persistentContainer，

267
00:11:41,277 --> 00:11:43,677
because that's the thing that essentially contains
因为这是本质上包含的东西

268
00:11:43,746 --> 00:11:46,346
your database, all right?
您的数据库?

269
00:11:46,415 --> 00:11:48,215
But let's go back and talk about the visual map.
让我们回过头来讨论一下视觉地图。

270
00:11:48,284 --> 00:11:51,084
Cuz we have to have a visual map before we can do anything
因为我们必须要有一个可视的地图才能做任何事情

271
00:11:51,153 --> 00:11:53,853
in our database because we have to have some things in
在我们的数据库中，因为我们需要一些东西

272
00:11:53,922 --> 00:11:56,556
our database, some objects and things like that.
我们的数据库，一些对象之类的东西。

273
00:11:56,625 --> 00:12:00,292
And Core database stores things in this kind of very
Core database在这方面存储东西

274
00:12:00,361 --> 00:12:02,027
straightforward way.
直接的方法。

275
00:12:02,095 --> 00:12:05,764
It looks very object-oriented in our code because
它在我们的代码中看起来很面向对象

276
00:12:05,833 --> 00:12:08,466
in Core Data terms it's storing entities,
在Core Data术语中，它是存储实体，

277
00:12:08,535 --> 00:12:11,235
which look like classes to our code.
这看起来像是我们代码的类。

278
00:12:11,304 --> 00:12:14,872
Attributes, which look like vars on our classes.
属性，在我们的类中看起来像vars。

279
00:12:14,940 --> 00:12:18,242
And relationship, which just look like vars that point to
关系，看起来像vars

280
00:12:18,310 --> 00:12:22,279
other objects in the database, other entities, etc.
数据库中的其他对象、其他实体等。

281
00:12:22,348 --> 00:12:25,181
And so we're gonna use this what I'm calling a storyboard.
所以我们要用这个我称之为故事板。

282
00:12:25,250 --> 00:12:26,081
It's not, don't get confused,
不是，别搞混了，

283
00:12:26,150 --> 00:12:27,716
this is not a storyboard, okay?
这不是故事板，明白吗?

284
00:12:27,785 --> 00:12:30,319
You know what a storyboard is, your Interface Builder thing.
你知道故事板是什么，你的接口生成器。

285
00:12:30,387 --> 00:12:32,087
But it's kind of like a storyboard,
但它有点像故事板，

286
00:12:32,156 --> 00:12:34,823
that's why it's in quotes for databases.
这就是为什么它在引用数据库的原因。

287
00:12:34,892 --> 00:12:37,224
It's a graphical, visual editor to create and
这是一个图形化的可视化编辑器

288
00:12:37,293 --> 00:12:40,427
describe all these entities, attributes and relationships,
描述所有这些实体、属性和关系，

289
00:12:40,496 --> 00:12:42,896
okay, that's what we're gonna do here.
这就是我们要做的。

290
00:12:42,965 --> 00:12:45,098
So let's start by adding an entity.
让我们从添加一个实体开始。

291
00:12:45,166 --> 00:12:48,034
Very easy, we go down to this button on the bottom here
很简单，我们到下面这个按钮

292
00:12:48,103 --> 00:12:49,502
called Add Entity.
添加实体。

293
00:12:49,571 --> 00:12:51,103
Okay, to add an entity.
添加一个实体。

294
00:12:51,172 --> 00:12:53,305
By the way, there's couple other things in that if you
顺便说一下，如果你的话，还有一些其他的东西

295
00:12:53,374 --> 00:12:55,807
hold down on that button you'll see Add Fetch Request,
按住这个按钮，你会看到Add fetchrequest，

296
00:12:55,875 --> 00:12:56,774
and Add Configuration.
并添加配置。

297
00:12:56,843 --> 00:12:58,642
I don't have time to talk about those unfortunately,
我没有时间来讨论这些，

298
00:12:58,711 --> 00:13:01,345
but especially Add Fetch Request is kind of a cool one.
尤其是添加fetchrequest是一种很酷的请求。

299
00:13:01,414 --> 00:13:04,247
So, if you can take what I teach you here and extend it
所以，如果你能接受我教给你的东西并扩展它

300
00:13:04,316 --> 00:13:07,350
by going and learning about that, that would be great.
通过学习和学习，那将是伟大的。

301
00:13:07,419 --> 00:13:08,884
So you click Add Entity,
点击添加实体，

302
00:13:08,953 --> 00:13:11,754
it creates a new entity called Entity.
它创建了一个名为entity的新实体。

303
00:13:11,822 --> 00:13:13,822
Cuz it doesn't know what name you want for it yet.
因为它还不知道你想要什么名字。

304
00:13:13,891 --> 00:13:16,491
And like I say, this analogous to a class.
就像我说的，类似于一个类。

305
00:13:16,560 --> 00:13:20,295
Now in our code we're gonna see any instances of this
在我们的代码中，我们将看到任何实例

306
00:13:20,364 --> 00:13:24,432
entity as instances of a class called NSManagedObject.
实体作为一个类的实例，称为NSManagedObject。

307
00:13:24,501 --> 00:13:27,235
So NSManagedObject super important in Core Data.
NSManagedObject在Core Data中非常重要。

308
00:13:27,304 --> 00:13:29,804
It is the super class or the class of everything that
它是所有东西的超类或类

309
00:13:29,872 --> 00:13:32,773
comes, all these entities that come out of the database.
来，所有这些从数据库中出来的实体。

310
00:13:32,842 --> 00:13:36,142
It's like the thing that represents them in our code,
就像在我们的代码中代表它们的东西一样，

311
00:13:36,211 --> 00:13:37,710
and we'll see all about that.
我们将会看到这些。

312
00:13:37,779 --> 00:13:40,679
So for my kind of slides here,
我这里的幻灯片，

313
00:13:40,748 --> 00:13:43,715
what I'm gonna do is create a database that would have
我要做的是创建一个数据库

314
00:13:43,784 --> 00:13:45,384
stuff like we got from Twitter.
像我们从Twitter得到的东西。

315
00:13:45,453 --> 00:13:46,952
So it's gonna have tweets and
它会有推文和

316
00:13:47,021 --> 00:13:48,086
we're gonna have Twitter users.
我们会有推特用户。

317
00:13:48,155 --> 00:13:49,954
So those are gonna be two entities that we have and
这就是我们所拥有的两个实体

318
00:13:50,023 --> 00:13:52,223
you're gonna see eventually, we're gonna have Tweet and
你会看到最终，我们会有推特和

319
00:13:52,292 --> 00:13:53,557
TwitterUser classes in our code and
我们代码中的TwitterUser类

320
00:13:53,625 --> 00:13:55,258
we're gonna access vars and all that stuff.
我们将访问vars和所有这些东西。

321
00:13:55,327 --> 00:13:57,126
So I'm gonna rename this entity,
我要重命名这个实体，

322
00:13:57,195 --> 00:13:59,828
this, that I added that was defaulted to entity,
我补充说，这是对实体的违约，

323
00:13:59,897 --> 00:14:02,331
I'm gonna rename it and call it Tweet.
我把它重命名为Tweet。

324
00:14:02,400 --> 00:14:04,934
So this is gonna be the first entity that I'm creating
这将是我创建的第一个实体

325
00:14:05,002 --> 00:14:06,568
in the database.
在数据库中。

326
00:14:06,636 --> 00:14:08,837
Now, an entity can have attributes.
现在，一个实体可以具有属性。

327
00:14:08,906 --> 00:14:11,005
Those are kind of like vars, and relationships.
这有点像vars和关系。

328
00:14:11,074 --> 00:14:14,108
Those are like vars that point to other entities.
这些就像vars指向其他实体。

329
00:14:14,177 --> 00:14:16,276
And I told you this fetched properties down at the bottom,
我告诉过你们，这是在底部取的，

330
00:14:16,345 --> 00:14:17,144
I'm not gonna talk about.
我不会讲的。

331
00:14:17,213 --> 00:14:19,078
Very cool, but not gonna talk about them.
很酷，但不会谈论它们。

332
00:14:19,147 --> 00:14:21,047
Not just time-wise.
不仅仅是时间。

333
00:14:21,115 --> 00:14:23,315
So let's go and add some attributes to this entity.
让我们添加一些属性到这个实体。

334
00:14:23,384 --> 00:14:24,783
Real easy, you click this plus button,
很简单，点击这个+按钮，

335
00:14:24,852 --> 00:14:26,284
there's also an Add Attribute button,
还有一个Add属性按钮，

336
00:14:26,353 --> 00:14:28,419
see it down in the lower right hand corner there.
在右下角看到它。

337
00:14:28,488 --> 00:14:29,954
But I'm gonna click this little plus
但我要点击这个加号

338
00:14:30,023 --> 00:14:33,290
button right there under the section called Attributes.
按钮就在属性栏下面。

339
00:14:33,359 --> 00:14:36,059
And when I do there it adds a new attribute called attribute
当我在那里做的时候，它会添加一个叫做属性的新属性

340
00:14:36,128 --> 00:14:37,927
and I'm gonna edit its name directly,
我要直接编辑它的名字，

341
00:14:37,996 --> 00:14:39,495
just like I did the entity name.
就像我做实体名称一样。

342
00:14:39,564 --> 00:14:40,663
I'm gonna change this to be text.
我要把它改成文本。

343
00:14:40,732 --> 00:14:45,268
So, this is gonna be our tweet text, the 140 characters
这是我们的tweet文本，140个字符

344
00:14:45,336 --> 00:14:49,438
of the tweet is gonna be this particular attribute.
这条推特将会是这个特殊的属性。

345
00:14:49,506 --> 00:14:53,008
Now, notice as soon as I did that, I got an error.
注意，一旦我这么做了，就会出错。

346
00:14:53,077 --> 00:14:55,476
In the corner there, this red error.
在角落里，这个红色的错误。

347
00:14:55,545 --> 00:14:56,043
And the reason for
的原因

348
00:14:56,112 --> 00:14:58,846
that is all attributes have to have a type.
这是所有属性都必须有类型。

349
00:14:58,914 --> 00:15:01,182
They can't just be undefined type like this one is.
它们不能只是像这样的未定义类型。

350
00:15:01,250 --> 00:15:03,350
You see where it says the type is undefined.
你可以看到它说的类型是未定义的。

351
00:15:03,419 --> 00:15:05,919
So, we need to change that to be a type.
所以，我们需要把它变成一种类型。

352
00:15:05,988 --> 00:15:08,721
And it's really easy, right there where it says undefined.
这很简单，在这里没有定义。

353
00:15:08,790 --> 00:15:10,122
We're just going to mouse down,
我们要把鼠标往下拉，

354
00:15:10,191 --> 00:15:12,924
it's gonna bring up a menu and we can choose our type.
它会打开一个菜单，我们可以选择我们的类型。

355
00:15:12,993 --> 00:15:15,393
Now, these are the types we have to choose from.
现在，这些是我们必须选择的类型。

356
00:15:15,462 --> 00:15:18,663
A lot of different numeric types like 16-bit integers,
很多不同的数字类型，比如16位整数，

357
00:15:18,732 --> 00:15:20,164
32-bit integer, etc.

358
00:15:20,233 --> 00:15:23,900
Doubles, floats, can a be string of course,
双打，花车，当然可以是字符串，

359
00:15:23,969 --> 00:15:28,605
a Boolean value, a date which is going to look like a date,
一个布尔值，一个看起来像一个日期的日期，

360
00:15:28,674 --> 00:15:32,142
you know, the date struct in our code.
你知道，我们代码中的日期结构。

361
00:15:32,210 --> 00:15:35,445
And binary data which is gonna look like the data struct
而二进制数据看起来像数据结构

362
00:15:35,513 --> 00:15:36,513
inside our code.
在我们的代码。

363
00:15:36,581 --> 00:15:39,782
So, these are gonna map to very familiar data types
这些会映射到非常熟悉的数据类型

364
00:15:39,851 --> 00:15:40,849
that we see.
我们看到的。

365
00:15:40,918 --> 00:15:42,317
There is that one at the bottom there,
在底部有一个，

366
00:15:42,386 --> 00:15:44,919
transformable, another thing I'm not gonna talk about.
转换，另一件事我不打算讲。

367
00:15:44,988 --> 00:15:48,322
But transformable allows you to store anything
但是，transformable可以存储任何东西

368
00:15:48,391 --> 00:15:51,592
into the database by converting it to a data, and
将其转换为数据，然后进入数据库

369
00:15:51,661 --> 00:15:53,326
then converting it back on the way out.
然后把它转换回来。

370
00:15:53,395 --> 00:15:54,728
And so if you pick transformable there,
如果你选择transformable，

371
00:15:54,797 --> 00:15:56,729
you're gonna have to do some extra work.
你得做点额外的工作。

372
00:15:56,798 --> 00:15:59,599
To tell Core Data about that transformation, and that's why
告诉Core Data关于这个转换的信息，这就是为什么

373
00:15:59,668 --> 00:16:02,001
I don't really have time to tell you about, but just know
我没有时间告诉你，只是知道而已

374
00:16:02,070 --> 00:16:04,003
that if you wanted to store something like a CGRect.
如果你想存储类似CGRect的东西。

375
00:16:04,071 --> 00:16:07,539
Actually, if I was going to store a CGRect, I might use
实际上，如果我要存储一个CGRect，我可能会用到

376
00:16:07,607 --> 00:16:09,841
the function, there's some function called something like
函数有一些函数

377
00:16:11,344 --> 00:16:13,143
NSStringFromCGRect.
NSStringFromCGRect。

378
00:16:13,212 --> 00:16:14,278
It gives you a string, and
它给你一个字符串

379
00:16:14,346 --> 00:16:16,112
then there's NSCGRectFromString or
还有NSCGRectFromString或

380
00:16:16,181 --> 00:16:16,746
something like that.
就像这样。

381
00:16:16,815 --> 00:16:18,047
So I'd probably store it as a string,
我可能把它存储为字符串，

382
00:16:18,115 --> 00:16:20,482
but if I had something more complicated than that,
但如果我有更复杂的东西，

383
00:16:20,551 --> 00:16:21,783
then I might use a transformable.
然后我可以用一个可转换的。

384
00:16:21,852 --> 00:16:27,388
All right, these attributes here are going to be accessed,
这些属性将被访问，

385
00:16:27,457 --> 00:16:29,390
we're gonna get and set their values.
我们将得到并设置它们的值。

386
00:16:29,459 --> 00:16:32,159
Well actually, we're not going to do this but fundamentally
实际上，我们不会这样做，但从根本上说

387
00:16:32,228 --> 00:16:34,595
the way you do it is you have these two methods,
你的方法是，你有这两种方法，

388
00:16:34,664 --> 00:16:36,430
value(forKey) and setValue (forKey).
值(forKey)和setValue(forKey)。

389
00:16:36,498 --> 00:16:38,598
And I'll talk about how we're gonna use that, but
我会讲到如何使用它，但是

390
00:16:38,667 --> 00:16:43,036
that's how we're gonna set and get the values on an entity.
这就是我们如何设置和获取一个实体的值。

391
00:16:43,105 --> 00:16:44,971
Notice the error went away as soon as we
注意，错误一开始就消失了

392
00:16:45,040 --> 00:16:47,239
gave this thing, a type.
给这个东西，一种类型。

393
00:16:47,308 --> 00:16:50,709
So here I'm gonna add some more attributes, identifier,
这里我要添加一些属性，标识符，

394
00:16:50,777 --> 00:16:52,978
which is just some string that identifies the tweet and
哪个是用来识别tweet的字符串

395
00:16:53,046 --> 00:16:55,714
then created, which was when it was tweeted.
然后创建了，这是在推特上。

396
00:16:55,782 --> 00:17:00,251
Notice I'm setting created's type here to be date because
注意，这里设置的是日期，因为

397
00:17:00,320 --> 00:17:03,287
it is a date, obviously, when the thing was created.
很明显，这是一个日期。

398
00:17:03,356 --> 00:17:06,189
Now this is one way to look at our entities and attributes,
这是观察我们的实体和属性的一种方法，

399
00:17:06,258 --> 00:17:07,257
this kind of table form.
这种表格。

400
00:17:07,326 --> 00:17:09,859
But we can actually look at it in graphical form as well.
但我们也可以用图形形式来观察它。

401
00:17:09,928 --> 00:17:12,094
If you see down in the corner where it says editor style.
如果你看到角落里有编辑风格。

402
00:17:12,163 --> 00:17:13,829
If I click on the other button there,
如果我点击这里的另一个按钮，

403
00:17:13,898 --> 00:17:15,965
the one that looks a little more like a graph,
这个看起来更像图形，

404
00:17:16,033 --> 00:17:17,832
then it shows me the same thing but
然后它向我展示了同样的东西

405
00:17:17,901 --> 00:17:18,867
in this graphical form.
在这个图形的形式。

406
00:17:18,936 --> 00:17:21,335
It's even on graph paper, all right?
它甚至在坐标纸上，对吧?

407
00:17:21,404 --> 00:17:24,105
And in this form right here we can do
在这个表格中我们可以做

408
00:17:24,173 --> 00:17:25,806
all the things that we did in the other one.
我们在另一个中做的所有事情。

409
00:17:25,875 --> 00:17:27,941
For example, I can still add entity here.
例如，我还可以在这里添加实体。

410
00:17:28,010 --> 00:17:30,543
So I'm gonna add another entity for my Twitter User,
所以我要为我的推特用户添加另一个实体，

411
00:17:30,612 --> 00:17:32,244
this is people who tweet.
这是推特的人。

412
00:17:32,313 --> 00:17:34,112
And there it is, it called it entity again,
它又称它为实体，

413
00:17:34,181 --> 00:17:35,280
that's the default.
这是默认的。

414
00:17:35,349 --> 00:17:38,583
We'll set its name to be TwitterUser.
我们将把它的名字设为TwitterUser。

415
00:17:38,652 --> 00:17:40,986
All right, so we now have two entities, you see on there.
好的，现在我们有两个实体，在这里。

416
00:17:41,054 --> 00:17:44,289
What's kinda cool is as you drag these entities around,
很酷的是当你拖动这些实体时，

417
00:17:44,358 --> 00:17:47,191
this, this kind of editor, this graphical
这个，这个编辑器，这个图形

418
00:17:47,259 --> 00:17:49,727
editor, will automatically kind of keep them spaced apart
编辑器，会自动将它们隔开

419
00:17:49,795 --> 00:17:50,594
from each other.
从对方。

420
00:17:50,663 --> 00:17:52,595
Which is kind of fun, especially since they're going
这很有趣，特别是因为他们要去

421
00:17:52,664 --> 00:17:54,497
to start having wires connecting them because
开始连接它们，因为

422
00:17:54,566 --> 00:17:56,332
they're going to start having relationships
他们会开始谈恋爱

423
00:17:56,400 --> 00:17:59,668
to each other as you're going to see in a moment.
你们马上就能看到彼此。

424
00:17:59,737 --> 00:18:02,871
We can add attributes in this graphical style as well- you
我们也可以在这个图形风格中添加属性——你

425
00:18:02,939 --> 00:18:05,874
can edit those right in there just by double clicking on
可以通过双击来编辑这些吗

426
00:18:05,943 --> 00:18:07,809
them, change whatever you want.
他们，改变你想要的。

427
00:18:07,877 --> 00:18:11,078
So, here I got a screenName, now of course I got an error
这里我有一个截图，当然我有一个错误

428
00:18:11,147 --> 00:18:14,014
again because I didn't set the type of that screenName.
因为我没有设置那个屏幕名的类型。

429
00:18:14,083 --> 00:18:17,350
So, in this view you set the types by bringing up
在这个视图中，你设置了类型

430
00:18:17,419 --> 00:18:18,017
the inspector.
检查员。

431
00:18:18,086 --> 00:18:20,286
So you just bring up your normal inspector,
你只要把你的检查官带上来，

432
00:18:20,355 --> 00:18:21,553
attribute inspector.
属性检查器。

433
00:18:21,622 --> 00:18:23,755
And the, here you can see it's inspecting screenName,
这里你可以看到它在检查屏幕名称，

434
00:18:23,824 --> 00:18:25,357
it's got the name there.
名字就在这里。

435
00:18:25,425 --> 00:18:27,625
There's some other things in here like transient,
这里还有一些其他的东西，比如短暂的，

436
00:18:27,694 --> 00:18:28,626
indexed, optional.
索引,可选的。

437
00:18:28,694 --> 00:18:31,395
By the way, that optional doesn't mean this is optional
顺便说一下，这个可选并不意味着这是可选的

438
00:18:31,464 --> 00:18:33,664
like the Swift thing optional.
就像快速的东西是可选的。

439
00:18:33,732 --> 00:18:37,233
This is optional like in SQL database terms, right.
这在SQL数据库术语中是可选的。

440
00:18:37,302 --> 00:18:39,469
In relational database optional.
在关系数据库中可选的。

441
00:18:39,538 --> 00:18:42,004
So I'm not gonna talk about any of the database
我不会讲任何数据库

442
00:18:42,073 --> 00:18:43,539
You rarely need to set any of these properties right here.
你很少需要在这里设置这些属性。

443
00:18:43,540 --> 00:18:45,006
stuff of it.
的东西。

444
00:18:46,743 --> 00:18:47,942
But you do need to set the type.
但是您需要设置类型。

445
00:18:48,011 --> 00:18:49,143
So we're not gonna talk about that, but
所以我们不会讨论这个，但是

446
00:18:49,211 --> 00:18:51,279
we have to set the type right here.
我们必须在这里设置类型。

447
00:18:51,347 --> 00:18:53,280
And the screenName, of course, is a string.
当然，屏幕名是一个字符串。

448
00:18:53,349 --> 00:18:56,116
So I'm just gonna change it to a string.
我把它改成一个字符串。

449
00:18:56,185 --> 00:18:59,652
I'm adding another attribute to the TwitterUser,
我给TwitterUser添加了另一个属性，

450
00:18:59,721 --> 00:19:03,056
this one is the name, the person's actual name,
这个是名字，这个人的真名，

451
00:19:03,125 --> 00:19:06,458
not their @ sign handle, but their actual name.
不是他们的@符号句柄，而是他们的实际名字。

452
00:19:06,527 --> 00:19:09,327
Now we've built a couple of entities with a bunch of
现在我们已经建立了一些实体

453
00:19:09,396 --> 00:19:12,030
attributes on them, okay, and this is gonna look like
它们的属性，好的，这个看起来是这样的

454
00:19:12,099 --> 00:19:15,767
classes with vars in our code eventually.
最终在我们的代码中使用vars的类。

455
00:19:15,836 --> 00:19:19,003
But what about relationships, obviously a Tweet and
但关系呢，显然是一条推文

456
00:19:19,072 --> 00:19:22,774
a TwitterUser have a relationship to each other.
TwitterUser之间有一个关系。

457
00:19:22,842 --> 00:19:25,209
And to create relationships between things we just
并建立我们之间的关系

458
00:19:25,278 --> 00:19:28,145
Ctrl+drag, this is our favorite gesture in Xcode and
Ctrl +拖动，这是我们在Xcode中最喜欢的手势

459
00:19:28,213 --> 00:19:28,945
we're using it again.
我们再次使用它。

460
00:19:29,013 --> 00:19:31,780
Ctrl+drag to create a relationship
Ctrl +拖动来创建关系

461
00:19:31,849 --> 00:19:32,648
between two things.
两件事之间的关系。

462
00:19:32,717 --> 00:19:36,151
And it actually doesn't matter which direction you Ctrl+drag,
不管你按哪个方向拖动，

463
00:19:36,220 --> 00:19:38,820
because you're creating kind of a bidirectional
因为你在创造一种双向性

464
00:19:38,889 --> 00:19:40,388
relationship.
的关系。

465
00:19:40,457 --> 00:19:43,057
So here, I did Ctrl+drag, and it automatically created this
在这里，我按Ctrl +拖动，它自动创建了这个

466
00:19:43,126 --> 00:19:47,829
relationship, which it called newRelationship on both sides.
关系，这是双方的新关系。

467
00:19:47,897 --> 00:19:52,766
And this relationship is essentially just gonna be
这种关系本质上就是

468
00:19:52,835 --> 00:19:54,768
a var in our class.
我们班的一个var。

469
00:19:54,837 --> 00:19:59,071
But the var's type is either going to be the type, if it's
但var的类型要么是类型，如果是

470
00:19:59,140 --> 00:20:01,508
like a Tweet, you know, it's gonna be a single one, or
就像一条推特，你知道，它会是一个单一的，或者

471
00:20:01,576 --> 00:20:04,343
it could be an NSSet, if it's many of them.
它可以是NSSet，如果是很多的话。

472
00:20:04,412 --> 00:20:06,679
Like a Twitter user might have many tweets, and
就像推特用户可能有很多推文

473
00:20:06,747 --> 00:20:08,781
I'll talk about that in a moment.
我一会儿会讲到这个。

474
00:20:08,849 --> 00:20:12,383
So, from a Tweet's perspective this relationship to
所以，从推特的角度来看这段关系

475
00:20:12,452 --> 00:20:14,419
a TwitterUser is the Tweeter.
推特用户就是Tweeter。

476
00:20:14,487 --> 00:20:16,821
The person who tweeted this tweet.
推特这条推文的人。

477
00:20:16,889 --> 00:20:19,557
So, I'm going to change the name of this relationship on
所以，我要改变这段关系的名称

478
00:20:19,625 --> 00:20:24,027
the Tweet side to be tweeter instead of newRelationship,
推特侧面是tweeter而不是newRelationship，

479
00:20:24,095 --> 00:20:25,361
which was the default.
这是默认的。

480
00:20:25,430 --> 00:20:27,763
But, on the other, okay, so that's why I call it tweeter.
但另一方面，这就是为什么我把它叫做tweeter。

481
00:20:27,832 --> 00:20:29,865
On the other side the TwitterUser from its
另一边是TwitterUser

482
00:20:29,934 --> 00:20:33,502
perspective though, okay, the relationship of the tweet is
不过，这条推特的关系是

483
00:20:33,571 --> 00:20:35,737
the tweets that this Twitter user has tweeted.
推特用户在推特上发布的推文。

484
00:20:35,805 --> 00:20:38,840
Okay, it's not tweeter, the Twitter user is the tweeter,
这不是tweeter,Twitter用户是tweeter，

485
00:20:38,909 --> 00:20:41,342
so he would never call this relationship tweeter.
所以他绝不会把这种关系称为推特。

486
00:20:41,411 --> 00:20:44,277
He's gonna call this relationship tweets
他会把这种关系称为推特

487
00:20:44,346 --> 00:20:46,213
because this is the tweet.
因为这是推特。

488
00:20:46,282 --> 00:20:47,748
Now notice that's plural, okay,
注意这是复数形式，

489
00:20:47,816 --> 00:20:50,583
we'll talk about that in a second.
我们马上就会讲到。

490
00:20:50,652 --> 00:20:54,186
Notice that when we do this, Xcode tracks if I'm inspecting
注意，当我们这样做的时候，Xcode会跟踪

491
00:20:54,255 --> 00:20:57,423
the tweet's relationship there on the TwitterUser side,
在推特用户一边，这条推特的关系，

492
00:20:57,491 --> 00:20:58,858
it knows the inverse.
它知道逆。

493
00:20:58,926 --> 00:21:00,759
It knows that tweeter goes the opposite direction,
它知道推特是反方向的，

494
00:21:00,828 --> 00:21:02,828
there's always gonna be an inverse relationship.
总会有一个逆关系。

495
00:21:04,631 --> 00:21:07,264
So let's talk about that tweets being a plural right?
让我们来讨论一下，tweets是一个复数，对吧?

496
00:21:07,333 --> 00:21:10,100
So a tweet can only have one tweeter.
所以一条推特只能有一个推特。

497
00:21:10,169 --> 00:21:12,002
Only one person can have tweeted it, but
只有一个人可以在推特上发推特

498
00:21:12,070 --> 00:21:16,873
a Twitter user can tweet thousands of tweets, okay?
一个推特用户可以发布数千条推文，对吧?

499
00:21:16,942 --> 00:21:18,474
And so that's a little different
这有点不同

500
00:21:18,542 --> 00:21:19,374
kind of relationship.
类型的关系。

501
00:21:19,443 --> 00:21:21,410
So how do we specify that?
那么如何指定呢?

502
00:21:21,479 --> 00:21:24,679
We call the tweets relationship the,
我们称推特关系为，

503
00:21:24,748 --> 00:21:27,915
a to many relationship because obviously the Twitter
关系到很多关系，因为很明显Twitter

504
00:21:27,984 --> 00:21:29,951
user can have many tweets.
用户可以有很多tweet。

505
00:21:30,019 --> 00:21:32,953
So that's called to many in database parlance, and
这就叫很多数据库术语

506
00:21:33,022 --> 00:21:34,321
you set that right in the Inspector.
你把它设置在检查器里。

507
00:21:34,390 --> 00:21:36,123
So you just click on that tweets and
你只需点击这个推文就可以了

508
00:21:36,192 --> 00:21:37,690
you go over here to where it says Type,
你到它说类型的地方，

509
00:21:37,759 --> 00:21:40,927
and instead of having it be To One you're gonna change it
而不是让它变成一个你要改变它

510
00:21:40,995 --> 00:21:43,962
to be To Many, okay, so now it's a to many relationship.
对很多人来说，这是一种关系。

511
00:21:44,031 --> 00:21:49,568
Right there, you can see that it's changed a little bit as,
在这里，你可以看到它的变化有点像，

512
00:21:49,637 --> 00:21:51,336
and we'll show that in a second.
我们马上就会展示出来。

513
00:21:51,404 --> 00:21:54,339
But the type of this relationship now on the tweet
但这段关系现在在推特上

514
00:21:54,407 --> 00:21:57,909
side is still type NSManagedObject,
side仍然是NSManagedObject类型，

515
00:21:57,978 --> 00:22:00,111
because it points to another entity in the database.
因为它指向数据库中的另一个实体。

516
00:22:00,179 --> 00:22:02,279
And we know that the objects in the database
我们知道数据库中的对象

517
00:22:02,348 --> 00:22:04,081
are represented by an NSManagedObject.
由NSManagedObject表示。

518
00:22:04,150 --> 00:22:06,783
So that's gonna be the type of that var.
这就是var的类型。

519
00:22:06,851 --> 00:22:09,118
Although we're eventually gonna make it even better than
尽管我们最终会做得更好

520
00:22:09,187 --> 00:22:11,420
that, but on the other side though,
但另一方面，

521
00:22:11,488 --> 00:22:17,493
the type of that var is NSSet of NSManagedObject, okay?
var的类型是NSManagedObject的NSSet ?

522
00:22:17,562 --> 00:22:23,598
Now NSSet, there is a Swift struct called set.
现在NSSet，有一个叫做set的Swift结构。

523
00:22:23,667 --> 00:22:25,766
It's a generic type, it's just like an array where you have
它是一个泛型类型，它就像一个数组

524
00:22:25,835 --> 00:22:26,667
to say what's in an array,
要说出数组中的内容，

525
00:22:26,736 --> 00:22:29,270
same thing with a set you have to say what's in it.
同样的，你必须说出它里面有什么。

526
00:22:29,338 --> 00:22:33,240
NSSet is kind of an older Objective-C kind of set.
NSSet是一种更老的objective - c类型的集合。

527
00:22:33,309 --> 00:22:35,375
It's not generic, it's untyped.
它不是一般的，它是无类型的。

528
00:22:35,443 --> 00:22:39,212
The things in NSSet are any, which we kinda need a little
NSSet中的东西都是，我们需要一点

529
00:22:39,281 --> 00:22:42,214
bit here cuz we really don't know what kinds of things
因为我们真的不知道什么东西

530
00:22:42,283 --> 00:22:43,149
are in there.
是在那里。

531
00:22:43,217 --> 00:22:47,619
However, in your code you can cast from this NSSet
然而，在您的代码中，您可以从这个NSSet中进行转换

532
00:22:47,688 --> 00:22:51,656
of NSManagedObject to a set of what you know to be in there
NSManagedObject的一组你知道的在那里

533
00:22:51,725 --> 00:22:53,158
using as question mark, and
使用作为问号，和

534
00:22:53,226 --> 00:22:55,293
if that in fact is what's in there, it will work.
如果这实际上是在那里，它就会起作用。

535
00:22:57,296 --> 00:22:58,462
So that's the NSSet there.
这是NSSet。

536
00:22:59,664 --> 00:23:01,164
One last thing I'm gonna show you here before
最后我要向你们展示的是

537
00:23:01,233 --> 00:23:04,300
we get back to the slides is this Delete Rule.
我们回到幻灯片是这个删除规则。

538
00:23:04,369 --> 00:23:06,268
You see the delete rule on the,
你看到了删除规则，

539
00:23:06,337 --> 00:23:10,005
clicked on tweets on here so we're inspecting tweets.
点击这里的推文，我们就会检查推文。

540
00:23:10,074 --> 00:23:13,608
And this delete rule tells you what happens
这个删除规则告诉你发生了什么

541
00:23:13,677 --> 00:23:17,979
to the pointed-to tweets if we deleted this Twitter user.
如果我们删除了这个Twitter用户，就会有一个指向。

542
00:23:18,047 --> 00:23:19,880
Cuz if I delete this Twitter user,
如果我删除这个推特用户，

543
00:23:19,949 --> 00:23:23,417
does that mean I delete all of the Twitter user's tweets?
这是否意味着我删除了所有的推特用户的推文?

544
00:23:23,486 --> 00:23:26,287
Well, it depends on this delete rule right here.
这取决于这里的删除规则。

545
00:23:26,355 --> 00:23:27,821
this delete rule is saying nullify, which would mean no.
这个删除规则说的是nullify，这意味着没有。

546
00:23:27,822 --> 00:23:29,288
So right now,
现在,

547
00:23:29,358 --> 00:23:32,091
Those tweets would stay in the database, and their tweeter
这些推文将留在数据库中，以及他们的推特

548
00:23:32,160 --> 00:23:35,261
will be set to nil because their tweeter got deleted.
将被设置为nil，因为他们的tweeter被删除了。

549
00:23:35,330 --> 00:23:37,829
But there is a cascading delete rule, which would say
但是有一个级联删除规则，也就是说

550
00:23:37,898 --> 00:23:40,332
if I delete this thing then delete everything that it
如果我删除了这个东西，然后删除它

551
00:23:40,401 --> 00:23:42,367
points to, just go right down the graph and
指向，直接沿着图走

552
00:23:42,436 --> 00:23:43,434
delete everything.
删除一切。

553
00:23:43,503 --> 00:23:46,170
So that's what controls what happens when you delete.
这就是控制当你删除时发生的事情。

554
00:23:46,238 --> 00:23:48,405
Now I'm not gonna ask you to even do delete;
现在我不会要求你删除;

555
00:23:48,474 --> 00:23:51,141
I guess I might ask you an extra credit to do delete in
我想我可能会要你额外的学分来做删除

556
00:23:51,209 --> 00:23:52,141
assignment five.
作业5。

557
00:23:52,210 --> 00:23:54,744
Because deletion kinda- you're really gonna know what
因为删除，你真的会知道

558
00:23:54,812 --> 00:23:56,612
you're doing- when you can delete things, and
你在做——当你可以删除东西的时候

559
00:23:56,681 --> 00:23:58,413
what kind of delete rules you want.
你想要什么样的删除规则。

560
00:23:58,482 --> 00:24:00,215
But I just want to let you know that you specify
但我只是想让你知道你的指定

561
00:24:00,283 --> 00:24:02,317
the delete rule right here in the inspector.
删除规则在检查器中。

562
00:24:03,986 --> 00:24:07,955
Okay, now that you've defined all your entities, attributes
好的，现在你已经定义了所有的实体，属性

563
00:24:08,023 --> 00:24:11,792
in relationships, then what can we do with these things?
在人际关系中，我们能做些什么呢?

564
00:24:11,861 --> 00:24:15,462
Well to do anything with it we need to get a hold of them
为了做任何事情，我们需要掌握它们

565
00:24:15,531 --> 00:24:18,531
in our code, grab onto them basically, and
在我们的代码中，基本上抓住它们

566
00:24:18,600 --> 00:24:20,466
to do that we need another important class,
我们需要另一个重要的课程，

567
00:24:20,535 --> 00:24:23,502
NSManagedObjectContext, so I told you
NSManagedObjectContext，我告诉过你

568
00:24:23,571 --> 00:24:26,071
all those things in the database are NSManagedObjects,
数据库中的所有东西都是nsmanagedobject，

569
00:24:26,139 --> 00:24:28,206
you need an NSManagedObjectContext,
你需要一个NSManagedObjectContext,

570
00:24:28,275 --> 00:24:32,009
which represents a database to do anything with them,
它表示数据库对它们做任何事情，

571
00:24:32,078 --> 00:24:34,578
to get any of them, to create any of them, etc,
为了得到它们中的任何一个，

572
00:24:34,647 --> 00:24:37,381
this is the hub around which Core Data activity turns,
这是核心数据活动转的中心，

573
00:24:37,449 --> 00:24:38,615
as I say there.
就像我说的。

574
00:24:38,684 --> 00:24:41,185
So how do I get one of these NSManagedObjectContext?
那么如何得到NSManagedObjectContext呢?

575
00:24:41,253 --> 00:24:43,920
And the answer is, you need a persistentContainer.
答案是，你需要一个persistentContainer。

576
00:24:43,989 --> 00:24:46,623
Woo-hoo, and you know where to get one of those.
哇哦，你知道哪里可以买到。

577
00:24:46,691 --> 00:24:48,190
You just click, Use Core Data, and
你只需点击，使用核心数据，然后

578
00:24:48,259 --> 00:24:49,858
it's gonna appear in your AppDelegate.
它会出现在你的AppDelegate中。

579
00:24:49,927 --> 00:24:51,693
You're gonna get that lazy var,
你会得到那个懒惰的var，

580
00:24:51,761 --> 00:24:53,461
that's called persistentContainer.
这就叫做persistentContainer。

581
00:24:53,530 --> 00:24:55,262
And that is gonna be a persistentContainer.
这将是一个持续的容器。

582
00:24:55,331 --> 00:24:57,431
And from that you can get the context.
这样你就能得到上下文。

583
00:24:57,499 --> 00:25:00,568
Now, if you have the lazy var in your AppDelegate,
现在，如果你的AppDelegate中有一个懒惰的var，

584
00:25:00,636 --> 00:25:02,636
How the heck do you call that var?
你怎么叫那个var ?

585
00:25:02,705 --> 00:25:04,003
How do you get that var?
如何得到var ?

586
00:25:04,072 --> 00:25:05,571
And this is how you do it, okay?
这就是你的做法，明白吗?

587
00:25:05,640 --> 00:25:10,009
You get a copy of the shared UIApplication, now,
你会得到一个共享UIApplication的拷贝，

588
00:25:10,077 --> 00:25:12,678
we didn't talk about this but your app has this one and
我们没有讨论这个，但是你的应用有这个

589
00:25:12,747 --> 00:25:16,415
only UIApplication object that represents your application
只有表示应用程序的UIApplication对象

590
00:25:16,484 --> 00:25:19,784
and you get it by doing UIApplication.shared,
你通过uiapplic. shared，共享，

591
00:25:19,853 --> 00:25:20,919
it's a var.
这是一个var。

592
00:25:20,987 --> 00:25:23,887
Static var in UIApplication class.
UIApplication类中的静态var。

593
00:25:23,956 --> 00:25:24,955
Gives you the shared one.
给你一个共享的。

594
00:25:25,024 --> 00:25:28,191
Then you're gonna access this var in UIApplication which is
然后在UIApplication中访问这个var

595
00:25:28,260 --> 00:25:29,159
its delegate.
它的代表。

596
00:25:30,528 --> 00:25:32,762
Now, its delegate is automatically set up for
现在，它的委托是自动设置的

597
00:25:32,830 --> 00:25:35,597
you to be this Swift class AppDelegate that you see
你可以看到这个Swift类AppDelegate

598
00:25:35,666 --> 00:25:37,999
always; we always put it off in Supporting Files and
总是;我们总是把它放在支持文件中

599
00:25:38,068 --> 00:25:40,134
get it out of our way, but it's created for you,
把它从我们的道路上拿出来，但它是为你创造的，

600
00:25:40,203 --> 00:25:41,035
it's a nice little class.
这是一个很好的小课堂。

601
00:25:41,104 --> 00:25:43,604
We're going to talk about the application life cycle, and
我们将讨论应用程序生命周期

602
00:25:43,672 --> 00:25:46,707
where it fits in, in a little bit, but for now all
它在哪里合适，在一点上，但现在呢

603
00:25:46,776 --> 00:25:49,542
you need to know is you can get AppDelegate, and you want
你需要知道，你可以得到AppDelegate，你想要

604
00:25:49,611 --> 00:25:52,845
to send persistentContainer to it to get that var, but of
将persistentContainer发送给它以获得var，但是

605
00:25:52,914 --> 00:25:57,450
course you have to as it to be the AppDelegate class first.
当然，必须先将它作为AppDelegate类。

606
00:25:57,519 --> 00:25:58,885
So this is the code you're going to use.
这就是你要用到的代码。

607
00:25:58,953 --> 00:26:01,120
(UIApplication.shared.delegate as!

608
00:26:01,189 --> 00:26:03,956
AppDelegate) All that in one expression
(AppDelegate)在一个表达式中

609
00:26:04,024 --> 00:26:06,758
dot persistentContainer now you're gonna get this
点persistentContainer现在你会得到这个

610
00:26:06,826 --> 00:26:09,794
persistentContainer, and notice I'm doing as
坚持容器，注意我做的是

611
00:26:09,862 --> 00:26:12,863
exclamation point this will crash if my App Delegate is
感叹号如果我的应用程序委托，它会崩溃

612
00:26:12,932 --> 00:26:15,866
not in fact App Delegate, but it's already wired up
实际上不是App委托，而是已经连接起来了

613
00:26:15,934 --> 00:26:18,669
to be that for you when you create a new project,
当你创建一个新项目时，

614
00:26:18,737 --> 00:26:20,103
so that should never be a problem.
所以这绝不是一个问题。

615
00:26:21,306 --> 00:26:21,770
Okay? So
好吧?所以

616
00:26:21,839 --> 00:26:24,640
now I have this persistentContainer,
现在我有了这个persistentContainer，

617
00:26:24,709 --> 00:26:27,275
I need to get the context out of it.
我需要从它那里得到上下文。

618
00:26:27,344 --> 00:26:28,643
And, so,
所以,

619
00:26:28,712 --> 00:26:33,281
the container has an awesome var called viewContext.
容器有一个可怕的var，称为viewContext。

620
00:26:33,349 --> 00:26:36,684
And the viewContext is an NSManagedObjectContext that's
viewContext是NSManagedObjectContext

621
00:26:36,753 --> 00:26:39,620
only suitable for use on the main queue.
仅适用于主队列。

622
00:26:39,688 --> 00:26:40,520
This is in red,
这是红色的,

623
00:26:40,588 --> 00:26:42,956
you know whenever you see anything in red on my slides,
每当你看到我的幻灯片上有红色的东西，

624
00:26:43,024 --> 00:26:45,191
this means pay attention, it will matter for
这意味着要注意，这很重要

625
00:26:45,260 --> 00:26:47,960
your homework, and in life, but
你的家庭作业，还有生活

626
00:26:48,029 --> 00:26:51,029
you can only use this viewContext in the main queue,
你只能在主队列中使用这个viewContext，

627
00:26:51,098 --> 00:26:54,333
it called viewContext because you use it with your views,
它叫viewContext，因为你使用视图，

628
00:26:54,401 --> 00:26:57,869
okay, your UI views, that's why we call it viewContext.
你的UI视图，这就是为什么我们称它为viewContext。

629
00:26:59,706 --> 00:27:02,773
So why do I make a point about this main queue?
为什么我要强调这个主队列呢?

630
00:27:02,842 --> 00:27:05,809
Well, the reason I do that is because NSManagedObjectContext
我之所以这么做是因为NSManagedObjectContext

631
00:27:05,878 --> 00:27:07,744
is not thread-safe.
不是线程安全的。

632
00:27:07,813 --> 00:27:10,747
But I'm gonna talk you, talk to you about how we can do
但我要告诉你，我们该怎么做

633
00:27:10,816 --> 00:27:13,883
multithreaded database stuff towards the end of this talk.
在此演讲结束时，多线程数据库内容。

634
00:27:13,951 --> 00:27:16,552
All right, so now you have this viewContext then you can
现在有了这个viewContext

635
00:27:16,621 --> 00:27:18,020
use it to do things.
用它来做事情。

636
00:27:18,089 --> 00:27:21,690
Now, it's so
现在,就是这样的

637
00:27:21,759 --> 00:27:23,892
{UIApplication.shared.delegate as!

638
00:27:23,960 --> 00:27:26,027
Appdelegate).persistentContai- ner,
Appdelegate)。persistentContai——尼珥

639
00:27:26,096 --> 00:27:27,394
that's kind of a messy line of code.
这是一种杂乱的代码。

640
00:27:27,463 --> 00:27:30,330
There's a lot of, there's as and all these things in there.
这里有很多，还有所有这些东西。

641
00:27:30,399 --> 00:27:34,100
So at times we'll just create a static version of
有时我们会创建一个静态版本

642
00:27:34,169 --> 00:27:37,537
persistentContainer in our AppDelegate.
在我们AppDelegate persistentContainer。

643
00:27:37,606 --> 00:27:39,138
Okay, we'll just call it the same thing.
我们把它叫做同样的东西。

644
00:27:39,207 --> 00:27:41,307
persistentContainer but it's static and
持久容器，但它是静态的

645
00:27:41,376 --> 00:27:43,776
it's just gonna return that messy line of code.
它会返回那个混乱的代码行。

646
00:27:43,845 --> 00:27:46,011
So now we can get that persistentContainer with
现在我们可以得到这个持久容器

647
00:27:46,079 --> 00:27:48,747
AppDelegate.persistentContai- ner.
AppDelegate。persistentContai——尼珥。

648
00:27:48,815 --> 00:27:50,248
See what I did there?
看到我做的了吗?

649
00:27:50,317 --> 00:27:52,683
I just made it easier to get up by making that be a static,
我只是让它变得更容易一些，

650
00:27:52,752 --> 00:27:56,153
a class var, and we can do the same thing with viewContext,
一个类var，我们可以用viewContext做同样的事情，

651
00:27:56,222 --> 00:27:59,455
you might create a static called viewContext and for
您可以创建一个名为viewContext的静态文件

652
00:27:59,524 --> 00:28:02,092
the rest of these slides you can assume I've done this.
剩下的这些幻灯片你可以假设我已经做过了。

653
00:28:02,160 --> 00:28:04,793
Which is good because typing that long messy thing would
这很好，因为打字很麻烦

654
00:28:04,862 --> 00:28:07,563
make all my slides spill over the edge.
让我的幻灯片溢出来。

655
00:28:07,632 --> 00:28:09,831
So I'm gonna use this shorter version as well.
所以我也要用这个简短的版本。

656
00:28:09,900 --> 00:28:11,300
And you're welcome to create the static
你可以创建静态的

657
00:28:11,369 --> 00:28:13,201
version in your AppDelegate if you want
如果需要，可以在AppDelegate中进行版本

658
00:28:13,270 --> 00:28:14,568
to make your code a little cleaner.
为了让你的代码更简洁。

659
00:28:14,637 --> 00:28:17,104
Now this viewContext in the persistentContainer
现在这个viewContext在persistentContainer中

660
00:28:17,173 --> 00:28:18,456
There's one of them that represents your entire
其中一个代表你的整个

661
00:28:18,457 --> 00:28:19,740
are shared.
是共享的。

662
00:28:19,808 --> 00:28:20,573
database.
数据库。

663
00:28:20,642 --> 00:28:22,709
So it's perfectly fine to create a single static
所以创建一个静态的完全没问题

664
00:28:22,777 --> 00:28:23,643
that does this.
做这个。

665
00:28:23,711 --> 00:28:26,178
By the way, what if you wanted multiple databases?
顺便说一下，如果你想要多个数据库呢?

666
00:28:26,246 --> 00:28:27,679
You could even have multiple databases with
甚至可以有多个数据库

667
00:28:27,748 --> 00:28:29,180
different schema.
不同的模式。

668
00:28:29,249 --> 00:28:31,316
Very easy, if you go look at the code for
很简单，如果你看一下代码

669
00:28:31,384 --> 00:28:34,819
persistentContainer in AppDelegate,
persistentContainer AppDelegate,

670
00:28:34,887 --> 00:28:37,087
you'll see it's only like four lines of code.
你会看到它只有四行代码。

671
00:28:37,156 --> 00:28:39,289
And you could just copy it to create a different
你可以复制它来创建一个不同的

672
00:28:39,358 --> 00:28:42,759
persistentContainer using a different xcmodeld file.
使用不同的xcmodeld文件的persistentContainer。

673
00:28:42,828 --> 00:28:45,295
Instead of using model according to the example,
而不是根据这个例子使用模型，

674
00:28:45,363 --> 00:28:46,828
create another one with a different one and
用不同的方法创建另一个

675
00:28:46,897 --> 00:28:50,399
you can just go file, new file and create another data model.
你可以点击文件，新建文件，创建另一个数据模型。

676
00:28:50,468 --> 00:28:54,403
You could even create two persistent containers with
您甚至可以创建两个持久性容器

677
00:28:54,471 --> 00:28:55,904
the same model.
相同的模型。

678
00:28:55,973 --> 00:28:58,006
So they would be separate databases, but
所以它们是单独的数据库，但是

679
00:28:58,074 --> 00:28:59,640
have the same model, the same entities to that and
有相同的模型，相同的实体吗

680
00:28:59,709 --> 00:29:00,674
the same relationship to that.
同样的关系。

681
00:29:00,743 --> 00:29:02,309
It's perfectly allowed as well.
这也是完全允许的。

682
00:29:02,377 --> 00:29:04,243
But for everything you're going to do in this class, and
但对于你在这门课上要做的所有事情

683
00:29:04,312 --> 00:29:05,444
for really with most apps,
对于大多数应用来说，

684
00:29:05,513 --> 00:29:08,046
you're going to have one big database.
你将会有一个大数据库。

685
00:29:08,115 --> 00:29:10,582
And you're going to have this one persistent container that
你将会有一个持久的容器

686
00:29:10,651 --> 00:29:12,384
is the container for it.
是它的容器。

687
00:29:12,452 --> 00:29:14,452
All right.
好吧。

688
00:29:14,521 --> 00:29:18,055
So now I have a context in my hand, this viewContext.
现在我有了一个context在我的手里，这个viewContext。

689
00:29:18,124 --> 00:29:19,023
And what can I do?
我该怎么办呢?

690
00:29:19,091 --> 00:29:21,391
Well, of course, I can insert objects into the database.
当然，我可以将对象插入数据库。

691
00:29:21,460 --> 00:29:23,227
I can delete objects from the database.
我可以从数据库中删除对象。

692
00:29:23,295 --> 00:29:25,361
And I can query for objects in the database.
我可以查询数据库中的对象。

693
00:29:25,430 --> 00:29:26,662
So, let's talk about all those things.
那么，让我们来谈谈这些事情。

694
00:29:26,731 --> 00:29:29,765
Let's start with insert because until we insert some
让我们从插入开始，因为在插入一些之前

695
00:29:29,834 --> 00:29:32,267
data in the database we can't do any of those other things.
数据库中的数据我们不能做其他的事情。

696
00:29:32,336 --> 00:29:35,136
And the way you insert an object in the database, or
以及在数据库中插入对象的方式

697
00:29:35,205 --> 00:29:36,538
a way to do it, and actually for
一种方法，实际上是为了

698
00:29:36,607 --> 00:29:39,107
the next few slide I'm going to kind of show you the,
接下来的几张幻灯片，我将向你们展示，

699
00:29:39,175 --> 00:29:40,741
the essentials.
的必需品。

700
00:29:40,810 --> 00:29:43,843
But, we're eventually going to move up to a high level and
但是，我们最终会达到一个高水平

701
00:29:43,912 --> 00:29:46,479
access this stuff in a much nicer way.
以一种更好的方式访问这些东西。

702
00:29:46,548 --> 00:29:48,414
But I'll tell you the basics of it first.
但我会先告诉你它的基本原理。

703
00:29:48,483 --> 00:29:51,117
So the basic way to put something in the database is
所以在数据库中放置东西的基本方法是

704
00:29:51,186 --> 00:29:53,252
with this really interesting method.
有了这个很有趣的方法。

705
00:29:53,321 --> 00:29:57,923
NSEntityDescription.insertNew- Object(forEntityName: into:
NSEntityDescription。insertNew对象(forEntityName:到:

706
00:29:57,991 --> 00:29:59,624
context).
上下文)。

707
00:29:59,693 --> 00:30:02,260
Okay, that's a mouthful, used to be even more of a mouthful
好吧，这是一口，原来是一口

708
00:30:02,329 --> 00:30:04,128
before they renamed it.
之前重命名它。

709
00:30:04,197 --> 00:30:08,366
And you just specify the name of the entity, so
你只需指定实体的名称

710
00:30:08,434 --> 00:30:09,933
Tweet or TwitterUser.
推特或TwitterUser。

711
00:30:10,002 --> 00:30:12,435
And you give it a context that is gonna be the viewContext
你给它一个context它将是viewContext

712
00:30:12,504 --> 00:30:13,570
you got from the AppDelegate.
你从AppDelegate得到。

713
00:30:13,639 --> 00:30:15,871
And boom, it's gonna create one of these in the database.
它会在数据库中创建一个。

714
00:30:15,940 --> 00:30:19,708
Now all of its attributes will be nil.
它的所有属性都是nil。

715
00:30:19,777 --> 00:30:21,810
Okay, although you can inspect the attributes in
虽然你可以检查属性

716
00:30:21,879 --> 00:30:24,313
the data model editor and specify default value.
数据模型编辑器并指定默认值。

717
00:30:24,381 --> 00:30:26,848
And so it might start out with the default value.
它可能以默认值开始。

718
00:30:26,917 --> 00:30:30,785
But if it doesn't, then they'll start out as nil.
但如果它没有，那么它们将以nil开始。

719
00:30:30,853 --> 00:30:34,055
Okay, so that's great.
好了,这很好。

720
00:30:34,123 --> 00:30:36,323
I can now create one.
我现在可以创建一个。

721
00:30:36,392 --> 00:30:40,460
And now I need to set those vars to have some value.
现在我需要设置这些vars有一些值。

722
00:30:40,529 --> 00:30:43,496
I need to set the text of the tweet and things like that and
我需要设置推文的文本和类似的东西

723
00:30:43,565 --> 00:30:46,465
I told you I'm gonna do this with value for key and
我告诉过你我要用valueforkey和

724
00:30:46,534 --> 00:30:48,867
set value for key.
为关键的设置值。

725
00:30:48,936 --> 00:30:53,872
So for example I wanted to set the let's say the text,
例如，我想设置文本，

726
00:30:53,941 --> 00:30:56,074
I could just say tweet.
我只能说推特。

727
00:30:56,143 --> 00:31:00,212
A set value for key quote text, to be a string.
一个键值文本的集合值，作为字符串。

728
00:31:03,817 --> 00:31:06,117
And you can do dot notation here, with value for key path.
你可以在这里做点标记，用valueforkeypath。

729
00:31:06,186 --> 00:31:08,318
That's what I'm showing in green right there.
这就是我用绿色表示的。

730
00:31:08,387 --> 00:31:10,754
You can have, if you had a tweet you can actually set
如果你有一条推特，你可以设置

731
00:31:10,823 --> 00:31:15,325
the tweet's tweeter's name, using this dot notation to set
推特的推特的名字，用这个点符号来设置

732
00:31:15,394 --> 00:31:17,761
value for key path tweeter dot name and it would go through
valueforkeypath tweeter dot name，它会通过

733
00:31:17,829 --> 00:31:20,696
the tweeter relationship which is kinda fun.
tweeter的关系很有趣。

734
00:31:20,765 --> 00:31:23,198
I'm kinda going fast through this because this is a really
我讲得有点快，因为这是真的

735
00:31:23,267 --> 00:31:25,333
terrible API.
可怕的API。

736
00:31:25,402 --> 00:31:27,502
First of all it's got any in there so
首先它里面有任何东西

737
00:31:27,571 --> 00:31:30,070
there's not type checking going on here, okay?
这里没有类型检查，明白吗?

738
00:31:30,139 --> 00:31:37,311
You could say, set value date for key quote text, all right?
你可以说，为关键引号文本设置值日期?

739
00:31:37,380 --> 00:31:39,480
And that would be perfectly accepted by Swift.
这将会被斯威夫特完全接受。

740
00:31:39,549 --> 00:31:43,617
Date is an Any and quote text is a String, but
日期是一个Any，引用文本是字符串，但是

741
00:31:43,685 --> 00:31:46,452
of course that's gonna fail miserably at run time, okay,
当然，这在运行时会失败，

742
00:31:46,521 --> 00:31:48,087
because the text is a Atring.
因为文本是一个Atring。

743
00:31:48,155 --> 00:31:50,822
So we're not really gonna use this API but this is
所以我们不会使用这个API，但这是

744
00:31:50,891 --> 00:31:55,561
the underlying basic way that Core Data is doing this.
核心数据的基本方式是这样的。

745
00:31:55,629 --> 00:31:57,695
Yes the key is just the name of the attribute, and
是的，关键是属性的名称，以及

746
00:31:57,764 --> 00:32:00,732
the value is all the things we've talked about before.
这个值就是我们之前讨论过的所有东西。

747
00:32:02,769 --> 00:32:04,769
I do have the blue Use Scalar Type there which
我有蓝色的使用标量类型

748
00:32:04,837 --> 00:32:05,536
is interesting.
很有趣。

749
00:32:05,604 --> 00:32:09,839
If the thing you're putting in the database is a flow or
如果你在数据库中输入的东西是流或

750
00:32:09,908 --> 00:32:12,575
an Int32 or one of these things.
一个Int32或其中一个。

751
00:32:12,644 --> 00:32:15,678
It's actually gonna be stored in a database as an NSNumber,
它实际上会被存储在数据库中作为NSNumber，

752
00:32:15,747 --> 00:32:16,879
which is a class,
这是一个类,

753
00:32:16,947 --> 00:32:20,515
it's an object, kind of generic holder of numbers.
它是一个对象，是数字的一般持有者。

754
00:32:20,584 --> 00:32:25,320
But if you flip on the switch in the inspector in your data
但如果你在数据中打开检查器的开关

755
00:32:25,389 --> 00:32:28,689
modeller for that attribute saying use a scalar type,
该属性的modeller使用标量类型，

756
00:32:28,758 --> 00:32:32,360
then it'll make the type be double or int or whatever,
然后它会使类型为double或int等等，

757
00:32:32,429 --> 00:32:33,394
instead of NSNumber, so.
而不是NSNumber,所以。

758
00:32:33,463 --> 00:32:35,596
I know, you had a question?
我知道，你有问题吗?

759
00:32:35,664 --> 00:32:38,298
>> Yes, so the question is, does set value reject

760
00:32:38,367 --> 00:32:39,799
something where the types don't match?
某些类型不匹配的东西?

761
00:32:39,868 --> 00:32:41,434
And the answer is, it can't.
答案是，它不能。

762
00:32:41,502 --> 00:32:43,702
It doesn't know the type, the types are any,
它不知道类型，类型是any，

763
00:32:43,771 --> 00:32:46,138
as long as it matches any- and everything matches any.
只要它匹配任何东西，任何东西都匹配。

764
00:32:46,207 --> 00:32:47,939
So, it can't.
所以,它不能。

765
00:32:48,008 --> 00:32:52,577
There's no way for it to have enough information to reject.
没有足够的信息来拒绝。

766
00:32:52,645 --> 00:32:55,079
As long as it matches any, it'll accept that as the type.
只要它匹配任何，它就会接受它作为类型。

767
00:32:55,147 --> 00:32:56,447
And then at runtime, it will crash.
然后在运行时，它会崩溃。

768
00:32:56,515 --> 00:32:59,216
If you try to set a date to be into a string field.
如果您尝试将日期设置为字符串字段。

769
00:32:59,285 --> 00:33:03,553
>> So when it's like [INAUDIBLE]

770
00:33:03,622 --> 00:33:06,856
save context,
拯救环境,

771
00:33:06,925 --> 00:33:09,125
do you have to like make it go through.
你必须喜欢让它通过吗?

772
00:33:09,193 --> 00:33:10,293
Or is it. >> Go and remove.
还是。> >去删除。

773
00:33:10,361 --> 00:33:11,660
>> [CROSSTALK] >> What do you

774
00:33:11,728 --> 00:33:12,794
mean go and remove it?
意思是去把它拿走?

775
00:33:12,863 --> 00:33:13,428
Remove what?
删除什么?

776
00:33:21,971 --> 00:33:23,604
Yeah, we'll talk about saving in this.
是的，我们会谈到储蓄。

777
00:33:23,673 --> 00:33:24,638
So, the question is,
所以,问题是,

778
00:33:24,707 --> 00:33:26,773
when the app terminates it does save context and
当应用程序终止时，它可以保存上下文

779
00:33:26,842 --> 00:33:29,609
they're trying to save this, we'll talk all about saving in
他们想挽救这个，我们来谈谈储蓄

780
00:33:29,677 --> 00:33:31,944
a minute cause that's an important piece of this.
一分钟的原因，这是很重要的一点。

781
00:33:32,013 --> 00:33:35,247
That's the keys and values, pretty straightforward there;
这是键和值，很简单;

782
00:33:35,316 --> 00:33:38,150
in fact we're going to talk about saving right now.
事实上，我们现在要讲的是储蓄。

783
00:33:38,218 --> 00:33:39,885
We do a nice lead in.
我们做得很好。

784
00:33:39,953 --> 00:33:43,020
All these changes that you make with that set value even
所有这些变化都是用这个集合的值来做的

785
00:33:43,089 --> 00:33:45,123
insert entity description for
插入实体描述

786
00:33:45,191 --> 00:33:48,125
entity name context whatever that thing is called.
实体名称上下文，不管叫什么东西。

787
00:33:48,194 --> 00:33:50,728
All that stuff only happens in memory,
所有这些只发生在记忆中，

788
00:33:50,796 --> 00:33:53,796
if you want that to actually happen permanently in
如果你想让它永久地发生

789
00:33:53,865 --> 00:33:55,998
the database you need to save it.
您需要保存它的数据库。

790
00:33:56,067 --> 00:33:58,233
And you do that by telling the context,
你这样做的前提是，

791
00:33:58,302 --> 00:34:01,370
like that view context thing, to save with the method save.
像这样的视图上下文，用方法保存。

792
00:34:01,438 --> 00:34:04,240
It couldn't be simpler, except that it can throw.
它不可能更简单，除了它可以扔。

793
00:34:05,910 --> 00:34:07,842
Save is a method that can throw because
Save是一种可以抛出的方法

794
00:34:07,911 --> 00:34:10,144
maybe there's a problem writing out to the database.
可能有一个问题写到数据库。

795
00:34:10,213 --> 00:34:12,880
And there's many problems that could happen writing
还有很多问题可能会发生

796
00:34:12,949 --> 00:34:14,448
out to the database.
到数据库。

797
00:34:14,517 --> 00:34:15,882
And you need to look at documentation and
你需要看看文档和

798
00:34:15,951 --> 00:34:17,783
kind of figure out what they all are.
弄清楚它们都是什么。

799
00:34:17,852 --> 00:34:20,687
But the take home message here is you do need to save.
但这里要传达的信息是，你需要保存。

800
00:34:20,755 --> 00:34:23,189
If you don't save, that substance is gonna be lost
如果你不存，那东西就会丢失

801
00:34:23,257 --> 00:34:25,324
when your app exists or whatever.
当你的应用程序存在时。

802
00:34:25,393 --> 00:34:26,558
So you definitely just save.
所以你一定要保存。

803
00:34:26,627 --> 00:34:29,627
And especially when talking about multithreaded Core Data.
特别是在讨论多线程核心数据时。

804
00:34:29,696 --> 00:34:30,928
And one thread is working.
一个线程在工作。

805
00:34:30,997 --> 00:34:33,531
That thread needs to save if it wants any of the other
如果线程想要另一个线程，则需要保存它

806
00:34:33,600 --> 00:34:36,066
threads to see the work that it's done.
线程来查看它完成的工作。

807
00:34:36,135 --> 00:34:40,370
Okay, so you can use try question mark here, remember,
你可以在这里用问号，记住，

808
00:34:40,439 --> 00:34:41,604
which means try and
这意味着试着

809
00:34:41,673 --> 00:34:44,807
if it fails, just return nil and ignore it.
如果失败，则返回nil并忽略它。

810
00:34:44,875 --> 00:34:48,310
You can do that, if you don't mind that it didn't save.
如果你不介意的话，你可以这么做。

811
00:34:48,379 --> 00:34:50,946
And the kinda things that can happen, saving errors.
还有一些可能发生的事情，比如保存错误。

812
00:34:51,015 --> 00:34:53,248
You could obviously have file system problems,
你可能会遇到文件系统问题，

813
00:34:53,317 --> 00:34:55,617
your disk is full or something like that.
你的磁盘已经满了，或者类似的东西。

814
00:34:55,686 --> 00:34:57,919
But you can also have inconsistencies in
但你也可以有不一致的地方

815
00:34:57,988 --> 00:35:01,121
the database, maybe you had conflicting
数据库，也许你有冲突

816
00:35:01,190 --> 00:35:04,291
data of two threads trying to save to the same database, and
两个线程试图保存到同一个数据库的数据

817
00:35:04,359 --> 00:35:06,126
they've tried to write over the top of each other,
他们试着互相写，

818
00:35:06,194 --> 00:35:08,261
those kind of things.
这样的事情。

819
00:35:08,330 --> 00:35:10,496
Again, a lot of those problems you're not gonna have,
这些问题很多都没有，

820
00:35:10,565 --> 00:35:12,365
unless you build a pretty complicated,
除非你建立一个相当复杂的，

821
00:35:12,433 --> 00:35:14,733
multithreaded application, or something like that,
多线程应用程序，或者类似的东西，

822
00:35:14,802 --> 00:35:17,335
but, again, you gotta check the documentation, I couldn't,
但是，你必须检查文档，

823
00:35:17,404 --> 00:35:19,971
it would take too long for me to go through all of it.
我要花很长时间才能完成所有的工作。

824
00:35:21,441 --> 00:35:25,776
Okay now, as I said value forKey and setValue forKey.
现在，正如我所说的值forKey和setValue forKey。

825
00:35:25,845 --> 00:35:29,713
Really ugly,
真的很丑,

826
00:35:29,782 --> 00:35:32,483
What we really want to do is be able to set these vars
我们真正想做的是能够设置这些vars

827
00:35:32,551 --> 00:35:35,685
as vars, we just wanna have a var called text
作为vars，我们只需要一个名为text的var

828
00:35:35,754 --> 00:35:37,487
somewhere that we can set.
我们可以在某个地方设置。

829
00:35:37,556 --> 00:35:39,521
And of course we're exactly going to do that.
当然，我们会这样做。

830
00:35:39,590 --> 00:35:42,791
And the way we're going to do that is create a subclass of
我们要做的就是创建一个子类

831
00:35:42,860 --> 00:35:45,561
NSManagedObject, instead of having NSManagedObject in
NSManagedObject，而不是NSManagedObject

832
00:35:45,629 --> 00:35:47,295
the database we doing set-value, get-value on it.
我们做的数据库设置值，在它上面的值。

833
00:35:47,364 --> 00:35:51,465
Instead we're going to create a subclass of NSManageObjects
相反，我们将创建NSManageObjects的子类

834
00:35:51,534 --> 00:35:54,635
and it's going to have vars on there for all the attributes,
它的所有属性都是vars，

835
00:35:54,704 --> 00:35:57,971
like text, and screen name and all those things.
比如文本，屏幕名称等等。

836
00:35:58,040 --> 00:36:00,307
And Xcode will generate all that code for
Xcode会生成所有的代码

837
00:36:00,375 --> 00:36:01,208
you behind the scenes,
你在幕后,

838
00:36:01,276 --> 00:36:03,676
you don't have to do any work to make that happen.
你不需要做任何工作来实现这一点。

839
00:36:03,744 --> 00:36:05,811
Quite quite simple, so let's look and see how we do that.
很简单，让我们看看怎么做。

840
00:36:05,880 --> 00:36:09,280
You do that by inspecting the entity.
你通过检查实体来做到这一点。

841
00:36:09,349 --> 00:36:11,083
So here I've chosen tweet.
这里我选择了tweet。

842
00:36:11,151 --> 00:36:12,316
Okay, not any of its attributes but
好的，不是它的任何属性，而是

843
00:36:12,385 --> 00:36:15,786
tweet itself, and I want to make it so
推特本身，我想这样做

844
00:36:15,855 --> 00:36:17,988
it generates this magic code, and how do I do that?
它产生了这个神奇的代码，我该怎么做呢?

845
00:36:18,057 --> 00:36:20,857
Well, if you go down on the inspector
好吧，如果你去找探长

846
00:36:20,926 --> 00:36:23,260
a little ways you see it says Codegen.
你看到的一些方法，它说的是Codegen。

847
00:36:23,329 --> 00:36:24,760
See that Codegen, that's for
看那个Codegen，它是for

848
00:36:24,829 --> 00:36:26,729
generating this code, this magic code.
生成这个代码，这个神奇的代码。

849
00:36:26,797 --> 00:36:29,198
Now, you actually have a couple of choices here for
现在，你有几个选择

850
00:36:29,267 --> 00:36:30,299
the Codegen.
Codegen。

851
00:36:30,367 --> 00:36:33,769
The default I believe is this one Class Definition.
默认情况下，我认为这是一个类定义。

852
00:36:33,837 --> 00:36:36,837
If you choose this one it will generate that subclass for
如果你选择这个，它会生成那个子类

853
00:36:36,906 --> 00:36:38,873
you and it will just work.
你和它只会工作。

854
00:36:38,942 --> 00:36:41,809
Okay, you'll be able to access your tweets as a class
你可以把你的推文作为一个类来访问

855
00:36:41,878 --> 00:36:42,543
called tweet.
称为tweet。

856
00:36:42,612 --> 00:36:44,744
With all the vars.
var。

857
00:36:44,813 --> 00:36:46,312
Now this sounds good and
这听起来不错

858
00:36:46,381 --> 00:36:49,215
it is good; by the way if you do this class definition
它是好的;如果你做这个类定义

859
00:36:49,284 --> 00:36:52,251
codegen it will not show up in your navigator.
它不会出现在你的导航器里。

860
00:36:52,320 --> 00:36:54,686
It's all behind the scenes- you never really see this file
这都是幕后的事情——你从来没有真正看到过这个文件

861
00:36:54,755 --> 00:36:58,290
that is, this codegen file that generates.
这就是生成的codegen文件。

862
00:36:58,359 --> 00:36:59,024
So don't look for
所以不要找

863
00:36:59,092 --> 00:37:00,792
it there if you put this on class definition.
如果你把这个放在类定义上。

864
00:37:00,861 --> 00:37:02,393
This might even be the default actually.
这实际上可能是默认的。

865
00:37:02,461 --> 00:37:04,028
To be Class Definition might be on.
可以定义为类定义。

866
00:37:05,063 --> 00:37:07,030
But there's other choices in here.
但这里还有其他选择。

867
00:37:07,099 --> 00:37:11,200
And the one we choose the most often is Category/Extension.
我们最常选择的是Category / Extension。

868
00:37:11,269 --> 00:37:15,271
By the way, category just is the Objective-C word for
顺便说一下，category仅仅是objective - c的意思

869
00:37:15,339 --> 00:37:16,805
extension.
扩展。

870
00:37:16,874 --> 00:37:20,008
Objective-C has something like extensions called categories.
objective - c有类似于扩展的类别。

871
00:37:20,077 --> 00:37:21,809
So that's why it says Category/Extension.
这就是Category /扩展名的原因。

872
00:37:21,878 --> 00:37:24,845
But you can think in your mind that this just says extension.
但你可以在你的脑海中思考这只是说延伸。

873
00:37:24,914 --> 00:37:28,215
And what this is gonna do is only generate an extension
它只会生成一个扩展

874
00:37:28,284 --> 00:37:30,017
of your Tweet class.
你的推文类。

875
00:37:30,085 --> 00:37:32,852
You have to actually write the Tweet class itself.
你必须自己写推文类。

876
00:37:32,921 --> 00:37:35,121
But it's all gonna have only your code in it, or
但它只会有你的代码，或者

877
00:37:35,190 --> 00:37:36,989
it could be empty if you want.
如果你愿意，它可能是空的。

878
00:37:37,058 --> 00:37:40,325
The extension's gonna take care of all making the vars.
扩展会负责所有制作vars的工作。

879
00:37:40,394 --> 00:37:42,061
Okay, the var magic right there.
这里的var魔法。

880
00:37:43,497 --> 00:37:47,165
So let's see how this works.
我们来看看它是如何工作的。

881
00:37:47,234 --> 00:37:48,933
Even when I switch to Category/Extension.
甚至当我切换到Category /扩展时。

882
00:37:49,002 --> 00:37:51,268
Again, I don't get that extension showing up in
再一次，我没有得到这个扩展

883
00:37:51,337 --> 00:37:52,035
my navigator.
我的导航器。

884
00:37:52,104 --> 00:37:54,838
It's kind of hidden from you.
这是隐藏的。

885
00:37:54,907 --> 00:37:57,674
Here I'm gonna add the extension way of doing it for
这里我要添加一个扩展的方法

886
00:37:57,742 --> 00:37:58,507
TwitterUser too.
TwitterUser。

887
00:37:58,576 --> 00:38:01,176
So both of them, both Tweet and TwitterUser, I'm gonna
所以他们都是推特和推特用户，我要

888
00:38:01,245 --> 00:38:07,182
have an extension generated and, why do we like this one?
有一个扩展生成，为什么我们喜欢这个?

889
00:38:07,251 --> 00:38:08,917
Because, a lot of times for
因为，很多时候

890
00:38:08,986 --> 00:38:11,520
our Tweet or TwitterUser we want to add our own code.
我们的Tweet或TwitterUser我们想添加我们自己的代码。

891
00:38:13,222 --> 00:38:14,021
Like in a tweet.
就像在一条微博。

892
00:38:14,089 --> 00:38:18,859
Imagine you wanted to add a static method that took data
假设您想添加一个静态方法，以获取数据

893
00:38:18,927 --> 00:38:22,595
from Twitter and turned it into a tweet in the database.
从推特(Twitter)到数据库的一条推文。

894
00:38:22,664 --> 00:38:23,930
Where would you put that code?
你会把代码放在哪里?

895
00:38:23,998 --> 00:38:26,498
Well, a great place to put it would be in a tweet class,
好吧，一个很好的地方是在推特上，

896
00:38:26,567 --> 00:38:27,699
if there was such a thing.
如果有这样的事。

897
00:38:27,768 --> 00:38:30,502
And so, you're in fact, going to create such a thing.
所以，事实上，你会创造出这样的东西。

898
00:38:30,571 --> 00:38:33,772
And the extension is going to handle all of the var business
扩展将处理所有的var业务

899
00:38:33,841 --> 00:38:34,705
for you.
给你。

900
00:38:34,774 --> 00:38:37,708
If you did choose Manual/None, right here for Codegen,
如果你选择了Manual / None，就在这里for Codegen，

901
00:38:37,777 --> 00:38:40,544
meaning don't do any Codegen, then you're doing value for
意思是不要做任何代码，然后你就可以做了

902
00:38:40,613 --> 00:38:41,445
set value for key.
为关键的设置值。

903
00:38:43,081 --> 00:38:45,682
Good luck with that, the code's gonna be a mess, okay?
祝你好运，代码会一团糟，明白吗?

904
00:38:45,750 --> 00:38:48,284
So, we almost always do it this way with this extension.
我们通常用这种方法来做这个扩展。

905
00:38:49,654 --> 00:38:52,721
Also, if we build our app using multiple modules
另外，如果我们使用多个模块构建我们的应用程序

906
00:38:52,789 --> 00:38:55,523
like we have in Smash Tag, we have a framework module and
就像在Smash标签中一样，我们有一个框架模块

907
00:38:55,592 --> 00:38:57,158
then we have the main module.
然后我们有主模块。

908
00:38:57,227 --> 00:38:58,926
Then you're probably gonna wanna choose
然后你可能会选择

909
00:38:58,995 --> 00:39:01,228
from this pull-down here where it says module,
从这个下拉，到模块，

910
00:39:01,297 --> 00:39:03,230
current product module.
当前的产品模块。

911
00:39:03,299 --> 00:39:06,467
I think if you have a single app that's not modularized
我想如果你有一个没有模块化的应用

912
00:39:06,535 --> 00:39:10,470
like that you probably don't need to set that, but
你可能不需要设置它，但是

913
00:39:10,539 --> 00:39:14,707
in a multi-modual app you probably do want to.
在一个你可能想要的多功能应用程序中。

914
00:39:14,776 --> 00:39:18,577
So, since we've chosen here to create only the extension,
既然我们选择在这里创建扩展，

915
00:39:18,646 --> 00:39:22,080
we obviously need to write the code for the classes Tweet And
显然，我们需要为类Tweet编写代码

916
00:39:22,149 --> 00:39:25,017
TwitterUser, we have to create those classes ourselves.
TwitterUser，我们必须自己创建这些类。

917
00:39:25,085 --> 00:39:26,551
So how do we do that?
怎么做呢?

918
00:39:26,619 --> 00:39:28,419
Well, just like we create anything,
就像我们创造任何东西一样，

919
00:39:28,487 --> 00:39:30,220
we use file, new file.
我们使用文件，新文件。

920
00:39:30,289 --> 00:39:32,256
Then we do file, new file, this time we are back
然后我们做文件，新文件，这次我们回来了

921
00:39:32,325 --> 00:39:35,559
to saying it's a cocoa touch class because NSManageObject.
说它是一个cocoa触摸类，因为NSManageObject。

922
00:39:35,628 --> 00:39:37,660
Why is it code called cocoa touch class,
为什么它被称为cocoa touch类，

923
00:39:37,729 --> 00:39:40,229
we wanna make sure we set our super class to be in its
我们要确保我们的超类在它的

924
00:39:40,297 --> 00:39:42,030
managed object, right?
管理对象,对吧?

925
00:39:42,099 --> 00:39:43,665
So, I'm creating a class called Tweet,
我正在创建一个名为Tweet的类，

926
00:39:43,734 --> 00:39:46,701
you see, which is a subclass of NSManagedObject.
你看，这是NSManagedObject的子类。

927
00:39:46,770 --> 00:39:48,436
And is gonna create this for us.
然后为我们创建这个。

928
00:39:48,504 --> 00:39:51,539
See? Class Tweet: NSManagedObject.
看到了吗?类微博:NSManagedObject。

929
00:39:51,608 --> 00:39:52,706
No code in there.
没有代码。

930
00:39:52,775 --> 00:39:56,043
That space is for us, we get write anything we want.
这个空间是给我们的，我们可以写任何我们想要的东西。

931
00:39:56,112 --> 00:39:58,778
The code that does the vars is in that extension which we
做vars的代码在这个扩展中

932
00:39:58,847 --> 00:39:59,746
don't even see, but but
看不见，但是

933
00:39:59,815 --> 00:40:02,082
I'm gonna show it to yo in a second here.
我要在这里展示给你看。

934
00:40:04,785 --> 00:40:07,452
Notice that I picked the name of this class Tweet
注意，我选择了这个类Tweet的名称

935
00:40:07,521 --> 00:40:09,888
to be the same as the name of the entity in the database,
与数据库中的实体名称相同，

936
00:40:09,956 --> 00:40:12,290
which, you want to do.
你想做什么。

937
00:40:12,359 --> 00:40:16,027
It is possible to not do that by inspecting the entity
通过检查实体，不可能做到这一点

938
00:40:16,096 --> 00:40:18,229
in the data model, but, don't do it.
在数据模型中，但是，不要这样做。

939
00:40:18,298 --> 00:40:20,231
Just have the entity with the same name.
只有具有相同名称的实体。

940
00:40:20,299 --> 00:40:22,699
People reading your code are going to expect this class,
阅读你的代码的人会期待这门课，

941
00:40:22,768 --> 00:40:24,400
this subclass of NSManageObject that
NSManageObject的子类

942
00:40:24,469 --> 00:40:25,602
represents a tweet.
代表一个tweet。

943
00:40:25,670 --> 00:40:28,371
Entity to be called tweet, so called it that.
实体被称为tweet，因此被称为tweet。

944
00:40:30,441 --> 00:40:33,708
Now, we've got an error here, I'll just created this class,
这里有一个错误，我创建这个类，

945
00:40:33,777 --> 00:40:34,976
how I'm gonna possibly have an error,
我可能会有一个错误，

946
00:40:35,045 --> 00:40:36,944
I'm done anything how could I've done anything wrong?
我做错了什么事?

947
00:40:37,013 --> 00:40:38,379
Well, the problem the problem here is,
问题是，

948
00:40:38,448 --> 00:40:41,081
really, Xcode has done something wrong.
真的，Xcode做错了什么。

949
00:40:41,150 --> 00:40:45,685
When Xcode created this, it didn't seem to realize that
当Xcode创建这个的时候，它似乎并没有意识到这一点

950
00:40:45,754 --> 00:40:47,687
NSManageObject is not in UIKit.
NSManageObject不是在UIKit中。

951
00:40:47,756 --> 00:40:50,790
You see how it put import UIKit at the top?
你看到它如何在顶部导入UIKit了吗?

952
00:40:50,859 --> 00:40:54,593
Really, what we need there is import CoreData, okay.
实际上，我们需要导入CoreData。

953
00:40:54,662 --> 00:40:55,761
All the code that you write,
你写的所有代码，

954
00:40:55,829 --> 00:40:57,129
any time you're doing something in CoreData,
任何时候你在CoreData做什么，

955
00:40:57,198 --> 00:40:58,997
you have to import CoreData.
您必须导入CoreData。

956
00:40:59,065 --> 00:41:01,032
It's a different framework that the UIKit so
这是一个不同的框架，UIKit

957
00:41:01,101 --> 00:41:02,934
you must import it everywhere that you're going to use it.
你必须把它导入到你将要使用的地方。

958
00:41:03,002 --> 00:41:05,235
Just like we had to import Twitter everywhere we want to
就像我们必须在任何地方进口Twitter一样

959
00:41:05,304 --> 00:41:06,937
use that Twitter framework that I gave you.
使用我给你的Twitter框架。

960
00:41:08,507 --> 00:41:09,906
So, I don't know why Xcode, I think it's just an oversight
所以，我不知道为什么Xcode，我认为这只是一个疏忽

961
00:41:09,907 --> 00:41:11,306
Okay?
好吧?

962
00:41:11,376 --> 00:41:13,842
that Xcode when you choose NSManagedObject
当你选择NSManagedObject时，这个Xcode

963
00:41:13,911 --> 00:41:15,944
as your super class you should know, that's in Core Data so
作为你的超类，你应该知道，这是核心数据

964
00:41:16,013 --> 00:41:17,546
it should be import Core Data there.
应该在那里导入核心数据。

965
00:41:17,614 --> 00:41:19,714
Don't know why it doesn't do that.
不知道为什么不这么做。

966
00:41:19,782 --> 00:41:22,784
So here I've created one for the TwitterUser class.
这里我为TwitterUser类创建了一个。

967
00:41:22,852 --> 00:41:25,352
Again you can put anything you want in there.
你可以在里面放任何你想要的东西。

968
00:41:25,421 --> 00:41:26,219
This is your class.
这是你的类。

969
00:41:26,288 --> 00:41:27,086
You can do anything you want.
你可以做任何你想做的事。

970
00:41:27,155 --> 00:41:29,588
All the stuff about the vars is off in
所有关于vars的东西都在里面

971
00:41:29,657 --> 00:41:31,390
an extension somewhere.
一个扩展。

972
00:41:31,459 --> 00:41:34,092
In fact, let's go take a look at that extension,
事实上，我们来看看这个扩展，

973
00:41:34,161 --> 00:41:34,910
Even though it's not going to show up in your next navigator
即使它不会出现在你的下一个导航器中

974
00:41:34,911 --> 00:41:35,660
what it looks like.
它看起来像什么。

975
00:41:35,729 --> 00:41:37,127
you're probably never going to look at it.
你可能永远也不会去看它。

976
00:41:37,196 --> 00:41:38,363
I thought I'd show it to you so
我想我应该给你看看

977
00:41:38,431 --> 00:41:40,164
you understand a little bit what's going on.
你能理解发生了什么。

978
00:41:40,232 --> 00:41:43,300
So, this is the extension, this generated for
这就是它的延伸

979
00:41:43,369 --> 00:41:43,933
TwitterUser.
TwitterUser。

980
00:41:44,002 --> 00:41:45,568
You see that is an extension
这是一个延伸

981
00:41:45,637 --> 00:41:47,236
of the TwitterUser class, right?
在TwitterUser类中，对吧?

982
00:41:47,305 --> 00:41:52,074
Remember extensions and it's got the vars.
记住扩展，它有vars。

983
00:41:52,143 --> 00:41:54,643
They're defined not just name and screenName but
它们不仅定义了名称和屏幕名称，还定义了它们

984
00:41:54,712 --> 00:41:57,279
it's got that relationship var tweets as well.
它也有关系var的推文。

985
00:41:58,281 --> 00:41:59,012
All right?
好吧?

986
00:41:59,081 --> 00:42:01,048
And look at the type of tweets.
看看推特的类型。

987
00:42:01,116 --> 00:42:03,917
As promised, it's an NSSet, it's an optional because it
正如所承诺的，它是一个NSSet，它是可选的，因为它

988
00:42:03,986 --> 00:42:07,153
comes out of the database as not set.
从数据库中出来，而不是设置。

989
00:42:07,222 --> 00:42:08,221
It's gonna get set.
它会得到设置。

990
00:42:09,823 --> 00:42:11,022
So these are the vars.
这些是vars。

991
00:42:11,091 --> 00:42:12,224
And I'll talk a little bit about
我会讲一点

992
00:42:12,292 --> 00:42:17,095
how these vars are actually implemented in a minute but
这些vars是如何在一分钟内实现的

993
00:42:17,164 --> 00:42:18,463
all the vars are there.
所有的vars都在那里。

994
00:42:18,532 --> 00:42:19,663
There's also some functions,
也有一些功能,

995
00:42:19,732 --> 00:42:20,964
now at the bottom you see those functions,
在底部你可以看到这些函数，

996
00:42:21,033 --> 00:42:23,967
those are kind of fun, those are convenience functions for
这些都很有趣，这些都是方便函数

997
00:42:24,036 --> 00:42:28,438
adding and removing tweets from the tweets set
在推特上添加和删除推文

998
00:42:28,506 --> 00:42:33,876
because NSSet is immutable, okay?
因为NSSet是不可变的，对吧?

999
00:42:33,945 --> 00:42:36,913
It's not var verses let like swift things,
这不是var，像swift的东西，

1000
00:42:36,981 --> 00:42:40,349
NS set is kind of old Objective-C way, and NSSet,
NSSet是一种老的objective - c方式，NSSet，

1001
00:42:40,418 --> 00:42:44,552
like NSAttributedString, is immutable, cannot be changed,
像NSAttributedString一样，是不可变的，不能改变，

1002
00:42:44,621 --> 00:42:47,588
so how can I add any tweets to my database here?
那么，我该如何在我的数据库中添加任何tweet呢?

1003
00:42:47,657 --> 00:42:50,158
Well you used these functions instead, add to tweets,
你使用这些函数，添加到tweet，

1004
00:42:50,226 --> 00:42:51,825
remove from tweets, add to tweets,
删除推文，添加推文，

1005
00:42:51,894 --> 00:42:55,896
remove from tweets, there's a pair for doing a single tweet,
从推特上删除，有一对做一条推文，

1006
00:42:55,965 --> 00:42:58,531
and there having adding a whole bunch of tweets, or
在那里添加了一大堆推文，或者

1007
00:42:58,600 --> 00:43:00,833
removing a whole bunch of tweets, okay?
删除一大堆tweet，明白吗?

1008
00:43:00,902 --> 00:43:03,603
So you're definitely going to want those functions for
所以你肯定想要这些函数

1009
00:43:03,671 --> 00:43:04,337
your assignment five.
作业5。

1010
00:43:05,840 --> 00:43:08,540
Cuz you're gonna have some relationships where you're
因为你会有一些关系

1011
00:43:08,608 --> 00:43:11,609
gonna want to add them using these functions.
用这些函数相加。

1012
00:43:11,678 --> 00:43:12,643
Now it adds those functions for
现在它添加了这些函数

1013
00:43:12,712 --> 00:43:16,346
any too many relationship, any time you have a too many var
任何关系，任何时候你有太多的var

1014
00:43:16,415 --> 00:43:19,549
like tweets, it's going to add these functions automatically
就像tweets一样，它将自动添加这些功能

1015
00:43:19,618 --> 00:43:21,151
It actually put it in its own little extension, this file
它实际上把它放到了自己的扩展中，这个文件

1016
00:43:21,152 --> 00:43:22,685
in the extensions.
在扩展。

1017
00:43:22,754 --> 00:43:26,622
has two extensions in it, both through TwitterUser.
它有两个扩展，都是通过TwitterUser。

1018
00:43:26,691 --> 00:43:29,825
Any questions about extensions there or any of that?
关于扩展有什么问题吗?

1019
00:43:29,894 --> 00:43:34,429
Okay, let's look at tweets extension real quick.
好的，让我们快速浏览一下推特。

1020
00:43:34,498 --> 00:43:36,565
Couple other things to look at here that I didn't look
还有一些我没看的东西

1021
00:43:36,634 --> 00:43:37,599
in the other one.
在另一个。

1022
00:43:37,667 --> 00:43:41,035
Notice this static func called fetchRequest?
注意到这个静态func叫做fetchRequest吗?

1023
00:43:41,103 --> 00:43:41,735
Put that in your mind.
把这个放在你的脑子里。

1024
00:43:41,804 --> 00:43:43,904
I'm gonna talk about that in a few slides.
我将在几张幻灯片中谈到这个。

1025
00:43:43,973 --> 00:43:46,640
fetchRequest is a really cool little static func that will
fetchRequest是一个非常酷的静态func

1026
00:43:46,709 --> 00:43:50,577
give you something you can use to fetch tweets.
给你一些你可以用来获取推文的东西。

1027
00:43:50,646 --> 00:43:52,245
And if you call fetchrRquest on twitter users,
如果你在推特上调用fetchrRquest，

1028
00:43:52,313 --> 00:43:54,213
you'll get something to fetch twitter users.
你会得到一些推特用户的东西。

1029
00:43:54,282 --> 00:43:57,282
And we'll talk about all about fetch in a moment here.
我们一会儿会谈到取回。

1030
00:43:57,351 --> 00:44:01,886
Notice the type of tweeter, see the tweeter var.
注意推特的类型，看看tweeter var。

1031
00:44:01,955 --> 00:44:04,589
Its type is TwitterUser.
它的类型是TwitterUser。

1032
00:44:04,657 --> 00:44:06,324
Because of course that's what the tweeter is,
因为这就是推特的作用，

1033
00:44:06,393 --> 00:44:09,494
we control drag between the tweet and the tweeter user so
我们在推特和推特用户之间控制拖拽

1034
00:44:09,562 --> 00:44:11,929
that tweeter var is of course a tweeter user,
tweeter var当然是推特用户，

1035
00:44:11,997 --> 00:44:15,432
not an NSSet, because it's a two one relationship, okay,
不是NSSet，因为这是两种关系，

1036
00:44:15,501 --> 00:44:18,301
there's only one TwitterUser, who is my tweeter.
只有一个推特用户，我的推特用户。

1037
00:44:20,105 --> 00:44:23,138
And what about this @NSManaged?
那么这个@ nsmanaged呢?

1038
00:44:23,207 --> 00:44:27,009
Okay, @NSManaged I'm just gonna say it's magic.
好的，@ nsmanagedobi我只是想说它是神奇的。

1039
00:44:27,077 --> 00:44:28,210
It's not really magic.
它不是真正的魔法。

1040
00:44:28,278 --> 00:44:33,181
It's essentially something that says to the runtime, hey.
它本质上是对运行时说的。

1041
00:44:33,250 --> 00:44:35,083
When someone accesses this var,
当有人访问这个var时，

1042
00:44:35,152 --> 00:44:37,485
Core Data's gonna figure it out for you.
Core Data会为你找出答案。

1043
00:44:37,554 --> 00:44:40,053
And what Core Data does, is when you try to say
Core Data做的是，当你试着说

1044
00:44:40,122 --> 00:44:45,058
Tweet.created equals some date, it gets trapped
推特。创建等于某个日期，它被捕获

1045
00:44:45,127 --> 00:44:48,228
at a low level in the runtime and Core Data swoops in and
在运行时处于低水平，核心数据突然出现

1046
00:44:48,297 --> 00:44:51,731
does set value for key for you, okay.
为你的键设置值。

1047
00:44:51,799 --> 00:44:55,268
Same thing if you get the created var, it swoops in and
同样的，如果你得到了创建的var，它会俯冲进来

1048
00:44:55,337 --> 00:44:57,603
does value for key and gets it that way.
对键值的值是这样的。

1049
00:44:57,671 --> 00:45:01,339
But it's all happening at a low level behind the scenes.
但这一切都发生在幕后。

1050
00:45:01,408 --> 00:45:05,309
So this extension does satisfy the extension limitation where
所以这个延伸确实满足了扩展限制

1051
00:45:05,378 --> 00:45:06,544
it can't have any storage.
它没有任何存储空间。

1052
00:45:06,612 --> 00:45:09,580
All of the storage for these vars isn't in the database.
这些vars的所有存储都不在数据库中。

1053
00:45:10,616 --> 00:45:12,416
And when you ask for it.
当你要求的时候。

1054
00:45:12,484 --> 00:45:14,985
Or when you set it, it's using its value for
或者当你设置它的时候，它是在使用它的值

1055
00:45:15,053 --> 00:45:17,019
key instead of value for key, to set it in the database.
键值代替键值，将其设置在数据库中。

1056
00:45:17,088 --> 00:45:18,087
Now again, it sets in memory.
再一次，它在内存中设置。

1057
00:45:18,156 --> 00:45:19,021
You have to save it for
你必须把它存起来

1058
00:45:19,090 --> 00:45:20,955
it to actually go out into the database.
它会进入数据库。

1059
00:45:21,024 --> 00:45:25,159
But that what's happening.
但这发生了什么。

1060
00:45:25,228 --> 00:45:29,130
All right, so
好吧,那么

1061
00:45:29,199 --> 00:45:34,334
now that we have these class so here's some
现在我们有了这些类

1062
00:45:34,403 --> 00:45:39,206
code that creates a tweets and sets it's attributes, okay so
创建一个tweet并设置它的属性的代码，好的

1063
00:45:39,274 --> 00:45:41,875
let's look at this piece by piece and see what it does.
让我们来看看它是怎么做的。

1064
00:45:41,943 --> 00:45:45,078
The first thing is to create a tweet, we don't have to do
第一件事是创建一条tweet，我们不需要做

1065
00:45:45,146 --> 00:45:49,449
NSEntityDescription, Entity, insert Entity for name into
nUNK tydescription，实体，插入实体的名称

1066
00:45:49,517 --> 00:45:52,318
contacts, or whatever that huge, long terrible thing was-
联系，或者其他什么巨大的，长期可怕的事情

1067
00:45:52,386 --> 00:45:55,421
we can just say, tweet, parenthesis context.
我们可以说，推特，圆括号。

1068
00:45:55,489 --> 00:45:58,223
You just say what context, which means what database you
你只需要说明上下文，这意味着什么数据库

1069
00:45:58,292 --> 00:46:00,859
want the tweet to put in and it creates a new tweet.
想要推入推文并创建一条新的tweet。

1070
00:46:00,928 --> 00:46:03,994
Okay, just use a normal initializer for
好的，使用一个普通的初始化器

1071
00:46:04,063 --> 00:46:05,496
new things so that's super cool.
新的东西，所以这很酷。

1072
00:46:05,565 --> 00:46:07,364
That's one of the coolest features right there.
这是最酷的功能之一。

1073
00:46:07,432 --> 00:46:09,666
Not having to use an NSEntityDescription thing, so
不需要使用n情感描述的东西，所以

1074
00:46:09,735 --> 00:46:13,002
no more NSEntityDescription, we'll not have to do that.
没有更多的n情感描述，我们就不用这么做了。

1075
00:46:13,071 --> 00:46:13,769
And then here,
然后在这里,

1076
00:46:13,838 --> 00:46:18,107
I'm setting the text to be 140 characters of pure joy.
我把文本设定为140个纯粹的快乐。

1077
00:46:18,175 --> 00:46:21,176
And I don't have to say set value 140 characters of pure
我不需要说集合值140个纯的字符

1078
00:46:21,244 --> 00:46:24,646
joy for key text and have all these literal strings like
关键文本的乐趣，以及所有这些文字字符串

1079
00:46:24,715 --> 00:46:28,016
text in there in this untyped thing.
文本就在这里。

1080
00:46:28,084 --> 00:46:29,918
I just say tweet.text equals that.
我只是说推特。文本=。

1081
00:46:29,986 --> 00:46:33,620
And the same thing here with created, again, so we don't
同样的东西也在这里，我们没有

1082
00:46:33,689 --> 00:46:36,857
even have to worry about the thing, if we tried to say
如果我们想说的话，就连担心这件事都要担心

1083
00:46:36,926 --> 00:46:41,228
tweet.created equals quote hello, this Swift would say,
推特。创造等于引用hello，这个Swift会说，

1084
00:46:41,297 --> 00:46:44,330
no, created is of type Date, so you can't do that, so
不，创建的是类型日期，所以你不能那样做

1085
00:46:44,399 --> 00:46:46,899
it finds all of our, it type checks everything,
它找到所有的，它类型检查所有东西，

1086
00:46:46,968 --> 00:46:49,801
finds all of our possible errors.
找出所有可能的错误。

1087
00:46:49,870 --> 00:46:52,170
What about relationships, okay, setting relationships?
那么人际关系呢?

1088
00:46:52,239 --> 00:46:56,675
So here I've created another object, a TwitterUser and
这里我创建了另一个对象，TwitterUser

1089
00:46:56,743 --> 00:46:59,144
again I just set TwitterUser with a context,
再一次，我给TwitterUser设置了一个context，

1090
00:46:59,212 --> 00:47:01,111
I'll talk about that argument in just a second but
我一会儿会讲到这个论点

1091
00:47:01,180 --> 00:47:06,050
I told what database I wanna create in TwitterUser and
我告诉了我想在TwitterUser创建的数据库

1092
00:47:06,118 --> 00:47:10,588
I set my tweet's tweeter equal to that TwitterUser.
我设置了推特的tweeter等于TwitterUser。

1093
00:47:10,656 --> 00:47:12,522
So, it's exactly what you're, would imagine right?
所以，这正是你所想象的，对吧?

1094
00:47:12,591 --> 00:47:14,290
Just set it equal to Joe.
把它设为Joe。

1095
00:47:14,359 --> 00:47:18,794
And what's interesting about this is that when you set one
有趣的是，当你设置一个

1096
00:47:18,863 --> 00:47:22,865
side of a relationship, the other side gets updated
一方的关系，另一方得到更新

1097
00:47:22,934 --> 00:47:26,001
automatically, 100% of the time.
自动的，100%的时间。

1098
00:47:26,070 --> 00:47:27,369
This is call maintaining
这是呼叫保持

1099
00:47:27,438 --> 00:47:30,038
the integrity of the database, okay?
数据库的完整性?

1100
00:47:30,106 --> 00:47:33,341
And Core Data always maintains database integrity.
核心数据始终保持数据库完整性。

1101
00:47:33,410 --> 00:47:35,543
So, when you change one side relationship.
所以，当你改变了一段关系。

1102
00:47:35,611 --> 00:47:36,710
It changes the other.
它改变了。

1103
00:47:36,779 --> 00:47:39,546
So, that means for example if I say tweet.tweeter
这意味着如果我说tweeter。tweeter

1104
00:47:39,614 --> 00:47:42,282
equals Joe, then if I went over to the Joe side and
和Joe一样，如果我走到Joe这边

1105
00:47:42,350 --> 00:47:46,152
said hey give me Joe's tweets and I'm even gonna turn it
说，嘿，给我乔的推文，我甚至会把它转过去

1106
00:47:46,220 --> 00:47:49,855
into a Swift kind of set from an NSSet to a set of
从NSSet变成一组快速的集合

1107
00:47:49,924 --> 00:47:52,291
tweet because we know that's what tweets are, right?
推特，因为我们知道推特是什么，对吧?

1108
00:47:52,360 --> 00:47:56,461
Tweets are a set of Tweets, so I'm gonna as it to do that.
推文是一组推文，所以我要这么做。

1109
00:47:56,530 --> 00:48:00,365
Then I can say, if Joe's tweet contains that tweet print yes
然后我可以说，如果乔的推文包含了推特打印是的

1110
00:48:00,434 --> 00:48:02,533
and of course it is going to print yes.
当然，它会打印yes。

1111
00:48:02,602 --> 00:48:05,002
Because when I said tweet.tweeter = joe,
因为当我说tweet的时候。推特=乔,

1112
00:48:05,071 --> 00:48:07,538
it automatically got added to joe's tweets.
它自动添加到joe的tweets中。

1113
00:48:08,573 --> 00:48:09,238
That make sense?
这说得通吗?

1114
00:48:09,307 --> 00:48:10,640
And same thing the other way.
同理。

1115
00:48:10,709 --> 00:48:13,375
If I added a tweet into joe's tweets,
如果我在乔的推文中添加一条推文，

1116
00:48:13,444 --> 00:48:16,112
that tweet tweeter would automatically set to be joe.
推特推特将自动成为乔。

1117
00:48:17,614 --> 00:48:18,546
Okay? Both sides will always
好吧?双方将永远

1118
00:48:18,615 --> 00:48:19,614
point to each other.
指向对方。

1119
00:48:19,682 --> 00:48:21,482
You never have to do anything to make that happen.
你不需要做任何事情来实现它。

1120
00:48:23,086 --> 00:48:27,688
tweet.tweeter=joe is exactly
推特。推特=乔就是

1121
00:48:27,756 --> 00:48:30,623
the same as saying joe dot addToTweets tweet.
就像说joe dot addToTweets。

1122
00:48:30,692 --> 00:48:32,959
Remember addToTweets is one of those convenience functions
记住addToTweets是其中一个方便函数

1123
00:48:33,027 --> 00:48:34,427
that it created for us over there.
它是为我们创造的。

1124
00:48:35,763 --> 00:48:37,529
Now, notice the argument I used for
现在，注意我所使用的参数

1125
00:48:37,598 --> 00:48:40,398
the context to create the Twitter user there.
创建Twitter用户的上下文。

1126
00:48:40,467 --> 00:48:43,434
I didn't say AppDelegate.viewContext.
我没有说AppDelegate.viewContext。

1127
00:48:43,503 --> 00:48:45,502
I didn't use that same context bar that I had.
我没有使用以前的上下文栏。

1128
00:48:45,571 --> 00:48:47,537
I said tweet.manageObjectContext.
我说tweet.manageObjectContext。

1129
00:48:47,606 --> 00:48:51,107
In other words, I got, I found out what database the tweet is
换句话说，我找到了推特的数据库

1130
00:48:51,176 --> 00:48:53,977
in, and I put the Twitter user in the same database.
我把推特用户放在同一个数据库中。

1131
00:48:54,046 --> 00:48:57,212
And this is a common way of programming in Core Data
这是核心数据中常见的编程方式

1132
00:48:57,281 --> 00:48:59,148
where when you wanna get a context and
当你想要得到背景的时候

1133
00:48:59,217 --> 00:49:01,717
you already have a object in the database you
您已经在数据库中有了一个对象

1134
00:49:01,786 --> 00:49:04,786
ask the object you already have what context to use.
问一下你已经有什么背景的对象。

1135
00:49:04,855 --> 00:49:08,256
And you can see that if I ever change my code to not put this
你可以看到，如果我改变我的代码，不把它放上去

1136
00:49:08,325 --> 00:49:12,059
into this context, to put it into another context, at least
在此背景下，至少把它放到另一个环境中

1137
00:49:12,128 --> 00:49:14,695
the Twitter user and the tweet would always be together
推特用户和推特总是在一起

1138
00:49:14,764 --> 00:49:16,330
in whatever that context is.
在任何情况下。

1139
00:49:16,399 --> 00:49:18,865
So you can see why I used the tweets can't
所以你可以看到为什么我使用推文不能

1140
00:49:18,934 --> 00:49:22,702
manage object context here to create that instead of using
在这里管理对象上下文，而不是使用

1141
00:49:22,771 --> 00:49:24,170
the context again.
上下文。

1142
00:49:24,239 --> 00:49:26,905
So, it, it would work to say context, of course,
所以，它会说上下文，当然，

1143
00:49:26,974 --> 00:49:30,575
but I'm just saying there's a paradigm of development where
但我只是说有一个发展的范式

1144
00:49:30,644 --> 00:49:33,612
we're gonna try and use the context of related object.
我们将尝试使用相关对象的上下文。

1145
00:49:33,680 --> 00:49:35,480
So they end up in the same database for sure.
所以他们最终在同一个数据库中。

1146
00:49:37,150 --> 00:49:37,715
Okay?
好吧?

1147
00:49:39,385 --> 00:49:41,351
All right, so
好吧,那么

1148
00:49:41,420 --> 00:49:44,821
we can also use dot notation, because these are just vars.
我们也可以用点符号，因为这些只是vars。

1149
00:49:44,889 --> 00:49:47,723
So when I say tweet.tweeter, I get a TwitterUser object.
所以当我说tweet的时候。tweeter，我得到一个TwitterUser对象。

1150
00:49:47,792 --> 00:49:50,059
So, of course, I can say dot name on it and
当然，我可以在它上面写点名

1151
00:49:50,128 --> 00:49:52,228
set it equal to Joe Schmo, whatever, right?
把它设为Joe Schmo，对吧?

1152
00:49:52,296 --> 00:49:57,266
tweet.tweeter.name = "Joe Schmo", all right?
tweeter . tweeter . name = " Joe Schmo " ?

1153
00:49:57,334 --> 00:49:59,134
No restriction there on those vars.
没有限制在那些vars上。

1154
00:50:00,703 --> 00:50:03,337
All right, remember I told you about the scalars?
好吧，记得我告诉过你关于标量的事吗?

1155
00:50:03,406 --> 00:50:06,240
This is that switch I was telling you about before.
这就是我之前告诉你们的那个开关。

1156
00:50:06,309 --> 00:50:09,777
If you don't do this, then when you say,
如果你不这样做，当你说，

1157
00:50:09,845 --> 00:50:13,313
if you had an int, let's say you had retweet
如果你有一个int，假设你有retweet

1158
00:50:13,382 --> 00:50:17,950
count which was an int here let's say on Int32.
数数在这里是int，我们在Int32上说。

1159
00:50:18,019 --> 00:50:19,185
If you don't switch this button,
如果你不切换这个按钮，

1160
00:50:19,253 --> 00:50:22,188
then that's going to be an NSNumber not an Int32.
那将会是一个NSNumber而不是Int32。

1161
00:50:22,256 --> 00:50:24,489
But when you click this switch on,
但是当你点击这个开关时，

1162
00:50:24,558 --> 00:50:26,958
now that var will be of type Int32.
现在var将会是Int32型。

1163
00:50:27,027 --> 00:50:28,893
So you almost always want this for numbers.
所以你几乎总是想要这个数字。

1164
00:50:28,962 --> 00:50:32,296
99.9% of the time, you want to have this switch on.

1165
00:50:32,365 --> 00:50:33,964
Luckily, it's on by default so
幸运的是，默认情况下是这样的

1166
00:50:34,033 --> 00:50:36,065
you don't even have to think about it much, but
你甚至不用想太多，但是

1167
00:50:36,134 --> 00:50:37,300
I just wanted to let you know about it.
我只是想让你知道。

1168
00:50:38,736 --> 00:50:40,970
All right, so now lets talk about deletion.
好，现在我们来讨论删除。

1169
00:50:41,038 --> 00:50:44,773
Okay, now, I want to delete something from the database.
现在，我想从数据库中删除一些东西。

1170
00:50:44,842 --> 00:50:46,641
And that's incredibly easy,
这是令人难以置信的简单,

1171
00:50:46,710 --> 00:50:50,378
almost too easy because your data's precious you don't want
几乎太容易了，因为你的数据很宝贵，你不想要

1172
00:50:50,447 --> 00:50:53,547
to be deleting it to easily, but you do that by asking
要删除它很容易，但你要这样做

1173
00:50:53,616 --> 00:50:56,851
the context to delete the NSManagedObject, so you can
删除NSManagedObject的上下文，可以

1174
00:50:56,919 --> 00:50:59,920
pass any NSManagedObject to this method delete and
将任何NSManagedObject传递给此方法删除和

1175
00:50:59,989 --> 00:51:02,189
it will delete it from the database.
它将从数据库中删除它。

1176
00:51:02,258 --> 00:51:05,325
And it could cascade and delete other things as well
它也可以层叠并删除其他的东西

1177
00:51:05,393 --> 00:51:08,161
depending on what delete rule is, all right?
取决于删除规则是什么?

1178
00:51:08,230 --> 00:51:11,530
Most of the time by default, when I delete something,
默认情况下，当我删除某个东西时，

1179
00:51:11,599 --> 00:51:15,067
other things that point to it get that pointer set to nil.
其他的东西，指向它的指针被设置为nil。

1180
00:51:15,136 --> 00:51:18,036
That's the nullify delete rule.
这就是nullify删除规则。

1181
00:51:18,105 --> 00:51:20,038
Now, when things get deleted from the database they got
现在，当从数据库中删除它们时

1182
00:51:20,107 --> 00:51:23,541
sent this message first, prepare for deletion.
首先发送此消息，准备删除。

1183
00:51:23,610 --> 00:51:26,177
Okay, and this is a really good method.
这是一个很好的方法。

1184
00:51:26,245 --> 00:51:28,812
Again, in here you don't have to do anything
再一次，在这里你不需要做任何事情

1185
00:51:28,881 --> 00:51:31,748
to worry about the other pointers point to you
担心其他指针指向你

1186
00:51:31,817 --> 00:51:33,583
that's all fixed by the delete rule.
这都是由删除规则决定的。

1187
00:51:33,652 --> 00:51:36,919
But what if you had another field in your database?
但如果数据库中有另一个字段呢?

1188
00:51:36,988 --> 00:51:39,421
Back to the retweet count example again.
再次回到retweet计数示例。

1189
00:51:39,490 --> 00:51:43,592
Let's say I had an int somewhere in TwitterUser,
假设我在TwitterUser某处有一个int，

1190
00:51:43,661 --> 00:51:46,227
which counted the number of retweets
哪个数的retweets

1191
00:51:46,296 --> 00:51:48,296
that this twitter user had done.
这个twitter用户已经完成了。

1192
00:51:48,365 --> 00:51:51,065
And so if I was deleting a tweet and it happened to be
所以如果我正在删除一条推特，它恰好是

1193
00:51:51,133 --> 00:51:54,902
a retweet then I need to set that to be minus equal one.
一个retweet，然后我需要把它设为-等于1。

1194
00:51:54,971 --> 00:51:56,636
And here's the perfect place to do it.
这是一个完美的地方。

1195
00:51:56,705 --> 00:51:58,372
So tweet, and it's prepared for
所以推特，它已经准备好了

1196
00:51:58,441 --> 00:52:00,507
deletion saying whoop, I'm about to be deleted.
删除说whoop，我将被删除。

1197
00:52:00,575 --> 00:52:03,376
I'd better tell my Twitter user, cuz I'm a retweet,
我最好告诉我的推特用户，因为我是一个retweet，

1198
00:52:03,444 --> 00:52:07,013
that he needs to decrement his retweet count.
他需要减量他的retweet计数。

1199
00:52:07,081 --> 00:52:09,381
So you see why you would use prepare for deletion?
你明白为什么要准备删除了吗?

1200
00:52:09,449 --> 00:52:11,416
It's a way to kind of update other things in the database
这是在数据库中更新其他东西的一种方式

1201
00:52:11,485 --> 00:52:14,252
when as you're leaving the database.
当你离开数据库的时候。

1202
00:52:15,855 --> 00:52:17,955
All right, so that's it for deletion.
这就是删除的内容。

1203
00:52:18,023 --> 00:52:19,789
Next topic, querying,
下一个话题、查询

1204
00:52:19,858 --> 00:52:22,158
the most important piece of this whole database thing.
这是整个数据库中最重要的部分。

1205
00:52:22,227 --> 00:52:24,294
It's really a waste of time doing all this stuff if you're
如果你是这样的人，做这些事情真的是浪费时间

1206
00:52:24,362 --> 00:52:24,961
not gonna query, okay?
不会查询,好吗?

1207
00:52:25,029 --> 00:52:28,831
If you're not gonna make sophisticated requests for
如果你不准备提出复杂的要求

1208
00:52:28,900 --> 00:52:32,767
the information based on the relationships, etc.
基于关系的信息，等等。

1209
00:52:32,836 --> 00:52:36,238
So, to do a query the most important thing you need to
所以，要做一个查询，你需要做的最重要的事情

1210
00:52:36,306 --> 00:52:40,475
know is NSFetchRequest, this class NSFetchRequest.
知道是NSFetchRequest，这个类NSFetchRequest。

1211
00:52:40,544 --> 00:52:43,077
And NSFetchRequest encapsulates
和NSFetchRequest封装

1212
00:52:43,146 --> 00:52:45,946
what you want from the database.
你想从数据库中得到什么。

1213
00:52:46,015 --> 00:52:47,915
So let's talk about an NSFetchRequest and
我们来谈谈NSFetchRequest

1214
00:52:47,984 --> 00:52:51,351
how we build one.
如何构建一个。

1215
00:52:51,420 --> 00:52:52,552
So when we're building one,
所以当我们建造一个，

1216
00:52:52,621 --> 00:52:54,487
there's three important things we need to know.
有三个重要的事情我们需要知道。

1217
00:52:54,556 --> 00:52:57,323
One, what entity are we fetching?
第一，我们取回的是什么实体?

1218
00:52:57,391 --> 00:53:01,626
Because a FetchRequest can only Fetch one kind of entity.
因为FetchRequest只能获取一种实体。

1219
00:53:01,695 --> 00:53:03,962
You can, there's no such thing a FetchRequest that will give
你可以，没有一个FetchRequest会给出

1220
00:53:04,031 --> 00:53:06,565
you some tweet and some Twitter user.
你有一些推特和一些推特用户。

1221
00:53:06,633 --> 00:53:07,464
No, okay?
不,好吗?

1222
00:53:07,533 --> 00:53:09,700
A fetch always gives you all tweets or
取回总是会给你所有的推文

1223
00:53:09,769 --> 00:53:12,136
all Twitter users, make sense?
所有的Twitter用户都明白吗?

1224
00:53:12,205 --> 00:53:13,070
So that's the number one thing,
这是第一件事，

1225
00:53:13,139 --> 00:53:14,905
is we're gonna create the fetch request.
我们将创建fetchrequest。

1226
00:53:14,973 --> 00:53:17,606
And it will be a fetch request or a very specific entity.
它将是一个fetchrequest或者一个非常具体的实体。

1227
00:53:17,675 --> 00:53:20,576
And it will only be able to fetch those entities.
它只能取回那些实体。

1228
00:53:20,645 --> 00:53:24,446
The second thing is is an array of sort descriptors.
第二件事是一组排序描述符。

1229
00:53:24,515 --> 00:53:25,647
And why do we want this?
为什么要这样呢?

1230
00:53:25,716 --> 00:53:29,017
Because when we execute this fetch it's gonna come back
因为当我们执行这个取回时它会回来

1231
00:53:29,086 --> 00:53:31,151
as an array, okay?
作为一个数组,好吗?

1232
00:53:31,220 --> 00:53:32,753
All the matching tweets or
所有匹配的tweet或

1233
00:53:32,822 --> 00:53:34,888
Twitter user will come back in an array.
Twitter用户将返回一个数组。

1234
00:53:34,957 --> 00:53:35,922
And since it's an array,
因为它是一个数组，

1235
00:53:35,991 --> 00:53:39,693
arrays are not sets, arrays are ordered and so
数组不是集合，数组是有序的

1236
00:53:39,761 --> 00:53:42,361
we have specify what order the things are in the arrays.
我们已经指定了数组中的东西的顺序。

1237
00:53:42,430 --> 00:53:44,830
So we do that with these sort descriptors.
我们用这些描述符来做。

1238
00:53:44,898 --> 00:53:47,833
And finally, we just specify or what is it that we want,
最后，我们只要指定，或者我们想要的，

1239
00:53:47,902 --> 00:53:51,236
which tweets do we want, which Twitter users do we want and
我们想要什么推特，我们想要哪个Twitter用户

1240
00:53:51,305 --> 00:53:53,971
we do that with something called a predicate.
我们用一个谓词来做这个。

1241
00:53:54,040 --> 00:53:55,039
Okay, so let's dive in and
让我们开始吧

1242
00:53:55,107 --> 00:53:57,174
look at all three of these things.
看看这三件事。

1243
00:53:57,243 --> 00:53:58,575
This is what it looks like,
这就是它的样子，

1244
00:53:58,644 --> 00:54:00,777
kinda top level to create a fetch request.
可以创建一个fetchrequest。

1245
00:54:00,846 --> 00:54:02,479
Okay, you get a fetch request.
你得到一个fetchrequest。

1246
00:54:02,547 --> 00:54:04,447
You set the source descriptor and you set its predicate.
设置源描述符并设置其谓词。

1247
00:54:04,516 --> 00:54:07,016
So you get each of these three parts.
得到这三个部分。

1248
00:54:07,085 --> 00:54:08,650
So getting the fetch request is easy.
所以获取fetchrequest很简单。

1249
00:54:08,719 --> 00:54:10,852
We're gonna use that little static function
我们将使用这个小的静态函数

1250
00:54:10,921 --> 00:54:14,455
that the extension that I talked about, made for
这就是我所谈到的扩展

1251
00:54:14,524 --> 00:54:16,223
us called fetchRequest.
我们叫fetchRequest。

1252
00:54:16,292 --> 00:54:19,127
Now, this is one of the very few times when Swift
这是斯威夫特为数不多的几次

1253
00:54:19,195 --> 00:54:22,830
cannot infer the type of this return value.
无法推断此返回值的类型。

1254
00:54:24,132 --> 00:54:26,500
Should've put this in red, okay?
应该把它涂成红色?

1255
00:54:26,568 --> 00:54:27,133
Because it's so
因为它是如此

1256
00:54:27,202 --> 00:54:29,568
rare, Swift can almost always infer things.
很少，斯威夫特几乎总是能推断出事情。

1257
00:54:29,637 --> 00:54:31,169
But in turns out NSManagedObject
但结果是NSManagedObject

1258
00:54:31,238 --> 00:54:34,506
has a fetchRequest method and it returns the more generic
有fetchRequest方法并返回更通用的吗

1259
00:54:34,574 --> 00:54:37,108
kind of fetchRequest and so when you're getting it,
就像fetchRequest一样，当你得到它的时候，

1260
00:54:37,177 --> 00:54:39,610
it doesn't quite know which one you want.
它不知道你想要哪一个。

1261
00:54:39,679 --> 00:54:41,579
So when you ask a Tweet for
所以当你问一个推特的时候

1262
00:54:41,648 --> 00:54:44,582
its fetch request right here, you have to tell it did you
它的取回请求，你必须告诉它是你

1263
00:54:44,650 --> 00:54:48,318
want the one in Tweet not the one from its super class?
想要在推特上的那个不是它的超类吗?

1264
00:54:48,387 --> 00:54:48,884
All right? And so
好吧?所以

1265
00:54:48,953 --> 00:54:51,186
say let request equal NSFetchRequest.
假设让请求等于NSFetchRequest。

1266
00:54:51,255 --> 00:54:53,756
It's a generic type like array or something like that, right?
它是一个类似数组之类的泛型类型，对吧?

1267
00:54:53,825 --> 00:54:55,958
This is a fetch request only for Tweets.
这是只用于tweet的获取请求。

1268
00:54:56,026 --> 00:54:58,594
So you say NSFetchRequest<tweet> =
你说NSFetchRequest < tweet > =

1269
00:54:58,662 --> 00:55:00,595
Tweet.fetchRequest().
Tweet.fetchRequest()。

1270
00:55:00,664 --> 00:55:02,396
And it knows, of course,
它当然知道，

1271
00:55:02,465 --> 00:55:05,900
that the only one that returns an NSFetchRequest for
这是唯一返回NSFetchRequest的

1272
00:55:05,968 --> 00:55:09,003
tweets is the fetchRequest, and that's Tweet extension.
tweets是fetchRequest，这是Tweet扩展。

1273
00:55:11,106 --> 00:55:12,439
So now, you have a fetchRequest,
现在，你有一个fetchRequest，

1274
00:55:12,507 --> 00:55:14,741
this is how you get a fetch request- couldn't be easier.
这就是获取获取请求的方法——不太容易。

1275
00:55:14,809 --> 00:55:17,442
You just have to remember to do that static
你只需要记住做静态的

1276
00:55:17,511 --> 00:55:19,378
typing right there.
打字在这里。

1277
00:55:19,446 --> 00:55:21,446
Okay, now we need the sortDescriptor, right?
好的，现在我们需要sortDescriptor，对吧?

1278
00:55:21,515 --> 00:55:22,947
It's got this array coming back.
这个数组回来了。

1279
00:55:23,016 --> 00:55:25,516
What order are they going to be?
他们将会是什么顺序?

1280
00:55:25,585 --> 00:55:27,851
SortDescriptor looks like this.
SortDescriptor看起来是这样的。

1281
00:55:27,920 --> 00:55:29,352
You create it with a key.
你用一个键来创建它。

1282
00:55:29,421 --> 00:55:32,188
That is the key, the attribute in
这就是关键所在

1283
00:55:32,257 --> 00:55:35,258
the database that you want to sort on, so the screen name or
你想要排序的数据库，所以是屏幕名称

1284
00:55:35,327 --> 00:55:38,828
even the text in the tweet or the actual name of
甚至是推特上的文字或真实的名字

1285
00:55:38,897 --> 00:55:40,896
the tweeter, whatever it's gonna be.
推特，不管它是什么。

1286
00:55:40,965 --> 00:55:42,230
This right here, sortDescriptor,
这里,sortDescriptor,

1287
00:55:42,299 --> 00:55:45,867
will be a sort descriptor only suitable for fetching Twitter
只适合于获取Twitter的排序描述符吗

1288
00:55:45,936 --> 00:55:49,471
users, because screenName is a key in Twitter user,
用户，因为屏幕名是推特用户的关键，

1289
00:55:49,540 --> 00:55:51,906
not in tweet, so we're gonna use this SortDescriptor
不是在推特上，所以我们要用这个SortDescriptor

1290
00:55:51,975 --> 00:55:53,641
in a tweet request.
在推特请求。

1291
00:55:53,709 --> 00:55:55,175
And I say that because on the previous slide,
我这么说是因为在之前的幻灯片上，

1292
00:55:55,244 --> 00:55:57,611
I just showed you how to make a fetch request for a tweet.
我刚刚向你展示了如何为一条tweet制作一个fetchrequest。

1293
00:55:57,680 --> 00:55:59,312
Anyway, I should just, that should have been Twitter user.
不管怎样，我应该，应该是推特用户。

1294
00:55:59,381 --> 00:56:01,648
But anyway, so this is a Twitter user.
不管怎样，这是一个推特用户。

1295
00:56:01,716 --> 00:56:02,781
SortDescriptor.
SortDescriptor。

1296
00:56:02,850 --> 00:56:05,951
And notice it has ascending or descending like us A to Z or
注意它上升或下降就像我们A到Z

1297
00:56:06,020 --> 00:56:10,588
Z to A and then it has this argument selector and
Z到A然后它有这个参数选择器

1298
00:56:10,657 --> 00:56:13,458
this one creates some confusion.
这造成了一些混乱。

1299
00:56:13,527 --> 00:56:15,859
But really this selector just says,
但这个选择器说，

1300
00:56:15,928 --> 00:56:20,497
what method am I gonna use to compare items to do the sort.
我将用什么方法来比较这些项。

1301
00:56:20,566 --> 00:56:24,735
All right now, you don't even have to specify the selector
现在，你甚至不需要指定选择器

1302
00:56:24,804 --> 00:56:26,837
if you don't want to and for
如果你不想这么做

1303
00:56:26,906 --> 00:56:29,906
almost all data types, numbers,
几乎所有的数据类型，数字，

1304
00:56:29,975 --> 00:56:34,410
dates, it's going to use a method called compare, okay.
日期，它将使用一个叫做compare的方法。

1305
00:56:34,479 --> 00:56:38,747
Compare returns something called a comparison result
比较返回的东西称为比较结果

1306
00:56:38,816 --> 00:56:41,450
which is either, it's the same, it's greater than, or
哪一个，它是一样的，它大于，还是

1307
00:56:41,518 --> 00:56:42,084
it's less than.
它小于。

1308
00:56:42,153 --> 00:56:43,618
So, that's what this compare method does.
这就是比较方法的作用。

1309
00:56:43,687 --> 00:56:44,885
And it's implemented by date.
它是按日期执行的。

1310
00:56:44,954 --> 00:56:46,187
It's implemented by Int32.
它是由Int32实现。

1311
00:56:46,256 --> 00:56:47,888
It's implemented by double.
它是由双实现。

1312
00:56:47,957 --> 00:56:49,823
It's even implemented by string.
它甚至用字符串来实现。

1313
00:56:49,892 --> 00:56:50,724
Okay? So,
好吧?所以,

1314
00:56:50,793 --> 00:56:52,358
you could just use compare.
你可以用比较。

1315
00:56:52,427 --> 00:56:54,594
But, for strings.
但是,对于字符串。

1316
00:56:54,662 --> 00:56:56,695
You wanna think a little bit about what kind
你想多想想哪类

1317
00:56:56,764 --> 00:56:57,895
of comparison do you want?
你想要什么比较?

1318
00:56:57,964 --> 00:57:01,233
Do you want case-insensitive compare?
您需要不区分大小写的比较吗?

1319
00:57:01,301 --> 00:57:03,734
Or you could even use this special compare,
或者你可以用这个特殊的比较，

1320
00:57:03,803 --> 00:57:05,736
called localizedStandardCompare.
叫localizedStandardCompare。

1321
00:57:05,805 --> 00:57:06,737
This will compare them so
这将比较它们

1322
00:57:06,806 --> 00:57:09,573
that it is sourced just like the finder on the Mac.
它的来源就像在Mac上的finder。

1323
00:57:09,641 --> 00:57:11,575
And what does the finder on the Mac do that's different
而在Mac上的取景器有什么不同呢

1324
00:57:11,643 --> 00:57:12,942
than case insensitive?
比不区分大小写吗?

1325
00:57:13,010 --> 00:57:15,444
Well, there's a lot of issues with things like diacritic
嗯，有很多问题，比如diacritic

1326
00:57:15,513 --> 00:57:17,912
marks, and you know,
是,你知道,

1327
00:57:17,981 --> 00:57:20,616
things in your local language where things sort differently,
在你当地的语言中，事情的排序方式不同，

1328
00:57:20,684 --> 00:57:23,284
depending on what language you're in, what locale it is.
取决于你所使用的语言，它是什么语言环境。

1329
00:57:23,353 --> 00:57:25,419
You'd, you sometimes you ignore the diacritics,
有时候你忽略了音符，

1330
00:57:25,488 --> 00:57:26,320
like accent marks.
像重音符号。

1331
00:57:26,389 --> 00:57:28,154
Sometimes they mean something.
有时他们意味着什么。

1332
00:57:28,223 --> 00:57:31,992
And, so localized standard compare is a special compare
而且，本地化的标准比较是一个特殊的比较

1333
00:57:32,061 --> 00:57:35,194
for strings, that knows how to do that, okay?
对于字符串，它知道怎么做，对吧?

1334
00:57:35,263 --> 00:57:38,197
And this is very commonly the one we will use for strings.
这是我们经常用到的字符串。

1335
00:57:38,266 --> 00:57:39,832
When we're gonna show something in our UI,
当我们在UI中显示一些东西时，

1336
00:57:39,901 --> 00:57:42,334
maybe this array of thing for fetching,
也许这一系列的抓取，

1337
00:57:42,403 --> 00:57:43,168
we're gonna put it in the UI.
我们把它放到UI中。

1338
00:57:43,237 --> 00:57:44,769
We would want it to be in order,
我们希望它是有序的，

1339
00:57:44,838 --> 00:57:46,304
this localizedStandardCompare.
这localizedStandardCompare。

1340
00:57:46,372 --> 00:57:50,374
You notice that it's an NSString dot method.
注意到它是NSString。

1341
00:57:50,443 --> 00:57:53,343
It's not String.localizedStandardComp-
这不是String.localizedStandardComp -

1342
00:57:53,412 --> 00:57:55,679
that's because this has to be an Objective-C visible method.
这是因为它必须是一个objective - c可见的方法。

1343
00:57:55,680 --> 00:57:57,947
are. And
是这样的。和

1344
00:57:58,950 --> 00:58:01,584
And you need the NSString version.
你需要NSString版本。

1345
00:58:01,652 --> 00:58:03,285
So basically you're going to say NSString dot, and
所以基本上你会说NSString

1346
00:58:03,354 --> 00:58:07,522
you can go look, search for compare in NSString or string,
你可以去找NSString或string的比较，

1347
00:58:07,591 --> 00:58:09,690
because a string implements them all as well but
因为一个字符串也实现了它们

1348
00:58:09,759 --> 00:58:12,393
you need NSString dot and then the name of the method.
你需要NSString点和方法名。

1349
00:58:12,462 --> 00:58:14,995
And you can search, and there is case insensitive and
你可以搜索，不区分大小写

1350
00:58:15,064 --> 00:58:18,232
the standard compare and then the regular compare and etc.
标准比较，然后是常规比较等。

1351
00:58:18,301 --> 00:58:22,335
Now one other thing about this is that,
另一个问题是，

1352
00:58:22,404 --> 00:58:27,273
these methods some of them are special in that,
这些方法有些很特别，

1353
00:58:27,342 --> 00:58:32,211
it does to compare on the database side, okay.
它可以在数据库方面进行比较。

1354
00:58:32,280 --> 00:58:36,082
Using SQL to do it, see what I'm saying?
使用SQL来完成它，明白我的意思吗?

1355
00:58:36,150 --> 00:58:39,251
It's not actually bringing all the data over.
它并没有把所有的数据都带过来。

1356
00:58:39,320 --> 00:58:41,786
Calling this method on every string, and
在每个字符串上调用此方法

1357
00:58:41,855 --> 00:58:43,989
doing some kind of quicksort or something.
做一些快速排序。

1358
00:58:44,057 --> 00:58:46,690
It's using super powerful sorting mechanisms that
它使用了非常强大的排序机制

1359
00:58:46,759 --> 00:58:48,993
are built into an SQL database, okay.
被构建到一个SQL数据库中。

1360
00:58:49,062 --> 00:58:52,896
So, in fact, all of the NSString ones will do that.
实际上，所有的NSString都会这样做。

1361
00:58:52,965 --> 00:58:56,834
Okay, so they're super duper efficient.
好吧，他们是超级高效的。

1362
00:58:56,902 --> 00:59:00,537
Now, if you wanted to use your own compare though,
现在，如果你想用自己的比较，

1363
00:59:00,606 --> 00:59:01,971
it's not gonna be efficient.
这样做效率不高。

1364
00:59:02,040 --> 00:59:02,838
Because it is gonna have to
因为这是必须的

1365
00:59:02,906 --> 00:59:05,674
bring all the data from the database into your memory so
将数据库中的所有数据都放到内存中

1366
00:59:05,743 --> 00:59:07,509
it can run your little method over it.
它可以在上面运行你的小方法。

1367
00:59:07,578 --> 00:59:08,776
So I strongly recommend
所以我强烈推荐

1368
00:59:08,845 --> 00:59:11,479
against using your own selector here.
不要使用你自己的选择器。

1369
00:59:11,548 --> 00:59:13,413
I would use the standard selectors.
我将使用标准选择器。

1370
00:59:13,482 --> 00:59:14,548
If you're gonna use your own selector
如果你要使用你自己的选择器

1371
00:59:14,617 --> 00:59:16,449
it's gotta be on a pretty small dataset.
它必须在一个很小的数据集上。

1372
00:59:16,518 --> 00:59:20,487
Cuz it's not gonna be very efficient.
因为这不是很有效率。

1373
00:59:22,123 --> 00:59:24,423
Notice that when we do the fetch request,
请注意，当我们执行取回请求时，

1374
00:59:24,492 --> 00:59:26,759
we don't just give it a sort descriptor,
我们不只是给它排序描述符，

1375
00:59:26,828 --> 00:59:29,427
we give it an array of sort descriptors.
我们给它一个排序描述符数组。

1376
00:59:29,496 --> 00:59:33,632
That's the old sort by last name, and then first name.
这是姓氏的旧排序，然后是名字。

1377
00:59:33,700 --> 00:59:34,432
Right? So if
对吧?因此,如果

1378
00:59:34,501 --> 00:59:37,167
we have 12 Smiths in there, we'll sort them and
我们有12个Smiths，我们会对它们排序

1379
00:59:37,236 --> 00:59:38,936
the Smiths will be in the right spot.
史密斯一家将会处于正确的位置。

1380
00:59:39,005 --> 00:59:40,870
And then all of the first names of the Smiths
然后是Smiths的所有名字

1381
00:59:40,939 --> 00:59:41,971
will be in order by that.
会按这个顺序排列的。

1382
00:59:42,040 --> 00:59:44,240
So we can have as many of these sub sort by the one
所以我们可以有很多这样的子排序

1383
00:59:44,308 --> 00:59:45,675
thing, sub sort by the next thing,
下一件事，

1384
00:59:45,744 --> 00:59:47,476
sub sort by the next thing.
下一件事。

1385
00:59:47,544 --> 00:59:50,612
Basically, we can break ties with subsequent sorting and
基本上，我们可以中断与后续排序的联系

1386
00:59:50,681 --> 00:59:53,749
that's why we give an array of sort descriptors.
这就是为什么我们给出排序描述符数组的原因。

1387
00:59:56,619 --> 01:00:00,688
Okay, so, that's the fetch request and
这是fetchrequest

1388
01:00:00,757 --> 01:00:02,790
its sort descriptors and now the predicate.
它的排序描述符和谓词。

1389
01:00:02,858 --> 01:00:06,192
Okay, the predicate is the guts of saying which tweets do
这个谓词是推文的核心

1390
01:00:06,261 --> 01:00:06,993
we want.
我们想要的。

1391
01:00:07,062 --> 01:00:08,962
Which Twitter users do we want?
我们想要哪个Twitter用户?

1392
01:00:09,030 --> 01:00:12,031
We create them with kind of interesting API.
我们用有趣的API创建它们。

1393
01:00:12,099 --> 01:00:17,069
It looks a lot like printf from C.
它看起来很像来自C的printf。

1394
01:00:17,137 --> 01:00:20,672
NSPredicate format colon, and then a string.
NSPredicate格式冒号，然后是字符串。

1395
01:00:20,740 --> 01:00:23,008
And the string is a format string.
字符串是一个格式字符串。

1396
01:00:23,076 --> 01:00:24,608
And again, looks a lot like printf.
再一次，看起来很像printf。

1397
01:00:24,677 --> 01:00:28,045
So the best way to explain this is probably by example.
所以最好的解释就是通过例子。

1398
01:00:28,114 --> 01:00:30,114
But the way you're gonna learn this is you're gonna go
但你要知道的是，你要走了

1399
01:00:30,182 --> 01:00:33,884
read the documentation for NSPredicate, you've got to go
读一下NSPredicate的文档，你就得走了

1400
01:00:33,953 --> 01:00:37,053
read that documentation, in its class documentation,
阅读文档，在它的类文档中，

1401
01:00:37,122 --> 01:00:39,856
there's gonna be a link that says, creating predicates,
会有一个链接，创建谓词，

1402
01:00:39,924 --> 01:00:42,858
or something like that, click on that, and go there, and
或者类似的东西，点击那个，然后去那里

1403
01:00:42,927 --> 01:00:45,327
learn all the things you can put in this format string,
学习所有你可以放入这个格式字符串的东西，

1404
01:00:45,396 --> 01:00:48,497
cuz it's all very specific to doing database queries, but
因为这都是针对数据库查询的，但是

1405
01:00:48,566 --> 01:00:49,631
I'll show you some examples, so
我会给你们看一些例子

1406
01:00:49,700 --> 01:00:51,666
you get an idea of what's going on here.
你知道这里发生了什么。

1407
01:00:51,735 --> 01:00:53,067
So here's the first one,
这是第一个，

1408
01:00:53,136 --> 01:00:54,935
let's have the search string called foo.
让我们有一个名为foo的搜索字符串。

1409
01:00:58,207 --> 01:01:00,039
All these searches then I'm gonna do right here
所有这些搜索，我就在这里做

1410
01:01:00,108 --> 01:01:01,307
are tweet searches.
微博搜索。

1411
01:01:01,375 --> 01:01:04,710
These are for predicates for searching for a tweet.
这些是用于搜索tweet的谓词。

1412
01:01:04,778 --> 01:01:08,113
So first, I'm gonna find all the tweets whose text,
首先，我要找到所有的推文，

1413
01:01:08,182 --> 01:01:11,617
the actual tweet, the 140 characters of pure joy or
真正的推特，140个纯粹的快乐

1414
01:01:11,685 --> 01:01:14,151
whatever, contains case sensitive.
无论如何,包含大小写敏感的。

1415
01:01:14,220 --> 01:01:15,320
Case insensitively.
区分大小写。

1416
01:01:15,388 --> 01:01:18,222
That's what [c] means.
这就是[c]的意思。

1417
01:01:18,290 --> 01:01:20,624
%@. %@ is a substitution variable,

1418
01:01:20,693 --> 01:01:22,659
and I have to give its value at the end.
最后我要给出它的值。

1419
01:01:22,728 --> 01:01:25,328
And so I'm substituting search string.
我在用搜索字符串替换。

1420
01:01:25,397 --> 01:01:28,298
Okay, note that I can't say, text contains foo.
注意，我不能说，文本包含foo。

1421
01:01:28,367 --> 01:01:32,902
I have to say, text contains %@ and then.
我不得不说，文本包含% @，然后。

1422
01:01:32,971 --> 01:01:35,037
Put something at the end there.
把东西放到最后。

1423
01:01:35,106 --> 01:01:36,237
Okay, so that's an obvious one,
这很明显，

1424
01:01:36,306 --> 01:01:38,739
I'm searching for all my tweets that contain foo.
我正在搜索所有包含foo的tweet。

1425
01:01:38,808 --> 01:01:41,309
How about this one?
这一个怎么样?

1426
01:01:41,378 --> 01:01:46,213
I want all the tweets whose tweeter equals %@.
我想要所有推特都是% @的推文。

1427
01:01:46,282 --> 01:01:48,615
I'm going to put Joe in there as the substitution variable
我把Joe放到这里作为替换变量

1428
01:01:48,684 --> 01:01:52,986
and created after some date that I create.
并在我创建的某个日期后创建。

1429
01:01:54,155 --> 01:01:56,489
See that? I'm using greater
看到了吗?我用大

1430
01:01:56,557 --> 01:01:57,556
than to do that.
比。

1431
01:01:57,625 --> 01:01:59,324
And I'm doing && for and,
我在做& &，

1432
01:01:59,393 --> 01:02:01,326
you can also use the word and there.
你也可以用这个词。

1433
01:02:02,295 --> 01:02:03,094
Okay? So that's all gonna be
好吧?这就是全部

1434
01:02:03,163 --> 01:02:05,129
the tweets created by Joe since that date.
乔自那一天起创建的推文。

1435
01:02:07,199 --> 01:02:09,198
You're starting to see the power of building the query
您已经看到了构建查询的能力

1436
01:02:09,267 --> 01:02:10,133
into the database, right?
到数据库中,对吧?

1437
01:02:10,202 --> 01:02:12,601
If I had thousands of tweets, it'd be really easy to find
如果我有成千上万条推文，很容易找到

1438
01:02:12,670 --> 01:02:14,570
the ones since yesterday, for example.
例如，从昨天开始。

1439
01:02:14,639 --> 01:02:16,839
I'll show you that in a second here.
我马上会给你们看。

1440
01:02:16,907 --> 01:02:21,910
Aand then I can also though, search through dot notation,
然后我还可以通过点符号来搜索，

1441
01:02:21,979 --> 01:02:23,844
on other fields, in other entities, but
在其他领域，在其他实体中，但是

1442
01:02:23,913 --> 01:02:28,616
this tweeter.screenName equals percent @ sign%@ with CS193P,
这个推特。在CS193P中，screenName = % @ @ % @ @ @ @ @，

1443
01:02:28,684 --> 01:02:30,617
that's still searching for tweets.
这还在搜索推文。

1444
01:02:30,686 --> 01:02:31,185
That's searching for
这是寻找

1445
01:02:31,253 --> 01:02:34,621
tweets whose tweeter's screen name is CS193P.
推特的屏幕名称是CS193P的推文。

1446
01:02:34,689 --> 01:02:37,056
Do you see what it's doing there?
你看到它在那里做什么了吗?

1447
01:02:37,125 --> 01:02:38,557
This is still a tweet predicate.
这仍然是一个tweet谓词。

1448
01:02:38,626 --> 01:02:41,060
This is not a twitter user predicate.
这不是一个twitter用户谓词。

1449
01:02:41,996 --> 01:02:43,094
Okay?
好吧?

1450
01:02:43,163 --> 01:02:45,263
So here's a different predicate.
这是一个不同的谓词。

1451
01:02:45,332 --> 01:02:47,932
This one is for Twitter user.
这个是给Twitter用户的。

1452
01:02:48,001 --> 01:02:49,234
So here I'm searching for all the Twitter users
我在搜索所有的推特用户

1453
01:02:49,235 --> 01:02:50,468
Okay?
好吧?

1454
01:02:52,438 --> 01:02:56,506
who has a Tweet whose text contains foo.
谁有一条含有foo的Tweet。

1455
01:02:57,743 --> 01:02:58,708
Okay?
好吧?

1456
01:02:58,777 --> 01:03:01,009
So it even knows how to do a pluralistic
所以它甚至知道如何做多元的

1457
01:03:01,078 --> 01:03:03,278
search right here where you've got tweets dot text that means
在这里搜索，你会得到tweets。text

1458
01:03:03,346 --> 01:03:08,049
all the tweets, texts and doing contains and
所有的推文，文本和做的都包含和

1459
01:03:08,118 --> 01:03:10,919
we can do [c] if we wanted foo.
如果我们想要，我们可以做。

1460
01:03:10,987 --> 01:03:13,054
So that's a twitter user search right there.
这就是twitter用户搜索。

1461
01:03:13,122 --> 01:03:14,555
the twitter users who have tweeted anything that includes
推特用户在推特上发布了任何内容

1462
01:03:14,556 --> 01:03:15,989
We're looking for
我们正在寻找

1463
01:03:16,058 --> 01:03:19,493
foo, again a powerful search, really easy to express.
foo，再一次强大的搜索，很容易表达。

1464
01:03:22,563 --> 01:03:24,197
Question.
的问题。

1465
01:03:24,265 --> 01:03:27,733
>> [INAUDIBLE] >> So the question,

1466
01:03:27,801 --> 01:03:29,801
does it infer this from the name of the variable,
它是从变量的名字推导出来的，

1467
01:03:29,869 --> 01:03:31,035
it's not inferring it,
这不是推断,

1468
01:03:31,104 --> 01:03:34,172
it's actually using the name of the attribute tweets
它实际上是在使用属性tweets的名称

1469
01:03:34,240 --> 01:03:36,674
right there and the name of the attribute text and it's
这里和属性文本的名称

1470
01:03:36,742 --> 01:03:40,177
building a SQL statement that will go and do this fetch.
构建一个SQL语句，然后执行这个fetch。

1471
01:03:40,246 --> 01:03:41,878
Okay now it's doing all that underneath the covers,
现在它在覆盖范围内做所有的事情，

1472
01:03:41,947 --> 01:03:44,314
we don't care how, but it's doing it.
我们不关心怎么做，但它就是这么做的。

1473
01:03:47,952 --> 01:03:48,718
Yeah, compound predicate.
是的,复合谓语。

1474
01:03:48,787 --> 01:03:51,453
You can build a compound predicate like an and
您可以构建一个复合谓词，像an和

1475
01:03:51,522 --> 01:03:52,887
predicate or an or predicate.
谓词或谓词。

1476
01:03:52,956 --> 01:03:55,957
You could put or or and in the string, or
你可以把它放在弦里，或者

1477
01:03:56,025 --> 01:03:58,026
you could create separate predicates and and
您可以创建独立的谓词和

1478
01:03:58,094 --> 01:04:00,794
them together by creating an NSCompoundPredicate.
它们通过创建一个nscompound谓词在一起。

1479
01:04:00,863 --> 01:04:02,195
And predicate with sub-predicates, and
谓词与子谓词，以及

1480
01:04:02,264 --> 01:04:03,864
just given an array of predicates and
只要给出一个谓词数组

1481
01:04:03,932 --> 01:04:04,664
it ands them together.
它and在一起。

1482
01:04:04,733 --> 01:04:06,699
Why would you ever want to do this versus just putting and
你为什么要这么做，而不是仅仅投入

1483
01:04:06,767 --> 01:04:07,600
or, or in there?
或者,还是在那里?

1484
01:04:07,669 --> 01:04:10,970
Well, maybe you're computing what the predicates are,
也许你在计算谓词是什么，

1485
01:04:11,038 --> 01:04:14,139
based on some, depending on what the user clicked on or
基于一些，取决于用户点击的是什么

1486
01:04:14,208 --> 01:04:14,939
something, you're computing it, and
你在计算它

1487
01:04:15,008 --> 01:04:18,009
so you want to add these things you computed together.
你想把这些相加。

1488
01:04:19,845 --> 01:04:22,980
All right, there's also function predicates.
好的，还有函数谓词。

1489
01:04:23,049 --> 01:04:25,382
Now these are super powerful predicates,
这些都是非常强大的谓词，

1490
01:04:25,451 --> 01:04:27,284
and you don't need these for your homework, so
你不需要这些来做作业

1491
01:04:27,352 --> 01:04:30,120
don't worry too much about these, but they're cool.
不要太担心这些，但它们很酷。

1492
01:04:30,188 --> 01:04:32,621
You can even say, you have a search like this one,
你甚至可以说，像这样的搜索，

1493
01:04:32,690 --> 01:04:35,291
tweets.@count > 5,
tweet。@count > 5,

1494
01:04:35,360 --> 01:04:37,926
this is a Twitter user search, that finds
这是一个Twitter用户搜索

1495
01:04:37,994 --> 01:04:42,363
all the Twitter users who have more than 5 Tweets, okay?
所有的推特用户都有5条以上的推文，对吧?

1496
01:04:42,432 --> 01:04:45,266
So, @count is actually running, kind of a function in
@ count实际上是在运行一个函数

1497
01:04:45,335 --> 01:04:49,003
the database, to go count the number of Tweets that
数据库，来计算推文的数量

1498
01:04:49,071 --> 01:04:50,770
the Twitter user has.
Twitter用户。

1499
01:04:50,839 --> 01:04:52,639
So, again, you'll see all of this when you go look at
再一次，你会看到所有这些

1500
01:04:52,707 --> 01:04:55,708
the NSPredicate documentation, it's incredibly powerful,
NSPredicate文档，非常强大，

1501
01:04:55,777 --> 01:04:59,445
you can see you barely have to type anything in as the format
您可以看到，您几乎不需要键入任何内容作为格式

1502
01:04:59,514 --> 01:05:02,081
string, and you get these really powerful searches.
字符串，你得到这些非常强大的搜索。

1503
01:05:04,218 --> 01:05:06,718
All right, so let's put it all together now to create
好了，让我们把它放到一起来创建

1504
01:05:06,787 --> 01:05:08,019
our fetch request, okay.
我们获取的请求。

1505
01:05:08,088 --> 01:05:09,154
I'm gonna create,
我要创建、

1506
01:05:09,222 --> 01:05:11,189
in this case, a Twitter user fetch request.
在本例中，是一个Twitter用户获取请求。

1507
01:05:11,257 --> 01:05:13,857
So I'm saying a FetchRequest<TwitterUser> =
我说的是FetchRequest < TwitterUser > =

1508
01:05:13,926 --> 01:05:16,527
TwitterUser.fetchRequest(), then I'm gonna
TwitterUser.fetchRequest(),然后我要

1509
01:05:16,595 --> 01:05:18,161
create a time which was yesterday,
创造一个昨天，

1510
01:05:18,230 --> 01:05:21,030
it's actually not, it's 24 hours ago.
实际上不是，24小时前。

1511
01:05:21,099 --> 01:05:24,133
Time interval since now, minus 24 times 60 times 60,
从现在开始的时间间隔，减去24乘以60乘以60，

1512
01:05:24,202 --> 01:05:27,068
that's 24 hours ago, and I'm creating a predicate
那是24小时前，我在创建一个谓词

1513
01:05:27,137 --> 01:05:31,239
that says, find me any Twitter users that have a Tweet that's
也就是说，找到任何有推特的推特用户

1514
01:05:31,308 --> 01:05:36,378
created before yesterday, or since yesterday I guess,
在昨天之前，或者从昨天开始，

1515
01:05:36,447 --> 01:05:38,812
yes, created is greater than yesterday.
是的，创造比昨天大。

1516
01:05:38,881 --> 01:05:42,917
So I'm finding all the Twitter users who have created Tweets
所以我找到所有创建推特的推特用户

1517
01:05:42,985 --> 01:05:45,419
in the last twenty-four hours, that's what this one does.
在过去的24小时里，这就是这个。

1518
01:05:45,487 --> 01:05:49,556
So any is a special term that means match any
所以任何一个都是一个特殊的术语，意思是和任何一个

1519
01:05:49,625 --> 01:05:51,424
of these things, and
这些东西,

1520
01:05:51,492 --> 01:05:54,828
these things are Tweets that are created since yesterday.
这些是自昨天以来创建的tweet。

1521
01:05:56,096 --> 01:05:58,831
And I'm gonna sort the result by the actual name,
我要用实际的名字排序，

1522
01:05:58,899 --> 01:06:01,733
the real name of the Twitter user.
Twitter用户的真实姓名。

1523
01:06:01,802 --> 01:06:04,436
So I'm just doing sortDescriptor, key of name,
我在做sortDescriptor,name的键，

1524
01:06:04,504 --> 01:06:07,305
ascending true, I'm not specifying a selector, so
提升为真，我没有指定选择器

1525
01:06:07,374 --> 01:06:09,873
I'm gonna get kind of the default comparison.
我会得到默认的比较。

1526
01:06:09,942 --> 01:06:12,743
Okay, that's it, so that's how you create a fetch request.
这就是创建fetchrequest的方法。

1527
01:06:12,811 --> 01:06:16,914
Now, since I have a fetch request, how do I make it go?
既然我有一个fetchrequest，那我该怎么做呢?

1528
01:06:16,982 --> 01:06:19,782
Give me those Tweets, give me those Twitter users.
给我那些推文，给我推特用户。

1529
01:06:19,851 --> 01:06:22,618
We do that with the very simple method in context, so
我们用非常简单的方法来做，所以

1530
01:06:22,687 --> 01:06:25,721
we ask the context to do the fetch, and it will go out and
我们要求context做取回，然后它就会出来

1531
01:06:25,790 --> 01:06:28,623
return an array of all those things,
返回所有这些东西的数组，

1532
01:06:28,692 --> 01:06:31,627
sorted in the way the fetch request says to sort them.
按照获取请求的方式对它们进行排序。

1533
01:06:31,695 --> 01:06:33,228
Okay, simple as that.
好了,就这么简单。

1534
01:06:33,297 --> 01:06:37,832
The only thing not so simple, it throws, okay?
唯一没有这么简单的东西，它抛出，对吧?

1535
01:06:37,901 --> 01:06:43,004
Just like context save throws, context execute also throws.
就像上下文保存抛出，上下文执行也抛出。

1536
01:06:43,073 --> 01:06:45,539
So, you could put in a try question mark,
你可以用一个问号，

1537
01:06:45,608 --> 01:06:48,942
in that case, if the execute fails, and usually it's gonna
在这种情况下，如果执行失败，通常它会

1538
01:06:49,011 --> 01:06:51,411
fail because your predicate is wrong, or something.
因为你的谓词错了，或者别的什么。

1539
01:06:53,114 --> 01:06:56,182
Like your predicate just makes no sense then you could fail.
就像你的谓词没有意义那样你就会失败。

1540
01:06:56,251 --> 01:06:57,916
If it's gonna fail, you're gonna get back nil,
如果它失败了，你会返回nil，

1541
01:06:57,985 --> 01:06:58,984
if you do try question mark,
如果你尝试问号，

1542
01:06:59,052 --> 01:07:00,652
remember that's what try question mark means.
记住，这就是问号的意思。

1543
01:07:00,720 --> 01:07:03,054
It means try this, and if it fails, give back nil.
它的意思是尝试这个，如果失败了，就返回nil。

1544
01:07:03,123 --> 01:07:04,188
But it if doesn't fail,
但如果没有失败，

1545
01:07:04,257 --> 01:07:06,524
then you're gonna get an optional array.
然后你会得到一个可选的数组。

1546
01:07:06,592 --> 01:07:08,892
And that array is gonna be empty,
这个数组是空的，

1547
01:07:08,961 --> 01:07:11,928
if it couldn't find anything that matches your request, or,
如果它找不到符合你要求的东西，

1548
01:07:11,997 --> 01:07:14,130
it's gonna be full of objects, okay?
会有很多对象?

1549
01:07:14,199 --> 01:07:16,832
Tweets, or Twitter users, an array of tweets, or
推文、推特用户、推文数组或

1550
01:07:16,901 --> 01:07:18,200
an array of Twitter users,
一群推特用户，

1551
01:07:18,268 --> 01:07:19,501
at least that's what it's gonna look like to you,
至少这是它看起来的样子，

1552
01:07:19,570 --> 01:07:22,404
it's not quite that, looks like it, all right?
看起来不太像，对吧?

1553
01:07:22,472 --> 01:07:24,939
That's the result you're gonna get back, so, again,
这就是你要回来的结果，

1554
01:07:25,007 --> 01:07:26,974
super simple querying.
超级简单的查询。

1555
01:07:27,042 --> 01:07:31,445
Now, you might be a little scared of doing this request,
现在，你可能有点害怕做这个请求，

1556
01:07:31,513 --> 01:07:35,415
what if it's matches a million things, okay?
如果匹配一百万件呢?

1557
01:07:35,484 --> 01:07:38,818
Are you gonna get a million Tweets back in one
你会收到一百万条回复吗

1558
01:07:38,887 --> 01:07:39,719
request like this?
这样的请求吗?

1559
01:07:39,788 --> 01:07:41,621
The answer is no.
答案是否定的。

1560
01:07:41,689 --> 01:07:45,658
This array that you get back is really super smart array.
你返回的这个数组非常智能。

1561
01:07:45,726 --> 01:07:48,693
It doesn't actually bring the data in from the database,
它实际上并没有从数据库中获取数据，

1562
01:07:48,762 --> 01:07:51,496
until you start asking for it, okay?
在你开始要求之前，好吗?

1563
01:07:51,565 --> 01:07:53,964
So until I ask for the Twitter user,
在我问推特用户之前，

1564
01:07:54,033 --> 01:07:56,133
a certain Twitter user's information,
一个特定的Twitter用户的信息，

1565
01:07:56,201 --> 01:07:58,401
the Twitter user's name, the Twitter user's screen name,
推特用户的名字，推特用户的屏幕名，

1566
01:07:58,470 --> 01:08:00,403
the Twitter user did not get faulted from the database.
Twitter用户没有从数据库中出错。

1567
01:08:00,472 --> 01:08:01,904
This is called faulting, okay?
这叫做断层作用?

1568
01:08:01,973 --> 01:08:03,706
And so, these objects, you can imagine,
这些物体，你可以想象，

1569
01:08:03,775 --> 01:08:05,941
they're kind of shells, empty shells.
它们是贝壳，空壳。

1570
01:08:06,010 --> 01:08:07,276
And until you crack open the shell and
直到你打开壳

1571
01:08:07,344 --> 01:08:08,810
start looking inside,
开始在里面,

1572
01:08:08,879 --> 01:08:10,811
it doesn't actually get the data for you.
它实际上并没有为你获取数据。

1573
01:08:10,880 --> 01:08:12,546
And the reason this matters to you is,
这对你来说很重要，

1574
01:08:12,615 --> 01:08:15,482
if you go in the debugger, or you do a print statement,
如果你进入调试器，或者你做一个打印声明，

1575
01:08:15,551 --> 01:08:20,220
like this one where you say, for user in recentTweeters
就像你说的这个，用户在最近的推特

1576
01:08:20,289 --> 01:08:23,423
fetched user whatever, when you print that out,
当你把它打印出来的时候，

1577
01:08:23,492 --> 01:08:26,159
it's not gonna print the, a Tweeter user object,
它不会打印，Tweeter用户对象，

1578
01:08:26,227 --> 01:08:29,261
it's gonna print some kind of faulting shel.
它会打印出一些错误的shel。

1579
01:08:29,330 --> 01:08:30,529
Because you haven't actually asked for
因为你还没有要求

1580
01:08:30,598 --> 01:08:32,631
any of the data inside that thing yet, so
里面有任何数据

1581
01:08:32,699 --> 01:08:34,065
it hasn't faulted yet.
它还没有断裂。

1582
01:08:34,134 --> 01:08:34,899
But if you say, for
但如果你说，因为

1583
01:08:34,968 --> 01:08:38,169
user in recentTweeters and say fetched user named, and
用户在最近的tweeter和说获取的用户名，和

1584
01:08:38,238 --> 01:08:41,438
now you say user.name, now you are faulting this object in.
现在你说user。name，现在你在把这个对象错了。

1585
01:08:41,507 --> 01:08:42,205
In fact, this for
事实上,这

1586
01:08:42,274 --> 01:08:45,809
loop would fault all these objects in to memory.
loop将把所有这些对象都记在内存中。

1587
01:08:45,877 --> 01:08:47,410
Okay, fetch them all, cuz you're asking for
好吧，把它们都拿来，因为你要的

1588
01:08:47,479 --> 01:08:48,411
the name of every single one.
每个人的名字。

1589
01:08:48,480 --> 01:08:50,445
Boom, fault, fault, fault, they're all coming in.
砰，错，错，错，他们都进来了。

1590
01:08:50,514 --> 01:08:53,449
Now, it doesn't do it one by one, it faults in batches,
它不是一个接一个地做，而是分批处理，

1591
01:08:53,517 --> 01:08:55,717
it's really high performance, so,
它的性能很好，

1592
01:08:55,785 --> 01:08:57,752
you know, don't worry about that.
你知道，别担心。

1593
01:08:57,821 --> 01:09:00,455
But just, I just don't want you to be surprised
但是，我只是不想让你感到惊讶

1594
01:09:00,524 --> 01:09:01,054
when you go in the debugger and
当你进入调试器和

1595
01:09:01,123 --> 01:09:02,957
you're like, I printed out this Twitter, user and
你就像，我打印了这个推特，用户和

1596
01:09:03,026 --> 01:09:04,858
there's no screen name, what's going on?
没有屏幕名称，发生了什么?

1597
01:09:04,927 --> 01:09:06,492
Well, it hasn't faulted it in.
它没有断裂。

1598
01:09:06,561 --> 01:09:07,993
In fact, the debugger you could say,
实际上，调试器你可以说，

1599
01:09:08,062 --> 01:09:09,862
print the user.name,
打印user.name,

1600
01:09:09,931 --> 01:09:13,332
and it would fault it in, okay, give it to you.
它会对你造成错误，好的，给你。

1601
01:09:15,369 --> 01:09:17,568
All right, I told you I was gonna talk about Core Data
好吧，我告诉过你我会讲到Core Data

1602
01:09:17,637 --> 01:09:19,470
thread safety, so here it is.
线程安全，这里。

1603
01:09:19,539 --> 01:09:22,873
NSManagedObjectContext, the context thing,
NSManagedObjectContext,上下文的事情,

1604
01:09:22,942 --> 01:09:24,775
that thing that you're sending executes to,
你发送的那个东西会被执行，

1605
01:09:24,844 --> 01:09:27,544
that thing that you're hitting save, the things that you're
那就是你正在努力拯救的东西，你所拥有的东西

1606
01:09:27,613 --> 01:09:30,280
using to create Tweet, Tweet, subcontext,
使用创建Tweet,Tweet，子上下文，

1607
01:09:30,349 --> 01:09:33,817
colon whatever, that handle on database is not thread safe.
无论如何，数据库的处理不是线程安全的。

1608
01:09:35,052 --> 01:09:38,420
A context can only be used on the queue
上下文只能在队列上使用

1609
01:09:38,489 --> 01:09:41,156
that it was created on, period.
它是在一段时间内创造出来的。

1610
01:09:41,225 --> 01:09:44,492
If you past a context to another queue,
如果你经过一个context到另一个队列，

1611
01:09:44,561 --> 01:09:47,194
like you tried to dispatch off to some
就像你试图向一些人发送

1612
01:09:47,263 --> 01:09:50,030
global concurrent queue, and you pasted the context, or
全局并发队列，您粘贴了上下文，或者

1613
01:09:50,099 --> 01:09:52,866
even just pasted a Tweet, okay, that's not gonna work,
即使只是贴了一条推文，也不会起作用，

1614
01:09:52,935 --> 01:09:55,335
cuz that Tweet was created on this other context.
这条推特是在另一个背景下创建的。

1615
01:09:55,403 --> 01:09:56,870
So in fact, not only the context,
所以事实上，不仅是背景，

1616
01:09:56,939 --> 01:09:59,372
but everything that you create on that context
但你在这方面所创造的一切

1617
01:09:59,441 --> 01:10:01,907
has to all be done in the same queue.
必须在相同的队列中完成。

1618
01:10:01,976 --> 01:10:03,175
So now you're probably thinking,
现在你可能在想，

1619
01:10:03,244 --> 01:10:07,145
well how the heck do I do multithreading then?
那我到底怎么做多线程呢?

1620
01:10:07,214 --> 01:10:10,315
Cuz a database especially, you can imagine, for
尤其是数据库，你可以想象

1621
01:10:10,384 --> 01:10:13,584
temple one to load your database off the main queue,
temple one将你的数据库加载到主队列，

1622
01:10:13,653 --> 01:10:15,853
cuz you, you might be loading lots and lots of things.
因为你，你可能正在装载很多东西。

1623
01:10:15,922 --> 01:10:16,586
Now your queries,
现在你的查询,

1624
01:10:16,655 --> 01:10:19,255
your probably gonna do those on the main queue because,
你可能会在主队列上做这些，

1625
01:10:19,324 --> 01:10:20,890
the user's looking at that information.
用户正在查看这些信息。

1626
01:10:20,959 --> 01:10:22,157
You want it to be highly responsive.
你希望它反应灵敏。

1627
01:10:22,226 --> 01:10:25,794
Okay, it's probably worth, and core data is super fast,
很可能，核心数据非常快，

1628
01:10:25,863 --> 01:10:27,029
especially with queries.
尤其是在查询。

1629
01:10:27,097 --> 01:10:28,797
So, you could probably do that on the main queue.
你可以在主队列上做。

1630
01:10:28,866 --> 01:10:29,464
But loading it up,
但加载它,

1631
01:10:29,532 --> 01:10:31,432
you probably don't want to do that.
你可能不想这么做。

1632
01:10:31,501 --> 01:10:33,734
All right, so, how do we do multithreading?
好，那么，我们怎么做多线程呢?

1633
01:10:33,803 --> 01:10:36,570
Although that we do multithreading in Core Data,
虽然我们在Core Data中做多线程，

1634
01:10:36,638 --> 01:10:43,110
is each database can have multiple contexts, okay?
每个数据库都可以有多个上下文，对吗?

1635
01:10:43,179 --> 01:10:47,247
So, the database underneath, is multithreaded,
下面的数据库是多线程的，

1636
01:10:47,315 --> 01:10:50,850
it can have multiple contexts writing to it.
它可以有多个上下文写入它。

1637
01:10:50,918 --> 01:10:52,784
Okay, completely different context,
好的,完全不同的背景下,

1638
01:10:52,853 --> 01:10:55,820
writing to the same database, in different queue's even, so
写入相同的数据库，在不同的队列中，甚至

1639
01:10:55,889 --> 01:10:57,622
it's fully multithreaded.
它是完全多线程。

1640
01:10:57,691 --> 01:11:00,992
So that means we had to have a context for every queue.
这意味着我们必须为每个队列都有一个context。

1641
01:11:01,060 --> 01:11:03,361
Whatever queue we're going to access the database,
不管我们要访问哪个队列，

1642
01:11:03,430 --> 01:11:04,896
we have to a context in every queue.
我们必须在每个队列中都有一个上下文。

1643
01:11:04,964 --> 01:11:07,230
Now I'm gonna show you how to create a context, or
现在，我将向您展示如何创建上下文，或者

1644
01:11:07,299 --> 01:11:07,997
on another queue, so
另一个队列,因此

1645
01:11:08,066 --> 01:11:10,467
you can do something with that queue in a second here.
你可以在这个队列中做一些事情。

1646
01:11:10,535 --> 01:11:12,101
But first I want to talk about this important
但首先我想谈谈这个重要的事情

1647
01:11:12,170 --> 01:11:15,471
method in context called performBlock.
在上下文中的方法称为performBlock。

1648
01:11:15,539 --> 01:11:17,373
performBlock just takes a closure,
performBlock只需要关闭，

1649
01:11:17,441 --> 01:11:18,807
a closure that takes no arguments,
一个没有参数的闭包，

1650
01:11:18,875 --> 01:11:22,677
returns no arguments, and it will ensure, this is
不返回任何参数，它将确保这是

1651
01:11:22,746 --> 01:11:27,381
an insurance method, it will ensure that everything inside
一种保险方法，它能保证里面的一切

1652
01:11:27,450 --> 01:11:32,086
that closure happens on the right queue for that context.
该闭包发生在该上下文的正确队列上。

1653
01:11:32,154 --> 01:11:34,955
Okay, so this, don't get confused,
好的，这个，不要搞混了，

1654
01:11:35,024 --> 01:11:38,125
this method does not dispatch, you know,
这个方法不会发送，你知道，

1655
01:11:38,193 --> 01:11:42,562
cause background thrading, this is just making sure that,
因为背景色，这是为了确保，

1656
01:11:42,631 --> 01:11:45,998
that closure executes on the right queue.
该闭包在正确的队列上执行。

1657
01:11:46,067 --> 01:11:48,433
So this is a way that you can kind of be safe.
这是一种安全的方法。

1658
01:11:48,502 --> 01:11:50,735
And some might argue you should put performBlock around
有些人可能会说，你应该把performBlock放在周围

1659
01:11:50,804 --> 01:11:53,238
every single call to every Core Data thing you ever do,
每个呼叫到你做过的每一个核心数据，

1660
01:11:53,307 --> 01:11:56,307
because that will ensure that you'll never have a problem
因为那将确保你永远不会有问题

1661
01:11:56,376 --> 01:11:59,811
where you're accessing the context not on it's queue.
访问上下文而不是队列。

1662
01:11:59,879 --> 01:12:01,778
Okay, it accidentally, you got some bad code.
不小心，你有一些坏代码。

1663
01:12:01,847 --> 01:12:06,483
Now, that might be a little bit overkill especially if
现在，这可能有点过分了，尤其是

1664
01:12:06,552 --> 01:12:09,352
you're mostly using the main queue anyway, and
不管怎样，你基本上都在使用主队列

1665
01:12:09,421 --> 01:12:12,355
you really, maybe you only use background queues for
实际上，您可能只使用后台队列

1666
01:12:12,424 --> 01:12:15,324
this tiny little bit of processing on the side.
这个小一点的处理。

1667
01:12:15,393 --> 01:12:17,993
It's not like you have the tons context and
它不像你有大量的上下文

1668
01:12:18,062 --> 01:12:20,695
lots of different queues all going at each other.
许多不同的队列都在互相攻击。

1669
01:12:20,764 --> 01:12:22,564
So, it might be overkill.
所以，它可能是过量的。

1670
01:12:22,632 --> 01:12:24,466
But if you're doing anything where you have,
但如果你在做任何事情，

1671
01:12:24,534 --> 01:12:27,202
truly have multiple context on multiple queues and
在多个队列中确实有多个上下文

1672
01:12:27,270 --> 01:12:31,572
they're access and things, this is a good way to be safe.
他们是有机会的，这是一个安全的好方法。

1673
01:12:31,641 --> 01:12:35,175
Okay, so all this does is it makes it so you are safe.
好了，所有这些都是为了让你安全。

1674
01:12:35,243 --> 01:12:39,346
The code inside that block will be executed on the proper
该块中的代码将在适当的地方执行

1675
01:12:39,415 --> 01:12:40,947
queue for that context.
队列上下文。

1676
01:12:41,015 --> 01:12:43,516
Even if it has to dispatch, it will do it if it has to.
即使它必须分派，它也会做如果它必须。

1677
01:12:43,585 --> 01:12:44,917
If it doesn't have to dispatch,
如果不需要分派，

1678
01:12:44,986 --> 01:12:47,786
if you're on the right queue, it'll just execute it, fine.
如果你在正确的队列上，它就会执行它，很好。

1679
01:12:47,855 --> 01:12:49,387
But if you're on the wrong queue right now and
但如果你现在排错队了

1680
01:12:49,456 --> 01:12:50,055
you execute this,
你执行这个,

1681
01:12:50,124 --> 01:12:52,056
it will dispatch it to the right queue.
它将把它发送到正确的队列。

1682
01:12:52,125 --> 01:12:53,991
There's also performBlockAndWait,
还有performBlockAndWait,

1683
01:12:54,060 --> 01:12:55,659
which will get it on the right queue and
哪一个会把它放在正确的队列上

1684
01:12:55,728 --> 01:12:58,062
wait until it's done, and then continue in your queue.
等待它完成，然后继续在您的队列中。

1685
01:12:59,298 --> 01:13:01,597
Okay, but this doesn't really talk about,
但这并不是真正的讨论，

1686
01:13:01,666 --> 01:13:05,100
how do I get another context in a different thread, right?
如何在不同的线程中获取另一个上下文?

1687
01:13:05,169 --> 01:13:07,969
I wanna do some code on another thread.
我想在另一个线程上做一些代码。

1688
01:13:08,038 --> 01:13:09,370
Where do I get a context?
我从哪里得到上下文?

1689
01:13:09,439 --> 01:13:12,840
The only context I know how to get right now is viewContext.
我所知道的唯一的上下文是viewContext。

1690
01:13:12,909 --> 01:13:14,909
That's the main queue's context,
这是主队列的上下文，

1691
01:13:14,978 --> 01:13:16,143
that's the only only one I can get.
这是我唯一能得到的。

1692
01:13:16,212 --> 01:13:18,812
Okay, well, you're gonna use this really cool method
好吧，你要用这个很酷的方法

1693
01:13:18,881 --> 01:13:20,013
in persistentContainer.
在persistentContainer。

1694
01:13:20,082 --> 01:13:24,050
This is new in iOS 10 and a really cool method,
这是iOS 10中的新方法，非常酷的方法，

1695
01:13:24,119 --> 01:13:25,185
super cool.
超级酷。

1696
01:13:25,253 --> 01:13:27,954
It makes it really easy to do background process on
这使得做后台处理很容易

1697
01:13:28,022 --> 01:13:29,188
Core Data.
核心数据。

1698
01:13:29,256 --> 01:13:31,256
It's called performBackgroundTask.
它叫做performBackgroundTask。

1699
01:13:31,324 --> 01:13:34,292
Remember, this is a function on persistentContainer that
记住，这是一个关于persistentContainer的函数

1700
01:13:34,361 --> 01:13:36,327
you get from the AppDelegate.
从AppDelegate获得。

1701
01:13:36,396 --> 01:13:38,129
And this takes a closure.
这需要关闭。

1702
01:13:38,197 --> 01:13:42,866
This closure has one argument, the argument is a context.
这个闭包有一个参数，参数是上下文。

1703
01:13:42,935 --> 01:13:45,569
And that context is appropriate for use
这个上下文适合使用

1704
01:13:45,638 --> 01:13:49,172
on this other thread that this is going to create for you.
在另一个线程上，它将为你创建。

1705
01:13:49,240 --> 01:13:52,107
So this performBackgroundTask finds another queue,
这个performBackgroundTask找到另一个队列，

1706
01:13:52,176 --> 01:13:55,044
not the main queue, some other queue.
不是主队列，也不是其他队列。

1707
01:13:55,113 --> 01:13:58,346
And it creates a context in that other queue, and it
它在另一个队列中创建了一个上下文

1708
01:13:58,415 --> 01:14:02,584
executes your closure on that other queue in the background.
在后台的另一个队列上执行闭包。

1709
01:14:03,853 --> 01:14:05,153
Now, it's a convenience method.
现在，这是一个方便的方法。

1710
01:14:05,221 --> 01:14:07,855
So if you really needed to control the quality of
所以如果你真的需要控制质量

1711
01:14:07,923 --> 01:14:10,724
service, for example, the queue and all the, okay, well,
服务，例如，队列和所有的，好的，

1712
01:14:10,793 --> 01:14:11,558
you can't use this.
你不能使用这个。

1713
01:14:11,626 --> 01:14:14,694
But 99.99% of the time, whatever quality of
但是99.99%的时间，无论质量如何

1714
01:14:14,762 --> 01:14:17,330
service that queue is getting is the right one for
队列的服务是正确的

1715
01:14:17,398 --> 01:14:19,499
Core Data cuz Core Data knows its business.
Core Data cuz Core Data知道它的业务。

1716
01:14:20,801 --> 01:14:21,633
So you're gonna do it.
所以你要去做。

1717
01:14:21,702 --> 01:14:25,169
Now, inside this closure couple of things really
现在，在这关闭的几件事里面

1718
01:14:25,238 --> 01:14:26,037
be careful of.
小心的。

1719
01:14:26,105 --> 01:14:28,839
One, never use viewContext in here.
第一，不要在这里使用viewContext。

1720
01:14:28,908 --> 01:14:32,242
Do you see why that would be horrendously bad to
你知道为什么那是可怕的坏事吗

1721
01:14:32,311 --> 01:14:34,911
use viewContext inside this closure?
在这个闭包中使用viewContext ?

1722
01:14:34,980 --> 01:14:37,781
Because this closure by definition is not executing on
因为这个定义没有执行

1723
01:14:37,849 --> 01:14:39,415
the main queue.
主要的队列。

1724
01:14:39,484 --> 01:14:41,350
By definition this closure is on a separate
根据定义，这个闭包是独立的

1725
01:14:41,419 --> 01:14:42,718
queue on a background queue.
在后台队列上排队。

1726
01:14:42,787 --> 01:14:44,452
That's the whole point of this thing,
这就是问题的关键，

1727
01:14:44,521 --> 01:14:46,121
is to put this thing on another queue.
就是把这个放到另一个队列上。

1728
01:14:46,189 --> 01:14:48,255
So never use viewContext in there,
不要使用viewContext，

1729
01:14:48,324 --> 01:14:50,257
that's why it's in red, okay?
这就是为什么它是红色的?

1730
01:14:50,326 --> 01:14:55,062
The second thing is don't forget to save this context.
第二件事是别忘了保存这个上下文。

1731
01:14:55,130 --> 01:14:56,629
If you do a whole bunch of stuff in here and
如果你在这里做一大堆东西

1732
01:14:56,698 --> 01:14:58,264
you don't save, you just did for
你不存钱，你只是做了

1733
01:14:58,333 --> 01:14:59,699
nothing cuz you did in memory.
没有你在记忆中做过的事。

1734
01:14:59,768 --> 01:15:02,601
And then this block went away, you're never gonna get that
然后这个块消失了，你永远不会得到它

1735
01:15:02,670 --> 01:15:05,804
context back again, that data is lost.
上下文又回来了，数据丢失了。

1736
01:15:05,873 --> 01:15:08,507
Which all gonna leave the heap and then nothing ever happens.
所有这些都会离开堆，然后什么也没有发生。

1737
01:15:08,575 --> 01:15:10,875
It never gonna get committed to the database.
它永远不会提交到数据库。

1738
01:15:10,944 --> 01:15:12,944
So, don't forget to save before you leave.
所以，在你离开之前别忘了存钱。

1739
01:15:14,113 --> 01:15:15,679
Now, when you save,
现在,当你保存,

1740
01:15:15,748 --> 01:15:18,515
it will push it down to the database and
它会把它推到数据库

1741
01:15:18,584 --> 01:15:23,186
your other context like your viewContext will see it, okay?
你的其他背景，比如你的viewContext会看到它，对吧?

1742
01:15:23,255 --> 01:15:26,022
And so these two contexts, the one that's happening on this
所以这两种情况，发生在这

1743
01:15:26,091 --> 01:15:27,423
background and the viewContext.
背景和viewContext。

1744
01:15:27,492 --> 01:15:29,291
They're working on the same database, so
他们在同一个数据库上工作

1745
01:15:29,360 --> 01:15:30,192
when this one saves,
当这一保存,

1746
01:15:30,261 --> 01:15:33,027
boom this guys is gonna start seeing those changes.
嘣，这家伙就会看到这些变化。

1747
01:15:33,096 --> 01:15:36,430
I'm gonna talk a little bit how react to seeing those
我要讲一下看到这些的反应

1748
01:15:36,499 --> 01:15:38,266
changes in a minute here.
这里有一分钟的变化。

1749
01:15:39,468 --> 01:15:41,334
Okay, so, everyone understand this?
大家都明白了吗?

1750
01:15:41,403 --> 01:15:43,703
Cuz you're gonna have to do this in assignment five.
因为你必须在作业5中做这个。

1751
01:15:43,772 --> 01:15:47,040
And I want you to do all your loading off the main queue,
我要你把所有的加载都从主队列出来，

1752
01:15:47,109 --> 01:15:49,709
and all your fetching on the main queue.
以及你在主队列上的所有取回。

1753
01:15:50,845 --> 01:15:56,315
All right, Core Data is huge.
好的，Core Data是巨大的。

1754
01:15:56,384 --> 01:15:56,948
Huge.
巨大的。

1755
01:15:58,351 --> 01:15:59,484
I can't cover it all.
我不能全包住。

1756
01:16:00,686 --> 01:16:02,085
It's got optimistic locking, for
这是一个乐观的锁定

1757
01:16:02,154 --> 01:16:03,053
those of you that know about database.
那些了解数据库的人。

1758
01:16:03,121 --> 01:16:06,423
It's got optimistic locking and all that database stuff.
它有乐观锁定和所有数据库内容。

1759
01:16:06,491 --> 01:16:10,025
It has full undo, redo, which is incredible.
它有完全的撤销，重做，这是令人难以置信的。

1760
01:16:10,094 --> 01:16:13,462
It obviously knows how to roll back unsaved changes.
它显然知道如何回滚未保存的更改。

1761
01:16:13,531 --> 01:16:15,330
Okay, if you have changes in memory and
好的，如果你的记忆发生了变化

1762
01:16:15,398 --> 01:16:16,297
you want to roll some of them back,
你想把它们卷回去，

1763
01:16:16,366 --> 01:16:17,966
you can do that before you save.
在你存钱之前你可以这样做。

1764
01:16:18,034 --> 01:16:20,534
It knows about staleness, like, if I make a fetch,
它知道什么是过时，比如，如果我做一个取回，

1765
01:16:20,603 --> 01:16:23,870
how long before I really wanna fetch it again because I don't
在我真正想要取回它之前多久，因为我没有

1766
01:16:23,939 --> 01:16:26,206
trust that the data hasn't changed, right?
相信数据没有改变，对吧?

1767
01:16:26,274 --> 01:16:28,574
How long it takes for the data to get stale.
数据要多久才会失效。

1768
01:16:28,643 --> 01:16:31,710
And a lot of other things in the Core Data.
Core Data中还有很多其他的东西。

1769
01:16:31,779 --> 01:16:33,212
So, I can't cover it all,
所以，我无法涵盖所有的内容，

1770
01:16:33,280 --> 01:16:35,247
there's not enough time to do that.
没有足够的时间去做。

1771
01:16:35,316 --> 01:16:37,749
Cuz we're trying to talk about a whole another topic about
因为我们正试着讨论另一个话题

1772
01:16:37,818 --> 01:16:39,217
But you'll want to check the documentation, you won't need
但是您需要检查文档，您不需要

1773
01:16:39,218 --> 01:16:40,617
Core Data here.
核心数据。

1774
01:16:40,687 --> 01:16:43,521
anything else of this stuff to do your homeworks, of course,
当然，还有其他的东西可以做作业，

1775
01:16:43,589 --> 01:16:45,689
I'm just trying to get you started with this.
我只是想让你从这个开始。

1776
01:16:45,757 --> 01:16:48,224
But you need to know that this stuff is in there, so that
但是你需要知道这些东西在里面，所以

1777
01:16:48,293 --> 01:16:52,562
one day when you go out and do some significant iOS database
有一天当你出去做一些重要的iOS数据库时

1778
01:16:52,631 --> 01:16:54,764
stuff, you'll know that these features are out there.
东西，你会知道这些功能在外面。

1779
01:16:56,300 --> 01:17:01,503
All right, the next topic here is Core Data and UITableView.
好，下一个主题是Core Data和UITableView。

1780
01:17:01,572 --> 01:17:05,306
As you can imagine, this is a marriage made in heaven, okay?
你们可以想象，这是一个在天堂里制造的婚姻，对吧?

1781
01:17:05,375 --> 01:17:06,908
Because you got this database,
因为你有了这个数据库，

1782
01:17:06,977 --> 01:17:09,244
got all this big data sets in there and
所有这些大数据集都在这里

1783
01:17:09,312 --> 01:17:13,681
what is the UI we use to show big data sets in iOS?
我们在iOS中显示大数据集的UI是什么?

1784
01:17:13,750 --> 01:17:14,982
UITableView.
UITableView。

1785
01:17:15,051 --> 01:17:18,152
Okay, UITableView is great at showing arbitrary large
UITableView很擅长显示任意大小

1786
01:17:19,487 --> 01:17:22,288
data sets in our arbitrary UIs, right?
数据集在任意的ui中?

1787
01:17:22,357 --> 01:17:23,655
We can do custom table view cell,
我们可以做自定义表格视图单元格，

1788
01:17:23,724 --> 01:17:26,191
we can do anything UI we want.
我们可以做任何想要的UI。

1789
01:17:26,260 --> 01:17:30,429
So, this is so common that Apple has invented this very
所以，这是很常见的，苹果公司发明了这个

1790
01:17:30,497 --> 01:17:33,965
important class called NSFetchedResultsController.
重要的类称为NSFetchedResultsController。

1791
01:17:34,034 --> 01:17:36,333
This is not a viewController, okay?
这不是一个viewController ?

1792
01:17:36,402 --> 01:17:39,403
This is a controller that controls Core Data and
这是一个控制核心数据的控制器

1793
01:17:39,472 --> 01:17:40,571
UITableView talking together,
UITableView说在一起,

1794
01:17:40,639 --> 01:17:44,607
but it's not in its fetch results view controller, okay?
但它不是在它的fetchedresultsviewcontroller中，对吧?

1795
01:17:44,676 --> 01:17:47,277
And all this NSFetchedResultsController
所有这些NSFetchedResultsController

1796
01:17:47,346 --> 01:17:50,513
does is it hooks up an NSFetchRequest that you create
它是否与您创建的NSFetchRequest挂钩

1797
01:17:50,582 --> 01:17:52,481
to a UITableView.
UITableView。

1798
01:17:52,550 --> 01:17:55,651
And it hooks them up in such a strong way that if anything
它以一种强有力的方式将它们连接起来

1799
01:17:55,720 --> 01:17:59,087
changes in the database that would cause that fetch request
数据库中的更改将导致获取请求

1800
01:17:59,156 --> 01:18:02,090
to return different results, it updates the table
为了返回不同的结果，它更新了表格

1801
01:18:02,158 --> 01:18:04,993
automatically, you don't have to do anything.
自动地，你不需要做任何事情。

1802
01:18:05,062 --> 01:18:09,096
So this is an active live hookup between
这是一个活跃的活的连接

1803
01:18:09,165 --> 01:18:14,467
the NSFetchRequest and the TableView, okay?
NSFetchRequest和TableView ?

1804
01:18:14,536 --> 01:18:17,370
Even if some other context are changing the data, it doesn't
即使一些其他的上下文正在改变数据，它也没有

1805
01:18:17,439 --> 01:18:20,807
matter, it's always keeping that TableView up to date.
重要的是，它一直保持着这个TableView。

1806
01:18:21,977 --> 01:18:25,011
So I'm gonna talk about how we do this,
我要讲一下我们是怎么做的，

1807
01:18:25,080 --> 01:18:28,980
how we use an NSFetchedResultsController.
我们如何使用一个NSFetchedResultsController。

1808
01:18:29,049 --> 01:18:31,550
I'm even gonna provide you some kind of free code
我甚至会给你提供一些免费的代码

1809
01:18:31,619 --> 01:18:32,984
to do some of it.
做一些。

1810
01:18:33,053 --> 01:18:34,586
You'll have to type in a little bit of the rest of it.
你得输入一点剩下的部分。

1811
01:18:34,654 --> 01:18:37,455
But it's, it's pretty easy to do.
但这很容易做到。

1812
01:18:39,191 --> 01:18:40,657
So how fundamentally does
那么如何从根本上

1813
01:18:40,726 --> 01:18:42,725
NSFetchedResultsController work?
NSFetchedResultsController工作吗?

1814
01:18:42,794 --> 01:18:46,596
Two ways, one, it has a delegate and
有两种方法，一种是委托

1815
01:18:46,664 --> 01:18:50,600
that delegate you set to be your UITableViewController.
这个委托就是UITableViewController。

1816
01:18:50,668 --> 01:18:53,001
And whenever the FetchResultsController sees
当FetchResultsController看到

1817
01:18:53,070 --> 01:18:53,802
something happening
发生了一些事情

1818
01:18:53,871 --> 01:18:56,638
in the database that would affect that fetchRequest,
在会影响fetchRequest的数据库中，

1819
01:18:56,706 --> 01:18:59,707
it tells the table view controller, hey, do this,
它告诉表视图控制器，

1820
01:18:59,776 --> 01:19:02,843
add this row, add a section, reload this row, whatever,
添加这一行，添加一个section，重载这一行，

1821
01:19:02,911 --> 01:19:09,349
it uses UITableView primitives to update the table, okay?
它使用UITableView原语来更新表，对吧?

1822
01:19:09,418 --> 01:19:10,350
I'm gonna show you,
我要告诉你,

1823
01:19:10,419 --> 01:19:12,318
I'm gonna give you the code that does that part of it,
我将给你代码，

1824
01:19:12,387 --> 01:19:14,454
that implements the NSFetchedResultsController's
实现NSFetchedResultsController

1825
01:19:14,522 --> 01:19:16,422
delegate, okay, so that's one way it does it.
委托，好的，这是它的一种方式。

1826
01:19:16,491 --> 01:19:18,758
The other way that the NSFetchedResultsController
NSFetchedResultsController的另一种方式

1827
01:19:18,826 --> 01:19:21,493
works is that it provides implementation for
工作是它提供实现

1828
01:19:21,562 --> 01:19:24,763
all of your UITableView data sources methods, right?
所有UITableView数据源方法，对吧?

1829
01:19:24,831 --> 01:19:26,631
Because the contents of your table
因为你桌子的内容

1830
01:19:26,700 --> 01:19:28,131
are coming out of the database,
从数据库中出来，

1831
01:19:28,200 --> 01:19:30,668
so NSFetchedResultsController lets you know all of them, how
所以NSFetchedResultsController让你知道所有这些,怎么做

1832
01:19:30,736 --> 01:19:33,436
many sections, how many rows and sections all that stuff.
很多分段，有多少行和分段。

1833
01:19:33,505 --> 01:19:35,204
In fact, this is what it looks like,
事实上，这就是它的样子，

1834
01:19:35,273 --> 01:19:37,874
this is the implementation that you're gonna put in to
这是你要放入的实现

1835
01:19:37,942 --> 01:19:41,077
your controller when you have fetchedResultsController.
当你有,fetchedResultsController控制器。

1836
01:19:41,146 --> 01:19:42,077
The first thing you're gonna
你要做的第一件事

1837
01:19:42,146 --> 01:19:44,212
do is you're gonna create a fetchedResultsController, and
做的是你要创建一个,fetchedResultsController,

1838
01:19:44,281 --> 01:19:46,448
I'm gonna show you how to do that in a moment.
我一会儿会告诉你们怎么做。

1839
01:19:46,516 --> 01:19:48,382
And so you're always gonna have a var called
所以你总是会调用一个var

1840
01:19:48,451 --> 01:19:50,518
fetchedResultsController, and
,fetchedResultsController,

1841
01:19:50,586 --> 01:19:53,386
it's gonna be of type NSFetchedResultsController.
它会NSFetchedResultsController类型。

1842
01:19:53,455 --> 01:19:56,056
And when you have that var, now you can implement your
当你有了这个var，现在你可以实现你的

1843
01:19:56,125 --> 01:19:59,659
sections, number of sections in TableView by saying return
分段，在TableView中，通过返回来表示

1844
01:19:59,728 --> 01:20:04,731
fetchedResultsController .sections.count, okay?
,fetchedResultsController .sections。数,好吗?

1845
01:20:04,800 --> 01:20:06,231
Those are a lot of optionals in there, so
那里有很多选择，所以

1846
01:20:06,300 --> 01:20:08,934
we'll default to one section.
我们将默认为一个部分。

1847
01:20:09,003 --> 01:20:10,969
And then to get the number of rows in a section,
然后为了得到section中的行数，

1848
01:20:11,038 --> 01:20:12,771
you're just gonna say the,
你只是想说，

1849
01:20:12,839 --> 01:20:14,539
you're gonna get the sections first by saying
你会先说

1850
01:20:14,608 --> 01:20:16,640
fetchedResultsController?.sec- tions.
,fetchedResultsController ?。秒,。

1851
01:20:16,709 --> 01:20:21,445
And as long as you have some sections, sections.count
只要你有部分，sections.count

1852
01:20:21,514 --> 01:20:24,748
greater than zero, then you're gonna return the sections in
大于零，然后你将返回这些部分

1853
01:20:24,817 --> 01:20:27,650
that section that's passed to you number of objects.
这个部分传递给你的对象数。

1854
01:20:27,719 --> 01:20:31,087
Okay, so that code, that's it, that's all of your, those two
好的，这就是代码，这就是你们所有的，这两个

1855
01:20:31,155 --> 01:20:34,390
methods, that's the entire implementation if you're using
方法，如果使用的话，这就是整个实现

1856
01:20:34,458 --> 01:20:36,491
a fetchedResultsController, okay?
,fetchedResultsController ?

1857
01:20:36,560 --> 01:20:39,394
And then of course, there's cellForRowAt, okay,
当然，还有cellForRowAt，好的，

1858
01:20:39,463 --> 01:20:41,629
you gotta implement that, that one too,
你也要实现这个，

1859
01:20:41,698 --> 01:20:44,298
you're gonna use fetchedResultsController.
你会使用,fetchedResultsController。

1860
01:20:44,367 --> 01:20:48,869
And the most important thing about cellForRowAt is you need
关于cellForRowAt，最重要的是你需要

1861
01:20:48,938 --> 01:20:53,274
to know what's at that row, which thing in my database is
要知道这一行是什么，数据库中是什么

1862
01:20:53,343 --> 01:20:56,909
at that row in that section in my table.
在我桌子的那一排。

1863
01:20:56,978 --> 01:21:00,480
And you get that by asking the fetchedResultsController with
你可以通过询问fetchedResultsController来得到它

1864
01:21:00,549 --> 01:21:02,481
this method objectAtIndexPath.
这种方法objectAtIndexPath。

1865
01:21:02,550 --> 01:21:05,117
So you just say fetchedResultsController,
你只是说,fetchedResultsController,

1866
01:21:05,186 --> 01:21:08,520
give me the object, and that object is gonna be a tweet, or
给我对象，那个对象将是一条tweet，或者

1867
01:21:08,589 --> 01:21:11,189
a Twitter user, or whatever, some entity.
一个推特用户，或者别的什么实体。

1868
01:21:11,258 --> 01:21:13,691
Give me an object at the index path
在索引路径上给我一个对象

1869
01:21:13,760 --> 01:21:17,262
that cellForRowAt indexPath is asking me for.
那个cellForRowAt indexPath正在请求我。

1870
01:21:17,330 --> 01:21:19,363
So now I have the Twitter user or the tweet,
现在我有了推特用户或推特，

1871
01:21:19,432 --> 01:21:21,232
I can easily load up my UI.
我可以轻松地加载UI。

1872
01:21:21,300 --> 01:21:24,667
You know, pass it off to my UI, custom UITableView cell,
你知道，把它传递给我的UI，自定义UITableView cell，

1873
01:21:24,736 --> 01:21:25,902
or if I have a subtitle cell,
或者如果我有一个subtitle cell，

1874
01:21:25,971 --> 01:21:27,970
just take a couple of things out of there and
把这些东西拿出来

1875
01:21:28,039 --> 01:21:30,105
put it in the text label in the detailed text label,
把它放到文本标签中，

1876
01:21:30,174 --> 01:21:31,340
you see what I'm saying?
你明白我的意思吗?

1877
01:21:31,408 --> 01:21:34,642
But you can see that the fetchedResultsController,
但是你可以看到,fetchedResultsController,

1878
01:21:34,711 --> 01:21:37,512
that code in yellow right there in the middle of
那个黄色的代码就在中间

1879
01:21:37,581 --> 01:21:39,180
cellForRowAt indexPath,
cellForRowAt indexPath,

1880
01:21:39,249 --> 01:21:42,416
that's doing all the work to figure out what tweet or
这是在做所有的工作来弄清楚推特或什么

1881
01:21:42,485 --> 01:21:45,653
what Twitter user is at this row in the table, okay?
推特用户在表格中的这一行?

1882
01:21:45,721 --> 01:21:47,120
So those code on the last slide and
这是最后一张幻灯片的代码

1883
01:21:47,189 --> 01:21:49,789
the code on this slide, you'll have to type that code in any
这张幻灯片上的代码，你必须键入代码

1884
01:21:49,858 --> 01:21:53,392
time you're using an NSFetchedResultsController.
当你使用一个NSFetchedResultsController。

1885
01:21:53,461 --> 01:21:56,028
Now, on the previous slide, one of the things was var
在之前的幻灯片中，其中一个是var

1886
01:21:56,097 --> 01:21:58,330
fetchedResultsController equals something.
,fetchedResultsController =。

1887
01:21:58,399 --> 01:22:00,566
So now let's talk about how we create
现在我们来谈谈我们是如何创造的

1888
01:22:00,634 --> 01:22:03,001
a fetchedResultsController, okay?
,fetchedResultsController ?

1889
01:22:03,070 --> 01:22:04,769
So this is what the initializer for
这就是初始化程序

1890
01:22:04,838 --> 01:22:07,304
NSFetchedResultsController looks like here.
NSFetchedResultsController看起来像。

1891
01:22:07,373 --> 01:22:09,273
It takes a request, a context.
它需要一个请求，一个context。

1892
01:22:09,342 --> 01:22:11,074
Obviously, it doesn't know what database
显然，它不知道什么是数据库

1893
01:22:11,143 --> 01:22:12,375
we're fetching in.
我们抓取。

1894
01:22:12,444 --> 01:22:15,444
And then it's got a sectionNameKeyPath.
然后它有一个sectionNameKeyPath。

1895
01:22:15,513 --> 01:22:19,682
That sectionNameKeyPath is the var in
sectionNameKeyPath是var in

1896
01:22:19,751 --> 01:22:24,519
that entity that, whose value is a string,
这个实体，它的值是一个字符串，

1897
01:22:24,588 --> 01:22:28,891
which is the title of the section it's in, okay?
这就是它的标题，明白吗?

1898
01:22:28,959 --> 01:22:31,425
That's how you do sections with fetchedResultsController.
这就是你做的部分,fetchedResultsController。

1899
01:22:31,494 --> 01:22:33,928
You just have to, and you might have to invent this or
你只需要，你可能需要发明这个或

1900
01:22:33,997 --> 01:22:35,195
even calculate this.
甚至计算。

1901
01:22:35,264 --> 01:22:38,265
But all of your tweets or all your Twitter users, if they're
但所有的推文或推特用户，如果他们是

1902
01:22:38,333 --> 01:22:40,800
gonna be in sections, they all have to have a var,
在分段中，它们都有一个var，

1903
01:22:40,869 --> 01:22:43,870
which is a string, which is the section they're in, okay,
这是一个字符串，这是它们所在的section，好的，

1904
01:22:43,939 --> 01:22:45,738
the name of the section they're in.
他们所处的区域的名称。

1905
01:22:45,807 --> 01:22:49,341
And as long as they have that, then the fetchedResults will,
只要他们有这些，fetchedResults就会，

1906
01:22:49,410 --> 01:22:50,843
will make the sections and
会做这些部分吗

1907
01:22:50,911 --> 01:22:53,344
put them all in there in the right section.
把它们都放在右边的部分。

1908
01:22:53,413 --> 01:22:56,681
And we'll talk about cacheName in a second here.
我们一会儿会讲到cacheName。

1909
01:22:56,749 --> 01:22:58,950
So we have to create a fetchRequest to put in here.
所以我们必须创建一个fetchRequest放在这里。

1910
01:22:59,019 --> 01:23:00,818
So here's an example of creating a fetchRequest for
这里有一个创建fetchRequest的例子

1911
01:23:00,887 --> 01:23:01,719
tweets, right?
微博,对吧?

1912
01:23:01,788 --> 01:23:03,486
So you recognize that first line there,
你知道第一行，

1913
01:23:03,555 --> 01:23:05,655
creating a fetchRequest for tweets.
创建tweet的fetchRequest。

1914
01:23:05,723 --> 01:23:09,625
And I'm gonna sort by when the tweets were created, okay,
我要在推文创建的时候排序，

1915
01:23:09,694 --> 01:23:11,427
when the tweet was tweeted out.
当这条推文被推出来的时候。

1916
01:23:11,496 --> 01:23:15,664
And I'm gonna look for all the tweets whose tweeter's name
我要找所有推特用户名的推文

1917
01:23:15,732 --> 01:23:18,734
equals some name, the name, okay?
等于名字，好吗?

1918
01:23:18,803 --> 01:23:20,468
So it's gonna get all those tweets, and
它会得到所有这些推文

1919
01:23:20,537 --> 01:23:22,903
I'm gonna set that request as the first argument there,
我将把这个请求设置为第一个参数，

1920
01:23:22,972 --> 01:23:24,471
to NSFetchedResultsController.
NSFetchedResultsController。

1921
01:23:24,540 --> 01:23:27,807
By the way, notice NSFetchedResultsController is
顺便说一下,请注意NSFetchedResultsController

1922
01:23:27,876 --> 01:23:31,612
also a generic type, and NSFetchedResultsController can
也是一个泛型类型,NSFetchedResultsController可以

1923
01:23:31,681 --> 01:23:34,313
only control fetches for a certain type.
只能控制特定类型的获取。

1924
01:23:34,382 --> 01:23:36,915
So you have to say what type, okay, what type of entity that
你必须说出哪种类型的实体

1925
01:23:36,984 --> 01:23:39,618
your FetchController is doing, and these are the same type of
FetchController正在做，这些是相同类型的

1926
01:23:39,687 --> 01:23:41,587
things that are in the rows of your table.
你桌子上的那些东西。

1927
01:23:42,956 --> 01:23:45,056
Now that cacheName at the bottom is interesting.
现在，底部的cacheName很有趣。

1928
01:23:45,124 --> 01:23:48,726
That is actually going to permanently cache the results.
这实际上会永久地缓存结果。

1929
01:23:48,794 --> 01:23:49,793
it's gonna get the results out of the database and
它会从数据库中得到结果

1930
01:23:49,794 --> 01:23:50,793
In other words,
换句话说,

1931
01:23:50,863 --> 01:23:55,532
store on disk the result in some internal format.
在磁盘上存储一些内部格式的结果。

1932
01:23:55,601 --> 01:23:57,667
And that's cool, and that storage, by the way,
这很酷，顺便说一下，

1933
01:23:57,735 --> 01:23:58,968
if you quit your app and come back,
如果你退出app回来，

1934
01:23:59,037 --> 01:24:01,904
it will still use that cache, so it's quite efficient.
它仍然会使用缓存，所以效率很高。

1935
01:24:01,973 --> 01:24:03,605
But you have to be a little bit careful.
但你得小心一点。

1936
01:24:03,674 --> 01:24:06,708
You cannot change anything about your request.
你不能改变你的要求。

1937
01:24:06,777 --> 01:24:09,578
As soon as you change anything about your request, like
一旦你改变了你的要求，就像

1938
01:24:09,646 --> 01:24:12,713
the name, the tweeter.name that you're searching for, or
你正在搜索的名字，tweeter . name

1939
01:24:12,782 --> 01:24:15,082
what you're sorting by, or anything.
你在排序什么，或者其他什么。

1940
01:24:15,151 --> 01:24:17,718
Now that cache is invalid, and you'll have to invalidate that
现在缓存无效，您将不得不使其无效

1941
01:24:17,786 --> 01:24:21,354
cache, okay, and there's an API in there for doing that.
缓存，这里有一个API。

1942
01:24:21,423 --> 01:24:24,057
You can pass nil there if you don't wanna do the caching,
如果你不想做缓存，你可以在那里传递nil，

1943
01:24:24,125 --> 01:24:28,027
which for most reasonable sized datasets perfectly fine,
对于大多数合理大小的数据集，

1944
01:24:28,095 --> 01:24:29,662
you don't really need the caching.
您并不真正需要缓存。

1945
01:24:29,730 --> 01:24:31,363
But I just wanna emphasize that if you change your
但我想强调的是，如果你改变了你的

1946
01:24:31,432 --> 01:24:34,700
request, your cache is now invalid.
请求，您的缓存现在无效。

1947
01:24:34,768 --> 01:24:38,169
And about that section key thing, something to be careful
关于那部分的关键，要小心

1948
01:24:38,237 --> 01:24:42,006
about there, too, is that whatever your sortDescriptors
在那里，无论你的sortdescriptor是什么

1949
01:24:42,075 --> 01:24:46,410
say that your rows would sort in, that has to be
假设你的行是排序的，那必须是

1950
01:24:46,478 --> 01:24:51,515
exactly the same order that your sections was sorted in.
和你的部分排序的顺序完全相同。

1951
01:24:51,583 --> 01:24:53,484
In other words, the FetchedResultsController
换句话说，FetchedResultsController

1952
01:24:53,552 --> 01:24:55,918
doesn't know how to like move things around
不知道怎么喜欢到处移动

1953
01:24:55,987 --> 01:24:58,521
because they sort out of order of their sections.
因为它们的排列顺序不同。

1954
01:24:58,590 --> 01:25:00,556
That's why a lot of times that we're doing sections,
这就是为什么我们要做的很多次，

1955
01:25:00,624 --> 01:25:04,360
the first sortDescriptor will be sort by the section key
第一个sortDescriptor将按section键排序

1956
01:25:04,428 --> 01:25:05,927
name var, right?
var名字,对吧?

1957
01:25:05,996 --> 01:25:08,163
And then the second one will be sort by what we
然后第二项会根据我们的情况来排序

1958
01:25:08,231 --> 01:25:10,865
really wanna sort by, because we have to make sure
真的想要排序，因为我们必须确定

1959
01:25:10,934 --> 01:25:13,935
that our entire table is sorted in section order.
我们的整个表按节顺序排序。

1960
01:25:15,338 --> 01:25:16,269
You see why?
你知道为什么吗?

1961
01:25:16,338 --> 01:25:17,737
Cuz otherwise it's just weird,
因为这很奇怪，

1962
01:25:17,806 --> 01:25:19,072
things would all be in the wrong places.
一切都会在错误的地方。

1963
01:25:20,274 --> 01:25:22,208
So keyThatSaysWhichAttributeIsTh-
因此keyThatSaysWhichAttributeIsTh -

1964
01:25:22,276 --> 01:25:24,810
eSectionName has to sort in the same order as your
eSectionName必须与您的相同顺序排序

1965
01:25:24,878 --> 01:25:26,044
sortDescriptors.
sortDescriptors。

1966
01:25:27,847 --> 01:25:32,216
Okay, now, I told you that NSFetchedResultsController
好的,现在,我告诉你,NSFetchedResultsController

1967
01:25:32,285 --> 01:25:33,817
watches Core Data.
手表核心数据。

1968
01:25:33,886 --> 01:25:36,953
It sees changes happening in there, and it updates it.
它看到了发生的变化，并更新了它。

1969
01:25:37,022 --> 01:25:38,888
And it does that with its delegate, okay?
它和它的委托是一样的，对吧?

1970
01:25:38,957 --> 01:25:40,489
Its delegate wants to be the tableView,
它的委托就是tableView，

1971
01:25:40,558 --> 01:25:42,124
be the tableViewController, rather.
表,。

1972
01:25:42,193 --> 01:25:44,360
Cuz it's gonna tell the tableViewController, and
因为它会告诉tableViewController

1973
01:25:44,429 --> 01:25:45,627
it sends messages like this.
它发送这样的消息。

1974
01:25:45,696 --> 01:25:48,663
So this is a typical NSFetchedResultsController
这是一个典型的NSFetchedResultsController

1975
01:25:48,731 --> 01:25:50,031
delegate method.
委托的方法。

1976
01:25:50,099 --> 01:25:53,200
Controller did change add indexPath for change type, and
控制器确实更改了更改类型的indexPath

1977
01:25:53,269 --> 01:25:55,202
here's the new indexPath.
这是新的indexPath。

1978
01:25:55,271 --> 01:25:58,105
Okay, and these change types might be deleted or
好的，这些更改类型可能会被删除

1979
01:25:58,173 --> 01:26:00,973
inserted or modified or whatever.
插入或修改。

1980
01:26:01,042 --> 01:26:04,176
Now, you have to put the code in there that would call
现在，你必须把代码放到该调用的地方

1981
01:26:04,245 --> 01:26:07,480
the right methods on the tableView to get the sections
在tableView上的正确方法获取部分

1982
01:26:07,549 --> 01:26:10,449
inserted or deleted or rows added or whatever.
插入或删除或行添加或其他内容。

1983
01:26:10,518 --> 01:26:13,819
But I'm gonna give you that code for free, okay, and
但是我要给你免费的代码，好的，还有

1984
01:26:13,888 --> 01:26:16,120
the demo that I'm gonna do on Wednesday,
我周三要做的演示，

1985
01:26:16,189 --> 01:26:19,757
I'm gonna have a class called fetchedResultsTableViewContro-
我要上课叫fetchedResultsTableViewContro -

1986
01:26:19,826 --> 01:26:21,759
ller, which is gonna be a class.
ller，这是一个课程。

1987
01:26:21,827 --> 01:26:25,796
And you can make that to be the super class of your
你可以让它成为你的超类

1988
01:26:25,864 --> 01:26:28,598
UITableViewController.
UITableViewController。

1989
01:26:28,667 --> 01:26:32,001
And you'll just inherit this implementation of
你将继承这个实现

1990
01:26:32,070 --> 01:26:36,039
the delegate, okay?
委托,对吧?

1991
01:26:36,107 --> 01:26:38,107
Yes, cuz that's what I just said.
是的，因为我刚刚说过。

1992
01:26:38,176 --> 01:26:41,276
Okay, so when you're using core data in UITableView,
当你在UITableView中使用core data时，

1993
01:26:41,345 --> 01:26:44,079
the things to remember are, you're going to subclass
要记住的是，你要去子类化

1994
01:26:44,148 --> 01:26:46,347
fetchedResultsTableViewContro- ller,
fetchedResultsTableViewContro——噢,

1995
01:26:46,416 --> 01:26:48,950
the thing I'm gonna give you, so that you implement
我要给你的东西，让你实现

1996
01:26:49,019 --> 01:26:51,585
NSFetchedResultsController delegate.
NSFetchedResultsController委托。

1997
01:26:51,654 --> 01:26:54,621
You're going to add a var to your UITableViewController
你将给UITableViewController添加一个var

1998
01:26:54,690 --> 01:26:56,856
called fetchedResultsController, and
叫,fetchedResultsController,

1999
01:26:56,925 --> 01:26:58,557
you're gonna set its value to be
你要设置它的值

2000
01:26:58,626 --> 01:27:01,995
an NSFetchedResultsController with the fetchRequest that you
一个NSFetchedResultsController fetchRequest你

2001
01:27:02,063 --> 01:27:05,464
want, okay, that you want to populate your table.
想要填充表格。

2002
01:27:05,532 --> 01:27:08,700
Then you're gonna implement your UITableView data source
然后你将实现你的UITableView数据源

2003
01:27:08,769 --> 01:27:11,770
methods using fetchedResultsController var
使用,fetchedResultsController var的方法

2004
01:27:11,839 --> 01:27:14,405
methods, just like I showed you in the slides,
方法，就像我在幻灯片中展示的一样，

2005
01:27:14,474 --> 01:27:15,907
character for character,
字符的字符,

2006
01:27:15,975 --> 01:27:18,910
you can use the exact same things that are on the slide.
你可以用同样的东西在幻灯片上。

2007
01:27:18,978 --> 01:27:21,679
Okay, and then it's all gonna magically work, all you'll
好吧，然后它就会神奇地工作，你会

2008
01:27:21,747 --> 01:27:24,014
have to do is inside your cellForRowAt indexPath,
要做的是在你的cellForRowAt indexPath中，

2009
01:27:24,082 --> 01:27:25,748
you'll have the object, the tweet,
你会有对象，推特，

2010
01:27:25,817 --> 01:27:28,284
or the Twitter user, you just gotta load up your UI.
或者推特用户，你只需要加载你的UI。

2011
01:27:29,454 --> 01:27:30,919
After you have all this set up,
在你完成这些设置之后，

2012
01:27:30,988 --> 01:27:34,022
then you can proceed to using the fetchedResultsController
然后你可以继续使用fetchedResultsController

2013
01:27:34,091 --> 01:27:35,890
in your tableViewController.
在你的表中。

2014
01:27:35,959 --> 01:27:38,826
First thing you have to do is perform fetch on
首先你要做的是执行取回

2015
01:27:38,895 --> 01:27:40,161
the fetchedResultsController.
,fetchedResultsController。

2016
01:27:40,229 --> 01:27:43,431
That will cause it to go out and do your NSFetchRequest,
这会导致它退出并执行NSFetchRequest，

2017
01:27:43,499 --> 01:27:44,564
basically.
基本上。

2018
01:27:44,633 --> 01:27:46,766
It's not gonna pull all the data over, but
它不会把所有的数据都拉过来，而是

2019
01:27:46,835 --> 01:27:49,836
it's going to basically bring over, do the same thing as if
它基本上会带来，做同样的事情

2020
01:27:49,905 --> 01:27:52,404
you had executed the fetchRequest yourself, and
你自己执行了fetchRequest

2021
01:27:52,473 --> 01:27:55,508
then you're gonna wanna do tableView View.reloadData.
然后你要做tableView。reloaddata。

2022
01:27:55,576 --> 01:27:59,144
And that's because you want all of your datasource
这是因为你想要所有的数据源

2023
01:27:59,213 --> 01:28:03,481
methods to be called, and you know that we've implemented
方法被调用，你知道我们已经实现了

2024
01:28:03,549 --> 01:28:07,118
all of them in terms of our fetch results controller as
所有这些都是我们的fetchedresultscontroller

2025
01:28:07,187 --> 01:28:09,720
showed on the previous slides there.
显示在前面的幻灯片上。

2026
01:28:09,788 --> 01:28:12,556
And the only other thing you want to remember to do
你想要记住的唯一一件事就是

2027
01:28:12,625 --> 01:28:15,692
is set your fetch results controller's delegate to be
设置你的fetchedresultscontroller的委托吗

2028
01:28:15,761 --> 01:28:19,663
yourself and, again, we use that fetch results table view
你自己，再一次，我们使用fetchedresultstable视图

2029
01:28:19,731 --> 01:28:22,732
controller code that added the delegate methods for
添加了委托方法的控制器代码

2030
01:28:22,801 --> 01:28:26,302
the fetch results controller to the UITableView controller
fetchedresultscontroller到uitableviewcontroller

2031
01:28:26,370 --> 01:28:29,638
until we can do all the things that is necessary to
直到我们能做所有必要的事情

2032
01:28:29,707 --> 01:28:33,074
be a fetchedResultsController delegate.
是一个,fetchedResultsController委托。

2033
01:28:33,143 --> 01:28:36,077
And what that buys you is that anytime in the database
在数据库中任何时候都可以买到

2034
01:28:36,146 --> 01:28:39,046
changes that would affect the NSFetchedRequest
改变会影响NSFetchedRequest

2035
01:28:39,115 --> 01:28:42,383
that you wired up to your fetchedResultsController.
你连接到你的,fetchedResultsController。

2036
01:28:42,452 --> 01:28:45,218
Then, it will use that delegate to ask the table view
然后，它将使用该委托询问表视图

2037
01:28:45,287 --> 01:28:47,154
to update the rows or sections,
更新行或节，

2038
01:28:47,223 --> 01:28:49,623
whatever happened to change.
无论发生了什么变化。

2039
01:28:49,691 --> 01:28:52,258
So let me talk a little bit about what's coming up here,
让我来简单介绍一下这里的情况，

2040
01:28:52,327 --> 01:28:55,027
on Wednesday, I'm gonna do a big demo that shows you all of
周三，我要做一个展示你们所有人的演示

2041
01:28:55,095 --> 01:28:56,828
this stuff, as usual.
这个东西,像往常一样。

2042
01:28:56,897 --> 01:28:58,530
Assignment five is going out on Wednesday,
作业五在周三开始，

2043
01:28:58,599 --> 01:28:59,831
it'll be due the next Wednesday.
下个星期三到期。

2044
01:28:59,899 --> 01:29:03,300
It's going to be to add Core Data stuff to your Smashtag.
将核心数据添加到Smashtag中。

2045
01:29:03,369 --> 01:29:08,839
On Friday, very relevant section.
周五，非常相关的部分。

2046
01:29:08,908 --> 01:29:12,276
It's using CloudKit to do a database.
它使用CloudKit来做数据库。

2047
01:29:12,344 --> 01:29:15,145
Okay? Now, Core Data and CloudKit,
好吧?Core Data和CloudKit，

2048
01:29:15,214 --> 01:29:17,380
what, what are they, how are they related?
什么，他们是什么，他们是如何联系的?

2049
01:29:17,448 --> 01:29:19,515
Well, Core Data is for
Core Data就是for

2050
01:29:19,584 --> 01:29:22,285
doing things that you would do with a relational database,
做一些与关系数据库有关的事情，

2051
01:29:22,353 --> 01:29:25,354
these powerful queries and searches and things like that.
这些强大的查询，搜索等等。

2052
01:29:25,423 --> 01:29:28,056
Cloud Kit is, what if you wanted to have a database
云工具包是，如果你想要一个数据库

2053
01:29:28,125 --> 01:29:30,692
on the network, in the cloud, okay?
在网络上，在云中?

2054
01:29:30,760 --> 01:29:34,028
A network that's being shared between multiple people or
在多人之间共享的网络

2055
01:29:34,097 --> 01:29:35,996
even by a single person on multiple,
即使是一个人，

2056
01:29:36,065 --> 01:29:38,198
on multiple of their devices, or whatever.
在他们的多个设备上，或者别的什么。

2057
01:29:38,267 --> 01:29:40,934
So there quite different in the way they approach things.
所以他们对待事物的方式有很大的不同。

2058
01:29:41,002 --> 01:29:44,971
In Core Data, we do the schema using this visual mapper.
在Core Data中，我们使用这个可视化映射器来执行模式。

2059
01:29:45,040 --> 01:29:48,607
In CloudKit, it's essentially schema on the fly.
在CloudKit中，它基本上是动态的模式。

2060
01:29:48,676 --> 01:29:51,310
As you start saving vars,
当你开始省钱的时候，

2061
01:29:51,378 --> 01:29:54,980
it starts making this schema up for you, so
它开始为你做这个模式，所以

2062
01:29:55,049 --> 01:29:57,816
it's a very different kind of way of thinking about.
这是一种非常不同的思考方式。

2063
01:29:57,885 --> 01:30:00,618
You don't think of it from a scheme of design point.
你不会从设计点的方案中考虑它。

2064
01:30:00,687 --> 01:30:03,788
In advance, there's kind of more organic as you go and
在前进的过程中，你会看到更多的有机食物

2065
01:30:03,857 --> 01:30:04,655
also you don't have to,
你也不必这么做，

2066
01:30:04,723 --> 01:30:07,590
you know, kind of create this whole scheme of front and
你知道，要创建整个前面的方案

2067
01:30:07,659 --> 01:30:10,560
describe it, you can describe it as you use it essentially.
描述它，你可以用它来描述它。

2068
01:30:10,629 --> 01:30:14,531
So it's a very interesting comparison between the two.
所以这是两个很有趣的比较。

2069
01:30:14,599 --> 01:30:16,265
I wish I had time to do CloudKit.
我希望我有时间做CloudKit。

2070
01:30:16,334 --> 01:30:18,067
Last quarter, I had the extra lectures.
上个季度，我有额外的讲座。

2071
01:30:18,135 --> 01:30:20,035
I was able to do CloudKit as a whole lecture but,
我做了一整节课的CloudKit，

2072
01:30:20,104 --> 01:30:23,205
we'll have to do it as a Friday section this week so,
我们将在这周的周五课上做，

2073
01:30:23,273 --> 01:30:24,538
don't miss that.
不要错过。

2074
01:30:24,607 --> 01:30:26,640
Next Monday is a holiday.
下星期一是假日。

2075
01:30:26,709 --> 01:30:28,542
So no lecture and then next Wednesday,
没有讲座，下周三，

2076
01:30:28,611 --> 01:30:30,111
I'm gonna go over your requirements for
我来解释一下你的要求

2077
01:30:30,179 --> 01:30:31,979
the final project, which are required to do.
最后的项目，需要做的。

2078
01:30:32,047 --> 01:30:35,915
And I'm also gonna have a lecture as well on AutoLayout.
我还会有一场关于自我介绍的讲座。

2079
01:30:35,984 --> 01:30:38,417
We'll finally get to Autolayout and
我们最终会到达自动降落场

2080
01:30:38,486 --> 01:30:41,654
how do that Autolayout stuff.
你是怎么做的?

2081
01:30:41,723 --> 01:30:43,522
I'd say, I just wanted to show you that and
我想说，我只是想给你们展示一下

2082
01:30:43,591 --> 01:30:46,025
I will see you all on Wednesday.
周三再见。

2083
01:30:46,093 --> 01:30:56,401
>> For more please visit us on Stanford.edu.
>> 更多课程详见 stanford.edu
